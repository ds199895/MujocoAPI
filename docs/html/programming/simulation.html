<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
    <link sizes="16x16" href="../_static/favicons/favicon-16x16.png" rel="icon" type="image/png">
    <link sizes="32x32" href="../_static/favicons/favicon-32x32.png" rel="icon" type="image/png">
    <link rel="apple-touch-icon" sizes="180x180" href="../_static/favicons/favicon-180x180.png" type="image/png">
    <link sizes="180x180" href="../_static/favicons/favicon-180x180.png" rel="icon" type="image/png">
    <link sizes="192x192" href="../_static/favicons/favicon-192x192.png" rel="icon" type="image/png"><link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Visualization" href="visualization.html" /><link rel="prev" title="Programming" href="index.html" />

    <meta name="generator" content="sphinx-4.5.0, furo 2022.09.29"/>
        <title>Simulation - MuJoCo Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/katex-math.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../_static/theme_overrides.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --font-stack--monospace: Inconsolata,Consolas,ui-monospace,monospace;
  --at-color: #bc103e;
  --at-val-color: #bc103e;
  --body-color: #14234b;
  --color-highlight-on-target: #e5e8ed;
  --primary-header-color: #0053d6;
  --row-odd-background-color: #f0f3f7;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #123693;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --at-color: #ff95a6;
  --at-val-color: #ff95a6;
  --body-color: #14234b;
  --color-admonition-background: #1e1e21;
  --color-highlight-on-target: #3d4045;
  --primary-header-color: #a8caff;
  --row-odd-background-color: #222326;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #458dff;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --at-color: #ff95a6;
  --at-val-color: #ff95a6;
  --body-color: #14234b;
  --color-admonition-background: #1e1e21;
  --color-highlight-on-target: #3d4045;
  --primary-header-color: #a8caff;
  --row-odd-background-color: #222326;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #458dff;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">MuJoCo Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/banner.svg" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">MuJoCo Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../computation.html">Computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modeling.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../XMLreference.html">XML Reference</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Programming</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="samples.html">Code samples</a></li>
<li class="toctree-l2"><a class="reference internal" href="extension.html">Extensions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../APIreference/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../APIreference/APItypes.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../APIreference/APIfunctions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../APIreference/APIglobals.html">Globals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../python.html">Python Bindings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../unity.html">Unity Plug-in</a></li>
<li class="toctree-l1"><a class="reference internal" href="../models.html">Model Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="simulation">
<span id="id1"></span><h1>Simulation<a class="headerlink" href="#simulation" title="Permalink to this headline">#</a></h1>
<section id="initialization">
<span id="siinitialization"></span><h2>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">#</a></h2>
<p>After the <a class="reference internal" href="index.html#inversion"><span class="std std-ref">version</span></a> check, the next step is to allocate and initialize the main data structures needed
for simulation, namely mjModel and mjData. Additional initialization steps related to visualization and callbacks will
be discussed later.</p>
<p>mjModel and mjData should never be allocated directly by the user. Instead they are allocated and initialized by the
corresponding API functions. These are very elaborate data structures, containing (arrays of) other structures,
preallocated data arrays for all intermediate results, as well as an <a class="reference internal" href="#sistack"><span class="std std-ref">internal stack</span></a>. Our strategy is
to allocate all necessary heap memory at the beginning of the simulation, and free it after the simulation is done, so
that we never have to call the C memory allocation and deallocation functions during the simulation. This is done for
speed, avoidance of memory fragmentation, future GPU portability, and ease of managing the state of the entire
simulator during a reset. It also means however that the maximal variable-memory allocation given by the
<span class="at">memory</span> attribute in the <a class="reference internal" href="../XMLreference.html#size"><span class="std std-ref">size</span></a> MJCF element, which affects the allocation of <code class="docutils literal notranslate"><span class="pre">mjData</span></code>, must be
set to a sufficiently large value. If this maximal size is exceeded during simulation, it is not increased
dynamically, but instead an error is generated. See also <a class="reference internal" href="#sidiagnostics"><span class="std std-ref">diagnostics</span></a> below.</p>
<p>First we must call one of the functions that allocates and initializes mjModel and returns a pointer to it. The
available options are</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// option 1: parse and compile XML from file</span>
<span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mj_loadXML</span><span class="p">(</span><span class="s">&quot;mymodel.xml&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">errstr</span><span class="p">,</span><span class="w"> </span><span class="n">errstr_sz</span><span class="p">);</span>

<span class="c1">// option 2: parse and compile XML from virtual file system</span>
<span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mj_loadXML</span><span class="p">(</span><span class="s">&quot;mymodel.xml&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vfs</span><span class="p">,</span><span class="w"> </span><span class="n">errstr</span><span class="p">,</span><span class="w"> </span><span class="n">errstr_sz</span><span class="p">);</span>

<span class="c1">// option 3: load precompiled model from MJB file</span>
<span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mj_loadModel</span><span class="p">(</span><span class="s">&quot;mymodel.mjb&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// option 4: load precompiled model from virtual file system</span>
<span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mj_loadModel</span><span class="p">(</span><span class="s">&quot;mymodel.mjb&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vfs</span><span class="p">);</span>

<span class="c1">// option 5: deep copy from existing mjModel</span>
<span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mj_copyModel</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">mexisting</span><span class="p">);</span>
</pre></div>
</div>
<p>All these functions return a NULL pointer if there is an error or warning. In the case of XML parsing and model
compilation, a description of the error is returned in the string provided as argument. For the remaining functions, the
low-level <a class="reference internal" href="../APIreference/APIfunctions.html#mju-error"><span class="std std-ref">mju_error</span></a> or <a class="reference internal" href="../APIreference/APIfunctions.html#mju-warning"><span class="std std-ref">mju_warning</span></a> is called with the error/warning message; see <a class="reference internal" href="#sierror"><span class="std std-ref">error handling</span></a>. Once we have a pointer to the mjModel that was allocated by one of the above functions, we pass it as
argument to all API functions that need model access. Note that most functions treat this pointer as <code class="docutils literal notranslate"><span class="pre">const</span></code>; more on
this in <a class="reference internal" href="#sichange"><span class="std std-ref">model changes</span></a> below.</p>
<p>The virtual file system (VFS) allows disk resources to be loaded in memory or created programmatically by the user, and
then MuJoCo’s load functions search for files in the VFS before accessing the disk. See <a class="reference internal" href="../APIreference/APIfunctions.html#virtualfilesystem"><span class="std std-ref">Virtual file system</span></a> in the
API Reference chapter.</p>
<p>In addition to mjModel which holds the model description, we also need mjData which is the workspace where all
computations are performed. Note that mjData is specific to a given mjModel. The API functions generally assume that
users know what they are doing, and perform minimal argument checking. If the mjModel and mjData passed to any API
function are incompatible (or NULL) the resulting behavior is unpredictable. mjData is created with</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// option 1: create mjData corresponding to given mjModel</span>
<span class="n">mjData</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mj_makeData</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

<span class="c1">// option 2: deep copy from existing mjData</span>
<span class="n">mjData</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mj_copyData</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">dexisting</span><span class="p">);</span>
</pre></div>
</div>
<p>Once both mjModel and mjData are allocated and initialized, we can call the various simulation functions. When we are
done, we can delete them with</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// deallocate existing mjModel</span>
<span class="n">mj_deleteModel</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

<span class="c1">// deallocate existing mjData</span>
<span class="n">mj_deleteData</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>The code samples illustrate the complete initialization and termination sequence.</p>
<p>MuJoCo simulations are deterministic with one exception: sensor noise can be generated when this feature is enabled.
This is done by calling the C function rand() internally. To generate the same random number sequence, call srand()
with a desired seed after the model is loaded and before the simulation starts. The model compiler calls srand(123)
internally, so as to generate random dots for procedural textures. Therefore the noise sequence in the sensor data
will change if the specification of procedural textures changes, and the user does not call srand() after model
compilation.</p>
</section>
<section id="simulation-loop">
<span id="sisimulation"></span><h2>Simulation loop<a class="headerlink" href="#simulation-loop" title="Permalink to this headline">#</a></h2>
<p>There are multiple ways to run a simulation loop in MuJoCo. The simplest way is to call the top-level simulation
function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-step"><span class="std std-ref">mj_step</span></a> in a loop such as</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// simulate until t = 10 seconds</span>
<span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">time</span><span class="o">&lt;</span><span class="mi">10</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="n">mj_step</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>This by itself will simulate the passive dynamics, because we have not provided any control signals or applied forces.
The default (and recommended) way to control the system is to implement a control callback, for example</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// simple controller applying damping to each dof</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">mycontroller</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">mjData</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nu</span><span class="o">==</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nv</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">mju_scl</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">qvel</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.1</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nv</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This illustrates two concepts. First, we are checking if the number of controls <code class="docutils literal notranslate"><span class="pre">mjModel.nu</span></code> equals the number of
DoFs <code class="docutils literal notranslate"><span class="pre">mjModel.nv</span></code>. In general, the same callback may be used with multiple models depending on how the user code is
structured, and so it is a good idea to check the model dimensions in the callback. Second, MuJoCo has a library of
BLAS-like functions that are very useful; indeed a large part of the code base consists of calling such functions
internally. The <a class="reference internal" href="../APIreference/APIfunctions.html#mju-scl"><span class="std std-ref">mju_scl</span></a> function above scales the velocity vector <code class="docutils literal notranslate"><span class="pre">mjData.qvel</span></code> by a constant feedback
gain and copies the result into the control vector <code class="docutils literal notranslate"><span class="pre">mjData.ctrl</span></code>. To install this callback, we simply assign it to the
global control callback pointer <a class="reference internal" href="../APIreference/APIglobals.html#mjcb-control"><span class="std std-ref">mjcb_control</span></a>:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// install control callback</span>
<span class="n">mjcb_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mycontroller</span><span class="p">;</span>
</pre></div>
</div>
<p>Now if we call <a class="reference internal" href="../APIreference/APIfunctions.html#mj-step"><span class="std std-ref">mj_step</span></a>, our control callback will be executed whenever the control
signal is needed by the simulation pipeline, and as a result we will end up simulating the controlled dynamics (except
damping does not really do justice to the notion of control, and is better implemented as a passive joint property,
but these are finer points).</p>
<p>Instead of relying on a control callback, we could set the control vector <code class="docutils literal notranslate"><span class="pre">mjData.ctrl</span></code> directly. Alternatively we
could set applied forces as explained in <a class="reference internal" href="#sistatecontrol"><span class="std std-ref">state and control</span></a>. If we could compute these control-
related quantities before <code class="docutils literal notranslate"><span class="pre">mj_step</span></code> is called, then the simulation loop for the controlled dynamics (without using a
control callback) would become</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">time</span><span class="o">&lt;</span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// set d-&gt;ctrl or d-&gt;qfrc_applied or d-&gt;xfrc_applied</span>
<span class="w">  </span><span class="n">mj_step</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Why would we not be able to compute the controls before <code class="docutils literal notranslate"><span class="pre">mj_step</span></code> is called? After all, isn’t this what causality
means? The answer is subtle but important, and has to do with the fact that we are simulating in discrete time. The top-
level simulation function <code class="docutils literal notranslate"><span class="pre">mj_step</span></code> basically does two things: compute the <a class="reference internal" href="#siforward"><span class="std std-ref">forward dynamics</span></a> in
continuous time, and then integrate over a time period specified by <code class="docutils literal notranslate"><span class="pre">mjModel.opt.timestep</span></code>. Forward dynamics computes
the acceleration <code class="docutils literal notranslate"><span class="pre">mjData.qacc</span></code> at time <code class="docutils literal notranslate"><span class="pre">mjData.time</span></code>, given the <a class="reference internal" href="#sistatecontrol"><span class="std std-ref">state and control</span></a> at time
<code class="docutils literal notranslate"><span class="pre">mjData.time</span></code>. The numerical integrator then advances the state and time to <code class="docutils literal notranslate"><span class="pre">mjData.time</span> <span class="pre">+</span> <span class="pre">mjModel.opt.timestep</span></code>.
Now, the control is required to be a function of the state at time <code class="docutils literal notranslate"><span class="pre">mjData.time</span></code>. However a general feedback
controller can be a very complex function, depending on various features of the state - in particular all the features
computed by MuJoCo as intermediate results of the simulation. These may include contacts, Jacobians, passive forces.
None of these quantities are available before <code class="docutils literal notranslate"><span class="pre">mj_step</span></code> is called (or rather, they are available but outdated by one
time step). In contrast, when <code class="docutils literal notranslate"><span class="pre">mj_step</span></code> calls our control callback, it does so as late in the computation as possible
- namely after all the intermediate results dependent on the state but not on the control have been computed.</p>
<p>The same effect can be achieved without using a control callback. This is done by breaking <code class="docutils literal notranslate"><span class="pre">mj_step</span></code> in two parts:
before the control is needed, and after the control is needed. The simulation loop now becomes</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">time</span><span class="o">&lt;</span><span class="mi">10</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mj_step1</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// set d-&gt;ctrl or d-&gt;qfrc_applied or d-&gt;xfrc_applied</span>
<span class="w">  </span><span class="n">mj_step2</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is one complication however: this only works with Euler integration. The Runge-Kutta integrator (as well as other
advanced integrators we plan to implement) need to evaluate the entire dynamics including the feedback control law
multiple times per step, which can only be done using a control callback. But with Euler integration, the above
separation of <code class="docutils literal notranslate"><span class="pre">mj_step</span></code> into <a class="reference internal" href="../APIreference/APIfunctions.html#mj-step1"><span class="std std-ref">mj_step1</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mj-step2"><span class="std std-ref">mj_step2</span></a> is sufficient to provide the control law with the
intermediate results of the computation.</p>
<p>To make the above discussion more clear, we provide the internal implementation of mj_step, mj_step1 and mj_step2,
omitting some code that computes timing diagnostics. The main simulation function is</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mj_step</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">mjData</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// common to all integrators</span>
<span class="w">  </span><span class="n">mj_checkPos</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_checkVel</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_forward</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_checkAcc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// compare forward and inverse solutions if enabled</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">mjENABLED</span><span class="p">(</span><span class="n">mjENBL_FWDINV</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">mj_compareFwdInv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// use selected integrator</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">opt</span><span class="p">.</span><span class="n">integrator</span><span class="o">==</span><span class="n">mjINT_RK4</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">mj_RungeKutta</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="n">mj_Euler</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The checking functions reset the simulation automatically if any numerical values have become invalid or too large.
The control callback (if any) is called from within the forward dynamics function.</p>
<p>Next we show the implementation of the two-part stepping approach, although the specifics will make sense only after
we explain the <a class="reference internal" href="#siforward"><span class="std std-ref">forward dynamics</span></a> later. Note that the control callback is now called directly, since
we have essentially unpacked the forward dynamics function. Note also that we always call the Euler integrator in
mj_step2 regardless of the setting of <code class="docutils literal notranslate"><span class="pre">mjModel.opt.integrator</span></code>.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mj_step1</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">mjData</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">mj_checkPos</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_checkVel</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_fwdPosition</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_sensorPos</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_energyPos</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_fwdVelocity</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_sensorVel</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_energyVel</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// if we had a callback we would be using mj_step, but call it anyway</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">mjcb_control</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">mjcb_control</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">mj_step2</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">mjData</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">mj_fwdActuation</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_fwdAcceleration</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_fwdConstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_sensorAcc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_checkAcc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// compare forward and inverse solutions if enabled</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">mjENABLED</span><span class="p">(</span><span class="n">mjENBL_FWDINV</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">mj_compareFwdInv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// integrate with Euler; ignore integrator option</span>
<span class="w">  </span><span class="n">mj_Euler</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="state-and-control">
<span id="sistatecontrol"></span><h2>State and control<a class="headerlink" href="#state-and-control" title="Permalink to this headline">#</a></h2>
<p>MuJoCo has a well-defined state that is easy to set, reset and advance through time. This is closely related to the
notion of state of a dynamical system. Dynamical systems are usually described in the general form</p>
<div class="highlight-Text notranslate"><div class="highlight"><pre><span></span>dx/dt = f(t,x,u)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">t</span></code> is the time, <code class="docutils literal notranslate"><span class="pre">x</span></code> is the state vector, <code class="docutils literal notranslate"><span class="pre">u</span></code> is the control vector, and <code class="docutils literal notranslate"><span class="pre">f</span></code> is the function that
computes the time-derivative of the state. This is a continuous-time formulation, and indeed the physics model
simulated by MuJoCo is defined in continuous time. Even though the numerical integrator operates in discrete time, the
main part of the computation - namely the function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-forward"><span class="std std-ref">mj_forward</span></a> - corresponds to the
continuous-time dynamics function <code class="docutils literal notranslate"><span class="pre">f(t,x,u)</span></code> above. Here we explain this correspondence.</p>
<p>The state vector in MuJoCo is:</p>
<div class="highlight-Text notranslate"><div class="highlight"><pre><span></span>x = (mjData.time, mjData.qpos, mjData.qvel, mjData.act)
</pre></div>
</div>
<p>For a second-order dynamical system the state contains only position and velocity, however MuJoCo can also model
actuators (such as cylinders and biological muscles) that have their own activation states assembled in the vector
<code class="docutils literal notranslate"><span class="pre">mjData.act</span></code>. While the physics model is time-invariant, user-defined control laws may be time-varying; in particular
control laws obtained from trajectory optimizers would normally be indexed by <code class="docutils literal notranslate"><span class="pre">mjData.time</span></code>.</p>
<p>The reason for the “official” caveat above is because user callbacks may store additional state variables that change
over time and affect the callback outputs; indeed the field <code class="docutils literal notranslate"><span class="pre">mjData.userdata</span></code> exists mostly for that purpose. Other
state-like quantities that are part of mjData and are treated as inputs by forward dynamics are <code class="docutils literal notranslate"><span class="pre">mjData.mocap_pos</span></code> and
mjData.mocap_quat. These quantities are unusual in that they are meant to change at each time step (normally driven by a
motion capture device), however this change is implemented by the user, while the simulator treats them as constants. In
that sense they are no different from all the constants in mjModel, or the function callback pointers set by the user:
such constants affect the computation, but are not part of the state vector of a dynamical system.</p>
<p>The warm-start mechanism in the constraint solver effectively introduces another state variable. This mechanism uses
the output of forward dynamics from the previous time step, namely the acceleration vector <code class="docutils literal notranslate"><span class="pre">mjData.qacc</span></code>, to estimate
the current constraint forces via inverse dynamics. This estimate then initializes the optimization algorithm in the
solver. If this algorithm runs until convergence the warm-start will affect the speed of convergence but not the final
solution (since the underlying optimization problem is convex and does not have local minima), but in practice the
algorithm is often terminated early, and so the warm-start has some (usually very small) effect on the solution.</p>
<p>Next we turn to the controls and applied forces. The control vector in MuJoCo is</p>
<div class="highlight-Text notranslate"><div class="highlight"><pre><span></span>u = (mjData.ctrl, mjData.qfrc_applied, mjData.xfrc_applied)
</pre></div>
</div>
<p>These quantities specify control signals (<code class="docutils literal notranslate"><span class="pre">mjData.ctrl</span></code>) for the actuators defined in the model, or directly apply
forces and torques specified in joint space (<code class="docutils literal notranslate"><span class="pre">mjData.qfrc_applied</span></code>) or in Cartesian space (mjData.xfrc_applied).</p>
<p>Finally, calling mj_forward which corresponds to the abstract dynamics function <code class="docutils literal notranslate"><span class="pre">f(t,x,u)</span></code> computes the
time-derivative of the state vector. The corresponding fields of mjData are</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dx</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">u</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mjData</span><span class="o">.</span><span class="n">qvel</span><span class="p">,</span> <span class="n">mjData</span><span class="o">.</span><span class="n">qacc</span><span class="p">,</span> <span class="n">mjData</span><span class="o">.</span><span class="n">act_dot</span><span class="p">)</span>
</pre></div>
</div>
<p>In the presence of quaternions (i.e., when free or ball joints are used), the position vector <code class="docutils literal notranslate"><span class="pre">mjData.qpos</span></code> has higher
dimensionality than the velocity vector <code class="docutils literal notranslate"><span class="pre">mjData.qvel</span></code> and so this is not a simple time-derivative in the sense of
scalars, but instead takes quaternion algebra into account.</p>
<p>To illustrate how the simulation state can be manipulated, suppose we have two mjData pointers src and dst
corresponding to the same mjModel, and we want to copy the entire simulation state from one to the other (leaving out
internal diagnostics which do not affect the simulation). This can be done as</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// copy simulation state</span>
<span class="n">dst</span><span class="o">-&gt;</span><span class="n">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">;</span>
<span class="n">mju_copy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">qpos</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="o">-&gt;</span><span class="n">qpos</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nq</span><span class="p">);</span>
<span class="n">mju_copy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">qvel</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="o">-&gt;</span><span class="n">qvel</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nv</span><span class="p">);</span>
<span class="n">mju_copy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">act</span><span class="p">,</span><span class="w">  </span><span class="n">src</span><span class="o">-&gt;</span><span class="n">act</span><span class="p">,</span><span class="w">  </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">na</span><span class="p">);</span>

<span class="c1">// copy mocap body pose and userdata</span>
<span class="n">mju_copy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">mocap_pos</span><span class="p">,</span><span class="w">  </span><span class="n">src</span><span class="o">-&gt;</span><span class="n">mocap_pos</span><span class="p">,</span><span class="w">  </span><span class="mi">3</span><span class="o">*</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nmocap</span><span class="p">);</span>
<span class="n">mju_copy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">mocap_quat</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="o">-&gt;</span><span class="n">mocap_quat</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nmocap</span><span class="p">);</span>
<span class="n">mju_copy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">userdata</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="o">-&gt;</span><span class="n">userdata</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nuserdata</span><span class="p">);</span>

<span class="c1">// copy warm-start acceleration</span>
<span class="n">mju_copy</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">qacc_warmstart</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="o">-&gt;</span><span class="n">qacc_warmstart</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nv</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, assuming the controls are also the same (see below) and that any installed callbacks are not relying on
user-defined state variables that are different between src and dst, calling mj_forward(m, src) or mj_step(m, src)
yields the same result as calling mj_forward(m, dst) or mj_step(m, dst) respectively. Similarly, calling mj_inverse(m,
src) yields the same result as calling mj_inverse(m, dst). More on <a class="reference internal" href="#siinverse"><span class="std std-ref">inverse dynamics</span></a> later.</p>
<p>The entire mjData can also be copied with the function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-copydata"><span class="std std-ref">mj_copyData</span></a>. This involves
less code but is much slower. Indeed using the above code to copy the state and then calling mj_forward to recompute
everything can sometimes be faster than copying mjData. This is because the preallocated buffers in mjData are large
enough to hold the intermediate results in the worst case where all possible constraints are active, but in practice
only a small fraction of constraints tend to be active simultaneously.</p>
<p>To illustrate how the control vector can be manipulated, suppose we want to clear all controls and applied forces
before calling mj_step, so as to make sure we are simulating the passive dynamics (assuming no control callback of
course). This can be done as</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// clear controls and applied forces</span>
<span class="n">mju_zero</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">);</span>
<span class="n">mju_zero</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">qfrc_applied</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nv</span><span class="p">);</span>
<span class="n">mju_zero</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">xfrc_applied</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="o">*</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nbody</span><span class="p">);</span>
</pre></div>
</div>
<p>If the user has installed a control callback <a class="reference internal" href="../APIreference/APIglobals.html#mjcb-control"><span class="std std-ref">mjcb_control</span></a> different from the default callback (which is a NULL
pointer), the user callback would be expected to set some of the above fields to non-zero. Note that MuJoCo will not
clear these controls/forces at the end of the time step. This is the responsibility of the user.</p>
<p>Also relevant in this context is the function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-resetdata"><span class="std std-ref">mj_resetData</span></a>. It sets <code class="docutils literal notranslate"><span class="pre">mjData.qpos</span></code> equal to the model reference
configuration <code class="docutils literal notranslate"><span class="pre">mjModel.qpos0</span></code>, <code class="docutils literal notranslate"><span class="pre">mjData.mocap_pos</span></code> and <code class="docutils literal notranslate"><span class="pre">mjData.mocap_quat</span></code> equal to the corresponding fixed body
poses from mjModel; and all other state and control variables to 0.</p>
</section>
<section id="forward-dynamics">
<span id="siforward"></span><h2>Forward dynamics<a class="headerlink" href="#forward-dynamics" title="Permalink to this headline">#</a></h2>
<p>The goal of forward dynamics is to compute the time-derivative of the state, namely the acceleration vector
mjData.qacc and the activation time-derivative <code class="docutils literal notranslate"><span class="pre">mjData.act_dot</span></code>. Along the way it computes everything else needed to
simulate the dynamics, including active contacts and other constraints, joint-space inertia and its LTDL
decomposition, constraint forces, sensor data and so on. All these intermediate results are available in mjData and
can be used in custom computations. As illustrated in the <a class="reference internal" href="#sisimulation"><span class="std std-ref">simulation loop</span></a> section above, the
main stepper function mj_step calls mj_forward to do most of the work, and then calls the numerical integrator to
advance the simulation state to the next discrete point in time.</p>
<p>The forward dynamics function mj_forward internally calls <a class="reference internal" href="../APIreference/APIfunctions.html#mj-forwardskip"><span class="std std-ref">mj_forwardSkip</span></a> with
skip arguments (mjSTAGE_NONE, 0), where the latter function is implemented as</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mj_forwardSkip</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">mjData</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">skipstage</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">skipsensor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// position-dependent</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">skipstage</span><span class="o">&lt;</span><span class="n">mjSTAGE_POS</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">mj_fwdPosition</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">skipsensor</span><span class="w"> </span><span class="p">)</span>
<span class="w">      </span><span class="n">mj_sensorPos</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">mjENABLED</span><span class="p">(</span><span class="n">mjENBL_ENERGY</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">      </span><span class="n">mj_energyPos</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// velocity-dependent</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">skipstage</span><span class="o">&lt;</span><span class="n">mjSTAGE_VEL</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">mj_fwdVelocity</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">skipsensor</span><span class="w"> </span><span class="p">)</span>
<span class="w">      </span><span class="n">mj_sensorVel</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">mjENABLED</span><span class="p">(</span><span class="n">mjENBL_ENERGY</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">      </span><span class="n">mj_energyVel</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// acceleration-dependent</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">mjcb_control</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">mjcb_control</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_fwdActuation</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_fwdAcceleration</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="n">mj_fwdConstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">skipsensor</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">mj_sensorAcc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that this is the same sequence of calls as in mj_step1 and mj_step2 above, except that checking of real values
and computing features such as sensor and energy are omitted. The functions being called are components of the
simulation pipeline. In turn they call sub-components.</p>
<p>The integer argument skipstage determines which parts of the computation will be skipped. The possible skip levels are</p>
<dl class="simple">
<dt>mjSTAGE_NONE</dt><dd><p>Skip nothing. Run all computations.</p>
</dd>
<dt>mjSTAGE_POS</dt><dd><p>Skip computations that depend on position but not on velocity or control or applied force. Examples of such
computations include forward kinematics, collision detection, inertia matrix computation and decomposition. These
computations typically take the most CPU time and should be skipped when possible (see below).</p>
</dd>
<dt>mjSTAGE_VEL</dt><dd><p>Skip computations that depend on position and velocity but not on control or applied force. Examples include the
computation of Coriolis and centrifugal forces, passive damping forces, reference accelerations for constraint
stabilization.</p>
</dd>
</dl>
<p>The intermediate result fields of mjData are organized into sections according to which part of the state is needed in
order to compute them. Calling mj_forwardSkip with mjSTAGE_POS assumes that the fields in the first section (position
dependent) have already been computed and does not recompute them. Similarly, mjSTAGE_VEL assumes that the fields in
the first and second sections (position and velocity dependent) have already been computed.</p>
<p>When can we use the above machinery and skip some of the computations? In a regular simulation this is not possible.
However, MuJoCo is designed not only for simulation but also for more advanced applications such as model-based
optimization, machine learning etc. In such settings one often needs to sample the dynamics at a cloud of nearby
states, or approximate derivatives via finite differences - which is another form of sampling. If the samples are
arranged on a grid, where only the position or only the velocity or only the control is different from the center
point, then the above mechanism can improve performance by about a factor of 2. The code sample <a class="reference internal" href="samples.html#saderivative"><span class="std std-ref">derivative.cc</span></a> illustrates this approach, and also shows how <a class="reference internal" href="#simultithread"><span class="std std-ref">multi-threading</span></a> can be used for
additional speedup.</p>
</section>
<section id="inverse-dynamics">
<span id="siinverse"></span><h2>Inverse dynamics<a class="headerlink" href="#inverse-dynamics" title="Permalink to this headline">#</a></h2>
<p>The computation of inverse dynamics is a unique feature of MuJoCo, and is not found in any other modern engine capable
of simulating contacts. Inverse dynamics are well-defined and very efficient to compute, thanks to our
<a class="reference internal" href="../computation.html#constraint"><span class="std std-ref">soft-constraint model</span></a> described in the Overview chapter. In fact once the position and
velocity-dependent computations that are shared with forward dynamics have been performed, the recovery of constraint
and applied forces given the acceleration comes down to an analytical formula. This is so fast that we actually use
inverse dynamics (with the acceleration computed at the previous time step) to warm-start the iterative constraint
solver in forward dynamics.</p>
<p>The inputs to inverse dynamics are the same as the state vector in forward dynamics as illustrated in <a class="reference internal" href="#sistatecontrol"><span class="std std-ref">state and
control</span></a>, but without <code class="docutils literal notranslate"><span class="pre">mjData.act</span></code> and <code class="docutils literal notranslate"><span class="pre">mjData.time</span></code>. Assuming no callbacks that depend on user-
defined state variables, the inputs to inverse dynamics are the following fields of mjData:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mjData</span><span class="o">.</span><span class="n">qpos</span><span class="p">,</span> <span class="n">mjData</span><span class="o">.</span><span class="n">qvel</span><span class="p">,</span> <span class="n">mjData</span><span class="o">.</span><span class="n">qacc</span><span class="p">,</span> <span class="n">mjData</span><span class="o">.</span><span class="n">mocap_pos</span><span class="p">,</span> <span class="n">mjData</span><span class="o">.</span><span class="n">mocap_quat</span><span class="p">)</span>
</pre></div>
</div>
<p>The main output is <code class="docutils literal notranslate"><span class="pre">mjData.qfrc_inverse</span></code>. This is the force that must have acted on the system in order to achieve the
observed acceleration <code class="docutils literal notranslate"><span class="pre">mjData.qacc</span></code>. If forward dynamics were to be computed exactly, by running the iterative solver
to full convergence, we would have</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mjData</span><span class="o">.</span><span class="n">qfrc_inverse</span> <span class="o">=</span> <span class="n">mjData</span><span class="o">.</span><span class="n">qfrc_applied</span> <span class="o">+</span> <span class="n">Jacobian</span><span class="s1">&#39;*mjData.xfrc_applied + mjData.qfrc_actuator</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mjData.qfrc_actuator</span></code> is the joint-space force produced by the actuators and the Jacobian is the mapping from
joint to Cartesian space. When the “fwdinv” flag in <code class="docutils literal notranslate"><span class="pre">mjModel.opt.enableflags</span></code> is set, the above identity is used to
monitor the quality of the forward dynamics solution. In particular, the two components of <code class="docutils literal notranslate"><span class="pre">mjData.solver_fwdinv</span></code> are
set to the L2 norm of the difference between the forward and inverse solutions, in terms of joint forces and
constraint forces respectively.</p>
<p>Similar to forward dynamics, <code class="docutils literal notranslate"><span class="pre">mj_inverse</span></code> internally calls <a class="reference internal" href="../APIreference/APIfunctions.html#mj-inverseskip"><span class="std std-ref">mj_inverseSkip</span></a> with skip arguments
<code class="docutils literal notranslate"><span class="pre">(mjSTAGE_NONE,</span> <span class="pre">0)</span></code>. The skip mechanism is the same as in forward dynamics, and can be used to speed up structured
sampling. The result <code class="docutils literal notranslate"><span class="pre">mjData.qfrc_inverse</span></code> is obtained by using the Recursive Newton-Euler algorithm to compute the
net force acting on the system, and then subtracting from it all internal forces.</p>
<p>Inverse dynamics can be used as an analytical tool when experimental data are available. This is common in robotics as
well as biomechanics. It can also be used to compute the joint torques needed to drive the system along a given
reference trajectory; this is known as computed torque control. In the context of state estimation, system
identification and optimal control, it can be used within an optimization loop to find sequences of states that
minimize physics violation along with other costs. Physics violation can be quantified as the norm of any unexplained
external force computed by inverse dynamics.</p>
</section>
<section id="multi-threading">
<span id="simultithread"></span><h2>Multi-threading<a class="headerlink" href="#multi-threading" title="Permalink to this headline">#</a></h2>
<p>When MuJoCo is used for simulation as explained in the <a class="reference internal" href="#sisimulation"><span class="std std-ref">simulation loop</span></a> section, it runs in a
single thread. We have experimented with multi-threading parts of the simulation pipeline that are computationally
expensive and amenable to parallel processing, and have concluded that the speedup is not worth using up the extra
processor cores. This is because MuJoCo is already fast compared to the overhead of launching and synchronizing
multiple threads within the same time step. If users start working with large simulations involving many floating
bodies, we may eventually implement within-step multi-threading, but for now this use case is not common.</p>
<p>Rather than speed up a single simulation, we prefer to use multi-threading to speed up sampling operations that are
common in more advanced applications. Simulation is inherently serial over time (the output of one mj_step is the
input to the next), while in sampling many calls to either forward or inverse dynamics can be executed in parallel
since there are no dependencies among them, except perhaps for a common initial state. The code sample
<a class="reference internal" href="samples.html#saderivative"><span class="std std-ref">derivative.cc</span></a> illustrates one important example of sampling, namely the approximation of
dynamics derivatives via finite differences. Here we will not repeat the material from that section, but will instead
explain MuJoCo’s general approach to parallel processing.</p>
<p>MuJoCo was designed for multi-threading from its beginning. Unlike most existing simulators where the notion of
dynamical system state is difficult to map to the software state and is often distributed among multiple objects, in
MuJoCo we have the unified data structure mjData which contains everything that changes over time. Recall the
discussion of <a class="reference internal" href="#sistatecontrol"><span class="std std-ref">state and control</span></a>. The key idea is to create one mjData for each thread, and
then use it for all per-thread computations. Below is the general template, using OpenMP to simplify thread
management.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// prepare OpenMP</span>
<span class="kt">int</span><span class="w"> </span><span class="n">nthread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_num_procs</span><span class="p">();</span><span class="w">      </span><span class="c1">// get number of logical cores</span>
<span class="n">omp_set_dynamic</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">                     </span><span class="c1">// disable dynamic scheduling</span>
<span class="n">omp_set_num_threads</span><span class="p">(</span><span class="n">nthread</span><span class="p">);</span><span class="w">           </span><span class="c1">// number of threads = number of logical cores</span>

<span class="c1">// allocate per-thread mjData</span>
<span class="n">mjData</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="n">nthread</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mj_makeData</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

<span class="c1">// ... serial code, perhaps using its own mjData* dmain</span>

<span class="c1">// parallel section</span>
<span class="cp">#pragma omp parallel</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omp_get_thread_num</span><span class="p">();</span><span class="w">       </span><span class="c1">// thread-private variable with thread id (0 to nthread-1)</span>

<span class="w">  </span><span class="c1">// ... initialize d[n] from results in serial code</span>

<span class="w">  </span><span class="c1">// thread function</span>
<span class="w">  </span><span class="n">worker</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span><span class="w">                    </span><span class="c1">// shared mjModel (read-only), per-thread mjData (read-write)</span>
<span class="p">}</span>

<span class="c1">// delete per-thread mjData</span>
<span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="n">nthread</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="n">mj_deleteData</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
</pre></div>
</div>
<p>Since all top-level API functions treat mjModel as <code class="docutils literal notranslate"><span class="pre">const</span></code>, this multi-threading scheme is safe. Each thread only
writes to its own mjData. Therefore no further synchronization among threads is needed.</p>
<p>The above template reflects a particular style of parallel processing. Instead of creating a large number of threads,
one for each work item, and letting OpenMP distribute them among processors, we rely on manual scheduling. More
precisely, we create as many threads as there are processors, and then within the <code class="docutils literal notranslate"><span class="pre">worker</span></code> function we distribute the
work explicitly among threads (not shown here, but see <a class="reference internal" href="samples.html#saderivative"><span class="std std-ref">derivative.cc</span></a> for an example). This
approach is more efficient because the thread-specific mjData is large compared to the processor cache.</p>
<p>We also use a shared mjModel for cache-efficiency. In some situations it may not be possible to use the same mjModel
for all threads. One obvious reason is that mjModel may need to be modified within the thread function. Another reason
is that the mjOption structure which is contained within mjModel may need to be adjusted (so as to control the number
of solver iterations for example), although this is likely to be the same for all parallel threads and so the
adjustment can be made in the shared model before the parallel section.</p>
<p>How the thread-specific mjData is initialized and what the thread function does is of course application-dependent.
Nevertheless, the general efficiency guidelines from the earlier sections apply here. Copying the state into the
thread-specific mjData and running MuJoCo to fill in the rest may be faster than using mj_copyData. Furthermore, the
skip mechanism available in both forward and inverse dynamics is particularly useful in parallel sampling
applications, because the samples usually have structure allowing some computations to be re-used. Finally, keep in
mind that the forward solver is iterative and good warm-start can substantially reduce the number of necessary
iterations. When samples are close to each other in state and control space, the solution for one sample (ideally in
the center) can be used to warm-start all the other samples. In this setting it is important to make sure that the
different results between nearby samples reflect genuine differences between the samples, and not different warm-start
or termination of the iterative solver.</p>
</section>
<section id="model-changes">
<span id="sichange"></span><h2>Model changes<a class="headerlink" href="#model-changes" title="Permalink to this headline">#</a></h2>
<p>The MuJoCo model contained in mjModel is supposed to represent constant physical properties of the system, and in
theory should not change after compilation. Of course in practice things are not that simple. It is often desirable to
change the physics options in <code class="docutils literal notranslate"><span class="pre">mjModel.opt</span></code>, so as to experiment with different aspects of the physics or to create
custom computations. Indeed these options are designed in such a way that the user can make arbitrary changes to them
between time steps.</p>
<p>The general rule is that real-valued parameters are safe to change, while structural integer parameters are not
because that may result in incorrect sizes or indexing. This rule does not hold universally though. Some real-valued
parameters such as inertias are expected to obey certain properties. On the other hand, some structural parameters
such as object types may be possible to change, but that depends on whether any sizes or indexes depend on them.
Arrays of type mjtByte can be changed safely, since they are binary indicators that enable and disable certain
features. The only exception here is <code class="docutils literal notranslate"><span class="pre">mjModel.tex_rgb</span></code> which is texture data represented as mjtByte.</p>
<p>When changing mjModel fields that corresponds to resources uploaded to the GPU, the user must also call the
corresponding upload function: <code class="docutils literal notranslate"><span class="pre">mjr_uploadTexture</span></code>, <code class="docutils literal notranslate"><span class="pre">mjr_uploadMesh</span></code>, <code class="docutils literal notranslate"><span class="pre">mjr_uploadHField</span></code>. Otherwise the data used
for simulation and for rendering will no longer be consistent.</p>
<p>A related consideration has to do with changing real-valued fields of mjModel that have been used by the compiler to
compute other real-valued fields: if we make a change, we want it to propagate. That is what the function
<a class="reference internal" href="../APIreference/APIfunctions.html#mj-setconst"><span class="std std-ref">mj_setConst</span></a> does: it updates all derived fields of mjModel. These are fields whose names end with “0”,
corresponding to precomputed quantities when the model is in the reference configuration <code class="docutils literal notranslate"><span class="pre">mjModel.qpos0</span></code>.</p>
<p>Finally, if changes are made to mjModel at runtime, it may be desirable to save them back to the XML. The function
<a class="reference internal" href="../APIreference/APIfunctions.html#mj-savelastxml"><span class="std std-ref">mj_saveLastXML</span></a> does that in a limited sense: it copies all real-valued parameters from mjModel back to the
internal mjCModel, and then saves it as XML. This does not cover all possible changes that the user could have made.
The only way to guarantee that all changes are saved is to save the model as a binary MJB file with the function
<a class="reference internal" href="../APIreference/APIfunctions.html#mj-savemodel"><span class="std std-ref">mj_saveModel</span></a>, or even better, make the changes directly in the XML. Unfortunately there are situations where
changes need to be made programmatically, as in system identification for example, and this can only be done with the
compiled model. So in summary, we have reasonable but not perfect mechanisms for saving model changes. The reason for
this lack of perfection is that we are working with a compiled model, so this is like changing a binary executable and
asking a “decompiler” to make corresponding changes to the C code - it is just not possible in general.</p>
</section>
<section id="data-layout-and-buffer-allocation">
<span id="silayout"></span><h2>Data layout and buffer allocation<a class="headerlink" href="#data-layout-and-buffer-allocation" title="Permalink to this headline">#</a></h2>
<p>All matrices in MuJoCo are in <strong>row-major</strong> format. For example, the linear memory array (a0, a1, … a5) represents the
2-by-3 matrix</p>
<div class="highlight-Text notranslate"><div class="highlight"><pre><span></span>a0 a1 a2
a3 a4 a5
</pre></div>
</div>
<p>This convention has traditionally been associated with C, while the opposite column-major convention has been
associated with Fortran. There is no particular reason to choose one over the other, but whatever the choice is, it is
essential to keep it in mind at all times. All MuJoCo utility functions that operate on matrices, such as
<a class="reference internal" href="../APIreference/APIfunctions.html#mju-mulmatmat"><span class="std std-ref">mju_mulMatMat</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mju-mulmatvec"><span class="std std-ref">mju_mulMatVec</span></a> etc. assume this matrix layout. For vectors there is of course no
difference between row-major and column-major formats.</p>
<p>When possible, MuJoCo exploits sparsity. This can make all the difference between O(N) and O(N^3) scaling. The inertia
matrix <code class="docutils literal notranslate"><span class="pre">mjData.qM</span></code> and its LTDL factorization <code class="docutils literal notranslate"><span class="pre">mjData.qLD</span></code> are always represented as sparse, using a custom
indexing format designed for matrices that correspond to tree topology. The functions <a class="reference internal" href="../APIreference/APIfunctions.html#mj-factorm"><span class="std std-ref">mj_factorM</span></a>,
<a class="reference internal" href="../APIreference/APIfunctions.html#mj-solvem"><span class="std std-ref">mj_solveM</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mj-solvem2"><span class="std std-ref">mj_solveM2</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mj-mulm"><span class="std std-ref">mj_mulM</span></a> are used for sparse factorization, substitution and
matrix-vector multiplication. The user can also convert these matrices to dense format with the function
<a class="reference internal" href="../APIreference/APIfunctions.html#mj-fullm"><span class="std std-ref">mj_fullM</span></a> although MuJoCo never does that internally.</p>
<p>The constraint Jacobian matrix <code class="docutils literal notranslate"><span class="pre">mjData.efc_J</span></code> is represented as sparse whenever the sparse Jacobian option is
enabled. The function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-issparse"><span class="std std-ref">mj_isSparse</span></a> can be used to determine if sparse format is currently in use. In that case
the transposed Jacobian <code class="docutils literal notranslate"><span class="pre">mjData.efc_JT</span></code> is also computed, and the inverse constraint inertia <code class="docutils literal notranslate"><span class="pre">mjData.efc_AR</span></code>
becomes sparse. Sparse matrices are stored in the compressed sparse row (CSR) format. For a generic matrix A with
dimensionality m-by-n, this format is:</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 10%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>A</p></td>
<td><p>m * n</p></td>
<td><p>Real-valued data</p></td>
</tr>
<tr class="row-odd"><td><p>A_rownnz</p></td>
<td><p>m</p></td>
<td><p>Number of non-zeros per row</p></td>
</tr>
<tr class="row-even"><td><p>A_rowadr</p></td>
<td><p>m</p></td>
<td><p>Starting index of row data in A and A_colind</p></td>
</tr>
<tr class="row-odd"><td><p>A_colind</p></td>
<td><p>m * n</p></td>
<td><p>Column indices</p></td>
</tr>
</tbody>
</table>
</div>
<p>Thus A[A_rowadr[r]+k] is the element of the underlying dense matrix at row r and column A_colind[A_rowadr[r]+k], where
k &lt; A_rownnz[r]. Normally m*n storage is not necessary (assuming the matrix is indeed sparse) but we allocate space
for the worst-case scenario. Furthermore, in operations that can change the sparsity pattern, it is more efficient to
spread out the data so that we do not have to perform many memory moves when inserting new data. We call this sparse
layout “uncompressed”. It is still a valid layout, but instead of A_rowadr[r] = A_rowadr[r-1] + A_rownnz[r] which is
the standard convention, we set A_rowadr[r] = r*n. MuJoCo uses sparse matrices internally</p>
<p>To represent 3D orientations and rotations, MuJoCo uses unit quaternions - namely 4D unit vectors arranged as q = (w,
x, y, z). Here (x, y, z) is the rotation axis unit vector scaled by sin(a/2), where a is the rotation angle in
radians, and w = cos(a/2). Thus the quaternion corresponding to a null rotation is (1, 0, 0, 0). This is the default
setting of all quaternions in MJCF.</p>
<p>MuJoCo also uses 6D spatial vectors internally. These are quantities in mjData prefixed with ‘c’, namely cvel, cacc,
cdot, etc. They are spatial motion and force vectors that combine a 3D rotational component followed by a 3D
translational component. We do not provide utility functions for working with them, and documenting them is beyond our
scope here. See Roy Featherstone’s webpage on <a class="reference external" href="http://royfeatherstone.org/spatial/">Spatial Algebra</a>. The unusual
order (rotation before translation) is based on this material, and was apparently standard convention in the past.</p>
<p>The data structures mjModel and mjData contain many pointers to preallocated buffers. The constructors of these data
structures (mj_makeModel and mj_makeData) allocate one large buffer, namely <code class="docutils literal notranslate"><span class="pre">mjModel.buffer</span></code> and <code class="docutils literal notranslate"><span class="pre">mjData.buffer</span></code>,
and then partition it and set all the other pointers in it. mjData also contains a stack outside this main buffer, as
discussed below. Even if two pointers appear one after the other, say <code class="docutils literal notranslate"><span class="pre">mjData.qpos</span></code> and <code class="docutils literal notranslate"><span class="pre">mjData.qvel</span></code>, do not
assume that the data arrays are contiguous and there is no gap between them. The constructors implement byte-alignment
for each data array, and skip bytes when necessary. So if you want to copy <code class="docutils literal notranslate"><span class="pre">mjData.qpos</span></code> and <code class="docutils literal notranslate"><span class="pre">mjData.qvel</span></code>, the
correct way to do it is the hard way:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// do this</span>
<span class="n">mju_copy</span><span class="p">(</span><span class="n">myqpos</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">qpos</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nq</span><span class="p">);</span>
<span class="n">mju_copy</span><span class="p">(</span><span class="n">myqvel</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">qvel</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nv</span><span class="p">);</span>

<span class="c1">// DO NOT do this, there may be padding at the end of d-&gt;qpos</span>
<span class="n">mju_copy</span><span class="p">(</span><span class="n">myqposqvel</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">qpos</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nq</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nv</span><span class="p">);</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../APIreference/APIglobals.html#tyxmacro"><span class="std std-ref">X Macros</span></a> defined in the optional header file <code class="docutils literal notranslate"><span class="pre">mjxmacro.h</span></code> can be used to automate allocation of
data structure that match mjModel and mjData, for example when writing a MuJoCo wrapper for a scripting language. In
the code sample <a class="reference internal" href="samples.html#satestxml"><span class="std std-ref">testxml.cc</span></a> we use these unusual macros to compare all data arrays from two instances
of mjModel and find the one with the largest difference. Apparently X Macros were invented in the 1960’s for assembly
language, and remain a great idea.</p>
</section>
<section id="internal-stack">
<span id="sistack"></span><h2>Internal stack<a class="headerlink" href="#internal-stack" title="Permalink to this headline">#</a></h2>
<p>MuJoCo allocates and manages dynamic memory in an “arena” space in <code class="docutils literal notranslate"><span class="pre">mjData.arena</span></code>. The arena memory space
contains two types of dynamically allocated memory:</p>
<blockquote>
<div><ul class="simple">
<li><p>Memory related to constraints, since the number of contacts is unknown at the beginning of a step.</p></li>
<li><p>Memory for temporary variables, managed by an internal stack mechanism.</p></li>
</ul>
</div></blockquote>
<p>See <a class="reference internal" href="../modeling.html#csize"><span class="std std-ref">Memory allocation</span></a> for details regarding the layout of the arena and internal stack.</p>
<p>Most top-level MuJoCo functions allocate space on the <a class="reference internal" href="../APIreference/APItypes.html#mjdata"><span class="std std-ref">mjData</span></a> stack, use it for internal computations, and then
deallocate it. They cannot do this with the regular C stack because the allocation size is determined dynamically at
runtime. Calling the heap memory management functions would be inefficient and result in fragmentation – thus a custom
stack. When any MuJoCo function is called, upon return the value of <code class="docutils literal notranslate"><span class="pre">mjData.pstack</span></code> is the same. The only exception is
the function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-resetdata"><span class="std std-ref">mj_resetData</span></a> and its variants: they set <code class="docutils literal notranslate"><span class="pre">mjData.pstack</span> <span class="pre">=</span> <span class="pre">0</span></code>. Note that this function is called
internally when an instability is detected in <a class="reference internal" href="../APIreference/APIfunctions.html#mj-step"><span class="std std-ref">mj_step</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mj-step1"><span class="std std-ref">mj_step1</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mj-step2"><span class="std std-ref">mj_step2</span></a>. So if user functions
take advantage of the custom stack, this needs to be done in-between MuJoCo calls that have the potential to reset the
simulation.</p>
<p>Below is the general template for using the custom stack in user code. This assumes that <code class="docutils literal notranslate"><span class="pre">mjData\*</span> <span class="pre">d</span></code> is defined in
the scope. If not, saving and restoring the stack pointer should be done manually instead of using the
<a class="reference internal" href="../APIreference/APIfunctions.html#mjmarkstack"><span class="std std-ref">mjMARKSTACK</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mjfreestack"><span class="std std-ref">mjFREESTACK</span></a> macros.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// save stack pointer in the &quot;hidden&quot; variable _mark</span>
<span class="n">mjMARKSTACK</span><span class="p">;</span>

<span class="c1">// allocate space</span>
<span class="n">mjtNum</span><span class="o">*</span><span class="w"> </span><span class="n">myqpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mj_stackAllocNum</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nq</span><span class="p">);</span>
<span class="n">mjtNum</span><span class="o">*</span><span class="w"> </span><span class="n">myqvel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mj_stackAllocNum</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">nv</span><span class="p">);</span>

<span class="c1">// restore stack from _mark</span>
<span class="n">mjFREESTACK</span><span class="p">;</span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-stackallocnum"><span class="std std-ref">mj_stackAllocNum</span></a> checks if there is enough space, and if so it advances the stack pointer,
otherwise it triggers an error. It also keeps track of the maximum stack allocation;
see <a class="reference internal" href="#sidiagnostics"><span class="std std-ref">diagnostics</span></a> below. Note that <a class="reference internal" href="../APIreference/APIfunctions.html#mj-stackallocnum"><span class="std std-ref">mj_stackAllocNum</span></a> is only used for allocating
<code class="docutils literal notranslate"><span class="pre">mjtNum</span></code> arrays, the most common type of array. <a class="reference internal" href="../APIreference/APIfunctions.html#mj-stackallocint"><span class="std std-ref">mj_stackAllocInt</span></a> is provided for integer array allocation,
and <a class="reference internal" href="../APIreference/APIfunctions.html#mj-stackalloc"><span class="std std-ref">mj_stackAlloc</span></a> is provided for allocation of arbitrary number of bytes and alignment.</p>
</section>
<section id="errors-warnings-memory-allocation">
<span id="sierror"></span><h2>Errors, warnings, memory allocation<a class="headerlink" href="#errors-warnings-memory-allocation" title="Permalink to this headline">#</a></h2>
<p>When a terminal error occurs, MuJoCo calls the function <a class="reference internal" href="../APIreference/APIfunctions.html#mju-error"><span class="std std-ref">mju_error</span></a> internally. Here is what mju_error does:</p>
<ol class="arabic simple">
<li><p>Append the error message at the end of the file MUJOCO_LOG.TXT in the program directory (create the file if it does
not exist). Also write the date and time along with the error message.</p></li>
<li><p>If the user error callback <a class="reference internal" href="../APIreference/APIglobals.html#mju-user-error"><span class="std std-ref">mju_user_error</span></a> is installed, call that function with the error message as
argument. Otherwise, print the error message and “Press Enter to exit…” to standard output. Then wait for any
keyboard input, and then terminate the simulator with failure.</p></li>
</ol>
<p>If a user error callback is installed, it must <strong>not</strong> return, otherwise the behavior of the simulator is undefined.
The idea here is that if mju_error is called, the simulation cannot continue and the user is expected to make some
change such that the error condition is avoided. The error messages are self-explanatory.</p>
<p>One situation where it is desirable to continue even after an error is an interactive simulator that fails to load a
model file. This could be because the user provided the wrong file name, or because model compilation failed. This is
handled by a special mechanism which avoids calling mju_error. The model loading functions
<a class="reference internal" href="../APIreference/APIfunctions.html#mj-loadxml"><span class="std std-ref">mj_loadXML</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mj-loadmodel"><span class="std std-ref">mj_loadModel</span></a> return NULL if the
operation fails, and there is no need to exit the program. In the case of mj_loadXML there is an output argument
containing the parser or compiler error that caused the failure, while mj_loadModel generates corresponding warnings
(see below).</p>
<p>Internally mj_loadXML actually uses the mju_error mechanism, by temporarily installing a “user” handler that triggers
a C++ exception, which is then intercepted. This is possible because the parser, compiler and runtime are compiled and
linked together, and use the same copy of the C/C++ memory manager and standard library. If the user implements an
error callback that triggers a C++ exception, this will be in their workspace which is not necessarily the same as the
MuJoCo library workspace, and so it is not clear what will happen; the outcome probably depends on the compiler and
platform. It is better to avoid this approach and simply exit when mju_error is called (which is the default behavior
in the absence of a user handler).</p>
<p>MuJoCo can also generate warnings. They indicate conditions that are likely to cause numerical inaccuracies, but can
also indicate problems with loading a model and other problematic situations where the simulator is nevertheless able
to continue normal operation. The warning mechanism has two levels. The high-level is implemented with the function
<a class="reference internal" href="../APIreference/APIfunctions.html#mj-warning"><span class="std std-ref">mj_warning</span></a>. It registers a warning in mjData as explained in more detail in the <a class="reference internal" href="#sidiagnostics"><span class="std std-ref">diagnostics</span></a> section below, and also calls the low-level function <a class="reference internal" href="../APIreference/APIfunctions.html#mju-warning"><span class="std std-ref">mju_warning</span></a>. Alternatively, the low-level
function may be called directly (from within mj_loadModel for example) without registering a warning in mjData. This
is done in places where mjData is not available.</p>
<p>mju_warning does the following: if the user callback <a class="reference internal" href="../APIreference/APIglobals.html#mju-user-warning"><span class="std std-ref">mju_user_warning</span></a> is installed, it calls that callback.
Otherwise it appends the warning message to MUJOCO_LOG.TXT and also does a printf, similar to mju_error but without
exiting. When MuJoCo wrappers are developed for environments such as MATLAB, it makes sense to install a user callback
which prints warnings in the command window (with mexPrintf).</p>
<p>When MuJoCo allocates and frees memory on the heap, it always uses the functions <a class="reference internal" href="../APIreference/APIfunctions.html#mju-malloc"><span class="std std-ref">mju_malloc</span></a> and
<a class="reference internal" href="../APIreference/APIfunctions.html#mju-free"><span class="std std-ref">mju_free</span></a>. These functions call the user callbacks <a class="reference internal" href="../APIreference/APIglobals.html#mju-user-malloc"><span class="std std-ref">mju_user_malloc</span></a> and <a class="reference internal" href="../APIreference/APIglobals.html#mju-user-free"><span class="std std-ref">mju_user_free</span></a> when
installed, otherwise they call the standard C functions malloc and free. The reason for this indirection is because
users may want MuJoCo to use a heap under their control. In MATLAB for example, a user callback for memory allocation
would use mxmalloc and mexMakeArrayPersistent.</p>
</section>
<section id="diagnostics">
<span id="sidiagnostics"></span><h2>Diagnostics<a class="headerlink" href="#diagnostics" title="Permalink to this headline">#</a></h2>
<p>MuJoCo has several built-in diagnostics mechanisms that can be used to fine-tune the model. Their outputs are grouped
in the diagnostics section at the beginning of mjData.</p>
<p>When the simulator encounters a situation that is not a terminal error but is nevertheless suspicious and likely to
result in inaccurate numerical results, it triggers a warning. There are several possible warning types, indexed by
the enum type <a class="reference internal" href="../APIreference/APItypes.html#mjtwarning"><span class="std std-ref">mjtWarning</span></a>. The array <code class="docutils literal notranslate"><span class="pre">mjData.warning</span></code> contains one <a class="reference internal" href="../APIreference/APItypes.html#mjwarningstat"><span class="std std-ref">mjWarningStat</span></a> data structure per
warning type, indicating how many times each warning type has been triggered since the last reset and any information
about the warning (usually the index of the problematic model element). The counters are cleared upon reset. When a
warning of a given type is first triggered, the warning text is also printed by mju_warning as documented in
<a class="reference internal" href="#sierror"><span class="std std-ref">error and memory</span></a> above. All this is done by the function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-warning"><span class="std std-ref">mj_warning</span></a> which the simulator calls
internally when it encounters a warning. The user can also call this function directly to emulate a warning.</p>
<p>When a model needs to be optimized for high-speed simulation, it is important to know where in the pipeline the CPU
time is spent. This can in turn suggest which parts of the model to simplify or how to design the user application.
MuJoCo provides an extensive profiling mechanism. It involves multiple timers indexed by the enum type
<a class="reference internal" href="../APIreference/APItypes.html#mjttimer"><span class="std std-ref">mjtTimer</span></a>. Each timer corresponds to a top-level API function, or to a component of such a function. Similar to
warnings, timer information accumulates and is only cleared on reset. The array <code class="docutils literal notranslate"><span class="pre">mjData.timer</span></code> contains one
<a class="reference internal" href="../APIreference/APItypes.html#mjtimerstat"><span class="std std-ref">mjTimerStat</span></a> data structure per timer. The average duration per call for a given timer (corresponding to
<code class="docutils literal notranslate"><span class="pre">mj_step</span></code> in the example below) can be computed as:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">mjtNum</span><span class="w"> </span><span class="n">avtm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">[</span><span class="n">mjTIMER_STEP</span><span class="p">].</span><span class="n">duration</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">mjMAX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">[</span><span class="n">mjTIMER_STEP</span><span class="p">].</span><span class="n">number</span><span class="p">);</span>
</pre></div>
</div>
<p>This mechanism is built into MuJoCo, but it only works when the timer callback <a class="reference internal" href="../APIreference/APIglobals.html#mjcb-time"><span class="std std-ref">mjcb_time</span></a> is installed by the
user. Otherwise all timer durations are 0. The reason for this design is because there is no platform-independent way
to implement high-resolution timers in C without bringing in additional dependencies. Also, most of the time the user
does not need timing, and in that case there is no reason to call timing functions.</p>
<p>One part of the simulation pipeline that needs to be monitored closely is the iterative constraint solver. The
simplest diagnostic here is <code class="docutils literal notranslate"><span class="pre">mjData.solver_iter</span></code> which shows how many iterations the solver took on the last call to
mj_step or <code class="docutils literal notranslate"><span class="pre">mj_forward</span></code>. Note that the solver has tolerance parameters for early termination, so this number is
usually smaller than the maximum number of iterations allowed. The array <code class="docutils literal notranslate"><span class="pre">mjData.solver</span></code> contains one
<a class="reference internal" href="../APIreference/APItypes.html#mjsolverstat"><span class="std std-ref">mjSolverStat</span></a> data structure per iteration of the constraint solver, with information about the constraint state
and line search.</p>
<p>When the option <span class="at">fwdinv</span> is enabled in <code class="docutils literal notranslate"><span class="pre">mjModel.opt.enableflags</span></code>, the field <code class="docutils literal notranslate"><span class="pre">mjData.fwdinv</span></code> is also populated.
It contains the difference between the forward and inverse dynamics, in terms of generalized forces and constraint
forces. Recall that that the inverse dynamics use analytical formulas and are always exact, thus any discrepancy is
due to poor convergence of the iterative solver in the forward dynamics. The numbers in <code class="docutils literal notranslate"><span class="pre">mjData.solver</span></code> near
termination have similar order-of-magnitude as the numbers in <code class="docutils literal notranslate"><span class="pre">mjData.fwdinv</span></code>, but nevertheless these are two
different diagnostics.</p>
<p>Since MuJoCo’s runtime works with compiled models, memory is preallocated when a model is compiled or loaded. Recall the
<span class="at">memory</span> attribute of the <a class="reference internal" href="../XMLreference.html#size"><span class="std std-ref">size</span></a> element in MJCF. It determines the preallocated space for dynamic
arrays. How is the user supposed to know what the appropriate value is? If there were a reliable recipe we would have
implemented it in the compiler, but there isn’t one. The theoretical worst-case, namely all geoms contacting all other
geoms, calls for huge allocation which is almost never needed in practice. Our approach is to provide default settings
in MJCF which are sufficient for most models, and allow the user to adjust them manually with the above attribute. If
the simulator runs out of dynamic memory at runtime it will trigger an error. When such errors are triggered, the user
should increase <span class="at">memory</span>. The field <code class="docutils literal notranslate"><span class="pre">mjData.maxuse_arena</span></code> is designed to help with this adjustment. It keeps track
of the maximum arena use since the last reset. So one strategy is to make very large allocation, then monitor
<code class="docutils literal notranslate"><span class="pre">mjData.maxuse_memory</span></code> statistics during typical simulations, and use it to reduce the allocation.</p>
<p>The kinetic and potential energy are computed and stored in <code class="docutils literal notranslate"><span class="pre">mjData.energy</span></code> when the corresponding flag in
<code class="docutils literal notranslate"><span class="pre">mjModel.opt.enableflags</span></code> is set. This can be used as another diagnostic. In general, simulation instability is
associated with increasing energy. In some special cases (when all unilateral constraints, actuators and dissipative
forces are disabled) the underlying physical system is energy-conserving. In that case any temporal fluctuations in
the total energy indicate inaccuracies in numerical integration. For such systems the Runge-Kutta integrator has much
better performance than the default semi-implicit Euler integrator.</p>
<p>Finally, the user can implement additional diagnostics as needed. Two examples were provided in the code samples
<code class="docutils literal notranslate"><span class="pre">testxml.cc</span></code> and <code class="docutils literal notranslate"><span class="pre">derivative.cc</span></code>, where we computed model mismatches after save and load, and assessed the accuracy
of the numerical derivatives respectively. Key to such diagnostics is to implement two different algorithms or
simulation paths that compute the same quantity, and compare the results numerically. This type of sanity check is
essential when dealing with complex dynamical systems where we do not really know what the numerical output should be;
if we knew that, we would not be using a simulator in the first place.</p>
</section>
<section id="jacobians">
<span id="sijacobian"></span><h2>Jacobians<a class="headerlink" href="#jacobians" title="Permalink to this headline">#</a></h2>
<p>The derivative of any vector function with respect to its vector argument is called Jacobian. When this term is used
in multi-joint kinematics and dynamics, it refers to the derivative of some spatial quantity as a function of the
system configuration. In that case the Jacobian is also a linear map that operates on vectors in the (co)tangent space
to the configuration manifold - such as velocities, momenta, accelerations, forces. One caveat here is that the system
configuration encoded in <code class="docutils literal notranslate"><span class="pre">mjData.qpos</span></code> has dimensionality <code class="docutils literal notranslate"><span class="pre">mjModel.nq</span></code>, while the tangent space has dimensionality
<code class="docutils literal notranslate"><span class="pre">mjModel.nv</span></code>, and the latter is smaller when quaternion joints are present. So the size of the Jacobian matrix is
N-by-<code class="docutils literal notranslate"><span class="pre">mjModel.nv</span></code> where N is the dimensionality of the spatial quantity being differentiated.</p>
<p>MuJoCo can differentiate analytically many spatial quantities. These include tendon lengths, actuator transmission
lengths, end-effector poses, contact and other constraint violations. In the case of tendons and actuator
transmissions the corresponding quantities are <code class="docutils literal notranslate"><span class="pre">mjData.ten_moment</span></code> and <code class="docutils literal notranslate"><span class="pre">mjData.actuator_moment</span></code>; we call them
moment arms but mathematically they are Jacobians. The Jacobian matrix of all scalar constraint violations is stored in
<code class="docutils literal notranslate"><span class="pre">mjData.efc_J</span></code>. Note that we are talking about constraint violations rather than the constraints themselves. This is
because constraint violations have units of length, i.e., they are spatial quantities that we can differentiate.
Constraints are more abstract entities and it is not clear what it means to differentiate them.</p>
<p>Beyond these automatically-computed Jacobians, we provide support functions allowing the user to compute additional
Jacobians on demand. The main function for doing this is <a class="reference internal" href="../APIreference/APIfunctions.html#mj-jac"><span class="std std-ref">mj_jac</span></a>. It is given a 3D point and a MuJoCo body to
which this point is considered to be attached. <code class="docutils literal notranslate"><span class="pre">mj_jac</span></code> then computes both the translational and rotational
Jacobians, which tell us how a spatial frame anchored at the given point will translate and rotate if we make a small
change to the kinematic configuration. More precisely, the Jacobian maps joint velocities to end-effector velocities,
while the transpose of the Jacobian maps end-effector forces to joint forces. There are also several other
<code class="docutils literal notranslate"><span class="pre">mj_jacXXX</span></code> functions; these are convenience functions that call the main <code class="docutils literal notranslate"><span class="pre">mj_jac</span></code> function with different points
of interest - such as a body center of mass, geom center etc.</p>
<p>The ability to compute end-effector Jacobians exactly and efficiently is a key advantage of working in joint
coordinates. Such Jacobians are the foundation of many control schemes that map end-effector errors to actuator
commands suitable for suppressing those errors. The computation of end-effector Jacobians in MuJoCo via the <code class="docutils literal notranslate"><span class="pre">mj_jac</span></code>
function is essentially free in terms of CPU cost; so do not hesitate to use this function.</p>
</section>
<section id="contacts">
<span id="sicontact"></span><h2>Contacts<a class="headerlink" href="#contacts" title="Permalink to this headline">#</a></h2>
<p>Collision detection and solving for contact forces were explained in detail in the <a class="reference internal" href="../computation.html"><span class="doc">Computation</span></a> chapter. Here
we further clarify contact processing from a programming perspective.</p>
<p>The collision detection stage finds contacts between geoms, and records them in the array <code class="docutils literal notranslate"><span class="pre">mjData.contact</span></code> of
<a class="reference internal" href="../APIreference/APItypes.html#mjcontact"><span class="std std-ref">mjContact</span></a> data structures. They are sorted such that multiple contacts between the same pair of bodies are
contiguous (note that one body can have multiple geoms attached to it), and the body pairs themselves are sorted such
that the first body acts as the major index and the second body as the minor index. Not all detected contacts are
included in the contact force computation. When a contact is included, its mjContact.exclude field is 0, and its
mjContact.efc_address is the address in the list of active scalar constraints. Reasons for exclusion can be the
<span class="at">gap</span> attribute of <a class="reference internal" href="../XMLreference.html#body-geom"><span class="std std-ref">geom</span></a>, as well as certain kinds of internal processing that use virtual contacts
for intermediate computations.</p>
<p>The list <code class="docutils literal notranslate"><span class="pre">mjData.contact</span></code> is generated by the position stage of both forward and inverse dynamics. This is done
automatically. However the user can override the internal collision detection functions, for example to implement
non-convex mesh collisions, or to replace some of the convex collision functions we use with geom-specific primitives
beyond the ones provided by MuJoCo. The global 2D array <a class="reference internal" href="../APIreference/APIglobals.html#mjcollisionfunc"><span class="std std-ref">mjCOLLISIONFUNC</span></a> contains the collision function pointer
for each pair of geom types (in the upper-left triangle). To replace them, simply set these pointers to your
functions. The collision function type is <a class="reference internal" href="../APIreference/APItypes.html#mjfcollision"><span class="std std-ref">mjfCollision</span></a>. When user collision functions detect contacts, they
should construct an mjvContact structure for each contact and then call the function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-addcontact"><span class="std std-ref">mj_addContact</span></a> to add that
contact to <code class="docutils literal notranslate"><span class="pre">mjData.contact</span></code>. The reference documentation of mj_addContact explains which fields of mjContact must be
filled in by custom collision functions. Note that the functions we are talking about here correspond to near-phase
collisions, and are called only after the list of candidate geom pairs has been constructed by the internal
broad-phase collision mechanism.</p>
<p>After the constraint forces have been computed, the vector of forces for contact <code class="docutils literal notranslate"><span class="pre">i</span></code> starts at:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">mjtNum</span><span class="o">*</span><span class="w"> </span><span class="n">contactforce</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">efc_force</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">contact</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">efc_address</span><span class="p">;</span>
</pre></div>
</div>
<p>and similarly for all other <code class="docutils literal notranslate"><span class="pre">efc_XXX</span></code> vectors. Keep in mind that the contact friction cone can be pyramidal or
elliptic, depending on which solver is selected in <code class="docutils literal notranslate"><span class="pre">mjModel.opt</span></code>. The function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-ispyramidal"><span class="std std-ref">mj_isPyramidal</span></a>
can be used to determine which friction cone type is used. For pyramidal cones, the interpretation of the contact force
(whose address we computed above) is non-trivial, because the components are forces along redundant non-orthogonal axes
corresponding to the edges of the pyramid. The function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-contactforce"><span class="std std-ref">mj_contactForce</span></a> can be
used to convert the force generated by a given contact into a more intuitive format: a 3D force followed by a 3D toque.
The torque component will be zero when <span class="at">condim</span> is 1 or 3, and non-zero otherwise. This force and torque are
expressed in the contact frame given by mjContact.frame. Unlike all other matrices in mjData, this matrix is stored in
transposed form. Normally a 3-by-3 matrix corresponding to a coordinate frame would have the frame axes along the
columns. Here the axes are along the rows of the matrix. Thus, given that MuJoCo uses row-major format, the contact
normal axis (which is the X axis of the contact frame by our convention) is in position mjContact.frame[0-2], the Y axis
is in [3-5] and the Z axis is in [6-8]. The reason for this arrangement is because we can have frictionless contacts
where only the normal axis is used, so it makes sense to have its coordinates in the first 3 positions of
<code class="docutils literal notranslate"><span class="pre">mjContact.frame</span></code>.</p>
</section>
<section id="coordinate-frames-and-transformations">
<span id="sicoordinate"></span><h2>Coordinate frames and transformations<a class="headerlink" href="#coordinate-frames-and-transformations" title="Permalink to this headline">#</a></h2>
<p>There are multiple coordinate frames used in MuJoCo. The top-level distinction is between joint coordinates and
Cartesian coordinates. The mapping from the vector of joints coordinates to the Cartesian positions and orientations
of all bodies is called forward kinematics and is the first step in the physics pipeline. The opposite mapping is
called inverse kinematics but it is not uniquely defined and is not implemented in MuJoCo. Recall that mappings
between the tangent spaces (i.e., joint velocities and forces to Cartesian velocities and forces) are given by the body
Jacobians.</p>
<p>Here we explain further subtleties and subdivisions of the coordinate frames, and summarize the available
transformation functions. In joint coordinates, the only complication is that the position vector <code class="docutils literal notranslate"><span class="pre">mjData.qpos</span></code> has
different dimensionality than the velocity and acceleration vectors <code class="docutils literal notranslate"><span class="pre">mjData.qvel</span></code> and <code class="docutils literal notranslate"><span class="pre">mjData.qacc</span></code> due to
quaternion joints. The function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-differentiatepos"><span class="std std-ref">mj_differentiatePos</span></a> “subtracts” two joint position vectors and returns a
velocity vector. Conversely, the function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-integratepos"><span class="std std-ref">mj_integratePos</span></a> takes a position vector and a velocity vector, and
returns a new position vector which has been displaced by the given velocity.</p>
<p>Cartesian coordinates are more complicated because there are three different coordinate frames that we use: local,
global, and com-based. Local coordinates are used in mjModel to represent the static offsets between a parent and a
child body, as well as the static offsets between a body and any geoms, sites, cameras and lights attached to it.
These static offsets are applied in addition to any joint transformations. So <code class="docutils literal notranslate"><span class="pre">mjModel.body_pos</span></code>,
<code class="docutils literal notranslate"><span class="pre">mjModel.body_quat</span></code> and all other spatial quantities in mjModel are expressed in local coordinates. The job of
forward kinematics is to accumulate the joint transformations and static offsets along the kinematic tree and compute
all positions and orientations in global coordinates. The quantities in mjData that start with “x” are expressed in
global coordinates. These are <code class="docutils literal notranslate"><span class="pre">mjData.xpos</span></code>, <code class="docutils literal notranslate"><span class="pre">mjData.geom_xpos</span></code> etc. Frame orientations are usually stored as
3-by-3 matrices (xmat), except for bodies whose orientation is also stored as a unit quaternion <code class="docutils literal notranslate"><span class="pre">mjData.xquat</span></code>. Given
this body quaternion, the quaternions of all other objects attached to the body can be reconstructed by a quaternion
multiplication. The function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-local2global"><span class="std std-ref">mj_local2Global</span></a> converts from local body coordinates to global Cartesian
coordinates.</p>
<p><a class="reference internal" href="../APIreference/APIfunctions.html#mju-negpose"><span class="std std-ref">mju_negPose</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mju-trnvecpose"><span class="std std-ref">mju_trnVecPose</span></a>. A pose is a grouping of a 3D position and a unit quaternion orientation.
There is no separate data structure; the grouping is in terms of logic. This represents a position and orientation in
space, or in other words a spatial frame. Note that OpenGL uses 4-by-4 matrices to represent the same information,
except here we use a quaternion for orientation. The function mju_mulPose multiplies two poses, meaning that it
transforms the first pose by the second pose (the order is important). <code class="docutils literal notranslate"><span class="pre">mju_negPose</span></code> constructs the opposite pose,
while <code class="docutils literal notranslate"><span class="pre">mju_trnVecPose</span></code> transforms a 3D vector by a pose, mapping it from local coordinates to global coordinates if
we think of the pose as a coordinate frame. If we want to manipulate only the orientation part, we can do that with the
analogous quaternion utility functions <a class="reference internal" href="../APIreference/APIfunctions.html#mju-mulquat"><span class="std std-ref">mju_mulQuat</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mju-negquat"><span class="std std-ref">mju_negQuat</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mju-rotvecquat"><span class="std std-ref">mju_rotVecQuat</span></a>.</p>
<p>Finally, there is the com-based frame. This is used to represent 6D spatial vectors containing a 3D angular velocity
or acceleration or torque, followed by a 3D linear velocity or acceleration or force. Note the backwards order:
rotation followed by translation. <code class="docutils literal notranslate"><span class="pre">mjData.cdof</span></code> and <code class="docutils literal notranslate"><span class="pre">mjData.cacc</span></code> are example of such vectors; the names start with
“c”. These vectors play a key role in the multi-joint dynamics computation. Explaining this is beyond our scope here;
see Featherstone’s excellent <a class="reference external" href="http://royfeatherstone.org/spatial">slides</a> on the subject. In general, the user should
avoid working with such quantities directly. Instead use the functions <a class="reference internal" href="../APIreference/APIfunctions.html#mj-objectvelocity"><span class="std std-ref">mj_objectVelocity</span></a>,
<a class="reference internal" href="../APIreference/APIfunctions.html#mj-objectacceleration"><span class="std std-ref">mj_objectAcceleration</span></a> and the low-level <a class="reference internal" href="../APIreference/APIfunctions.html#mju-transformspatial"><span class="std std-ref">mju_transformSpatial</span></a> to obtain linear and angular velocities,
accelerations and forces for a given body. Still, for the interested reader, we summarize the most unusual aspect of
the “c” quantities. Suppose we want to represent a body spinning in place. One might expect a spatial velocity that
has non-zero angular velocity and zero linear velocity. However this is not the case. The rotation is interpreted as
taking place around an axis through the center of the coordinate frame, which is outside the body (we use the center
of mass of the kinematic tree). Such a rotation will not only rotate the body but also translate it. Therefore the
spatial vector must have non-zero linear velocity to compensate for the side-effect of rotation around an off-body
axis. If you call mj_objectVelocity, the resulting 6D quantity will be represented in a frame that is centered at the
body and aligned with the world. Thus the linear component will now be zero as expected. This function will also put
translation in front of rotation, which is our convention for local and global coordinates.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="visualization.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Visualization</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Programming</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; DeepMind Technologies Limited
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Simulation</a><ul>
<li><a class="reference internal" href="#initialization">Initialization</a></li>
<li><a class="reference internal" href="#simulation-loop">Simulation loop</a></li>
<li><a class="reference internal" href="#state-and-control">State and control</a></li>
<li><a class="reference internal" href="#forward-dynamics">Forward dynamics</a></li>
<li><a class="reference internal" href="#inverse-dynamics">Inverse dynamics</a></li>
<li><a class="reference internal" href="#multi-threading">Multi-threading</a></li>
<li><a class="reference internal" href="#model-changes">Model changes</a></li>
<li><a class="reference internal" href="#data-layout-and-buffer-allocation">Data layout and buffer allocation</a></li>
<li><a class="reference internal" href="#internal-stack">Internal stack</a></li>
<li><a class="reference internal" href="#errors-warnings-memory-allocation">Errors, warnings, memory allocation</a></li>
<li><a class="reference internal" href="#diagnostics">Diagnostics</a></li>
<li><a class="reference internal" href="#jacobians">Jacobians</a></li>
<li><a class="reference internal" href="#contacts">Contacts</a></li>
<li><a class="reference internal" href="#coordinate-frames-and-transformations">Coordinate frames and transformations</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/katex.min.js"></script>
    <script src="../_static/auto-render.min.js"></script>
    <script src="../_static/katex_autorenderer.js"></script>
    </body>
</html>