<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
    <link sizes="16x16" href="../_static/favicons/favicon-16x16.png" rel="icon" type="image/png">
    <link sizes="32x32" href="../_static/favicons/favicon-32x32.png" rel="icon" type="image/png">
    <link rel="apple-touch-icon" sizes="180x180" href="../_static/favicons/favicon-180x180.png" type="image/png">
    <link sizes="180x180" href="../_static/favicons/favicon-180x180.png" rel="icon" type="image/png">
    <link sizes="192x192" href="../_static/favicons/favicon-192x192.png" rel="icon" type="image/png"><link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Code samples" href="samples.html" /><link rel="prev" title="Simulation" href="simulation.html" />

    <meta name="generator" content="sphinx-4.5.0, furo 2022.09.29"/>
        <title>Visualization - MuJoCo Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/katex-math.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../_static/theme_overrides.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --font-stack--monospace: Inconsolata,Consolas,ui-monospace,monospace;
  --at-color: #bc103e;
  --at-val-color: #bc103e;
  --body-color: #14234b;
  --color-highlight-on-target: #e5e8ed;
  --primary-header-color: #0053d6;
  --row-odd-background-color: #f0f3f7;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #123693;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --at-color: #ff95a6;
  --at-val-color: #ff95a6;
  --body-color: #14234b;
  --color-admonition-background: #1e1e21;
  --color-highlight-on-target: #3d4045;
  --primary-header-color: #a8caff;
  --row-odd-background-color: #222326;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #458dff;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --at-color: #ff95a6;
  --at-val-color: #ff95a6;
  --body-color: #14234b;
  --color-admonition-background: #1e1e21;
  --color-highlight-on-target: #3d4045;
  --primary-header-color: #a8caff;
  --row-odd-background-color: #222326;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #458dff;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">MuJoCo Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/banner.svg" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">MuJoCo Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../computation.html">Computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modeling.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../XMLreference.html">XML Reference</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Programming</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="simulation.html">Simulation</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="samples.html">Code samples</a></li>
<li class="toctree-l2"><a class="reference internal" href="extension.html">Extensions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../APIreference/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../APIreference/APItypes.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../APIreference/APIfunctions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../APIreference/APIglobals.html">Globals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../python.html">Python Bindings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../unity.html">Unity Plug-in</a></li>
<li class="toctree-l1"><a class="reference internal" href="../models.html">Model Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="visualization">
<span id="id1"></span><h1>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">#</a></h1>
<p>MuJoCo has a native 3D visualizer. Its use is illustrated in the <a class="reference internal" href="samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a> code sample and in
the simpler <a class="reference internal" href="samples.html#sabasic"><span class="std std-ref">basic.cc</span></a> code sample. While it is not a full-featured rendering engine, it is a
convenient, efficient and reasonably good-looking visualizer that facilitates research and development. It renders not
only the simulation state but also decorative elements such as contact points and forces, equivalent inertia boxes,
convex hulls, kinematic trees, constraint violations, spatial frames and text labels; these can provide insight into
the physics simulation and help fine-tune the model.</p>
<p>The visualizer is tightly integrated with the simulator and supports both onscreen and offscreen rendering, as
illustrated in the <a class="reference internal" href="samples.html#sarecord"><span class="std std-ref">record.cc</span></a> code sample. This makes it suitable for synthetic computer vision and
machine learning applications, especially in cloud environments. VR integration is also available as of MuJoCo version
1.40, facilitating applications that utilize new head-mounted displays such as Oculus Rift and HTC Vive.</p>
<p>Visualization in MuJoCo is a two-stage process:</p>
<dl class="simple">
<dt>Abstract visualization and interaction</dt><dd><p>This stage populates the <a class="reference internal" href="../APIreference/APItypes.html#mjvscene"><span class="std std-ref">mjvScene</span></a> data structure with a list of geometric objects, lights, cameras and
everything else needed to produce a 3D rendering. It also provides abstract keyboard and mouse hooks for user
interaction. The relevant data structure and function names have the prefix <code class="docutils literal notranslate"><span class="pre">mjv</span></code>.</p>
</dd>
<dt>OpenGL rendering</dt><dd><p>This stage takes the mjvScene data structure populated in the abstract visualization stage, and renders it. It also
provides basic 2d drawing and framebuffer access, so that most applications would not need to call OpenGL directly.
The relevant data structure and function names have the prefix <code class="docutils literal notranslate"><span class="pre">mjr</span></code>.</p>
</dd>
</dl>
<p>There are several reasons for this separation. First, the two stages are conceptually different and separating them is
good software design. Second, they have different dependencies, both internally and in terms of additional libraries;
in particular, abstract visualization does not require any graphics libraries. Third, users who wish to integrate
another rendering engine with MuJoCo can bypass the native OpenGL renderer but still take advantage of the abstract
visualizer.</p>
<p>Below is a mixture of C code and pseudo-code in comments, illustrating the structure of a MuJoCo application which
does both simulation and rendering. This is a short version of the <a class="reference internal" href="samples.html#sabasic"><span class="std std-ref">basic.cc</span></a> code sample. For
concreteness we assume that GLFW is used, although it can be replaced with a different window library such as GLUT or
one of its derivatives.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// MuJoCo data structures</span>
<span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">                  </span><span class="c1">// MuJoCo model</span>
<span class="n">mjData</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">                   </span><span class="c1">// MuJoCo data</span>
<span class="n">mjvCamera</span><span class="w"> </span><span class="n">cam</span><span class="p">;</span><span class="w">                      </span><span class="c1">// abstract camera</span>
<span class="n">mjvOption</span><span class="w"> </span><span class="n">opt</span><span class="p">;</span><span class="w">                      </span><span class="c1">// visualization options</span>
<span class="n">mjvScene</span><span class="w"> </span><span class="n">scn</span><span class="p">;</span><span class="w">                       </span><span class="c1">// abstract scene</span>
<span class="n">mjrContext</span><span class="w"> </span><span class="n">con</span><span class="p">;</span><span class="w">                     </span><span class="c1">// custom GPU context</span>

<span class="c1">// ... load model and data</span>

<span class="c1">// init GLFW, create window, make OpenGL context current, request v-sync</span>
<span class="n">glfwInit</span><span class="p">();</span>
<span class="n">GLFWwindow</span><span class="o">*</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">1200</span><span class="p">,</span><span class="w"> </span><span class="mi">900</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Demo&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
<span class="n">glfwSwapInterval</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">// initialize visualization data structures</span>
<span class="n">mjv_defaultCamera</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cam</span><span class="p">);</span>
<span class="n">mjv_defaultPerturb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pert</span><span class="p">);</span>
<span class="n">mjv_defaultOption</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opt</span><span class="p">);</span>
<span class="n">mjr_defaultContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">con</span><span class="p">);</span>

<span class="c1">// create scene and context</span>
<span class="n">mjv_makeScene</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scn</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span>
<span class="n">mjr_makeContext</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">con</span><span class="p">,</span><span class="w"> </span><span class="n">mjFONTSCALE_100</span><span class="p">);</span>

<span class="c1">// ... install GLFW keyboard and mouse callbacks</span>

<span class="c1">// run main loop, target real-time simulation and 60 fps rendering</span>
<span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// advance interactive simulation for 1/60 sec</span>
<span class="w">  </span><span class="c1">//  Assuming MuJoCo can simulate faster than real-time, which it usually can,</span>
<span class="w">  </span><span class="c1">//  this loop will finish on time for the next frame to be rendered at 60 fps.</span>
<span class="w">  </span><span class="c1">//  Otherwise add a cpu timer and exit this loop when it is time to render.</span>
<span class="w">  </span><span class="n">mjtNum</span><span class="w"> </span><span class="n">simstart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">time</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">simstart</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1.0</span><span class="o">/</span><span class="mf">60.0</span><span class="w"> </span><span class="p">)</span>
<span class="w">      </span><span class="n">mj_step</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// get framebuffer viewport</span>
<span class="w">  </span><span class="n">mjrRect</span><span class="w"> </span><span class="n">viewport</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="n">glfwGetFramebufferSize</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewport</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">viewport</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// update scene and render</span>
<span class="w">  </span><span class="n">mjv_updateScene</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cam</span><span class="p">,</span><span class="w"> </span><span class="n">mjCAT_ALL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scn</span><span class="p">);</span>
<span class="w">  </span><span class="n">mjr_render</span><span class="p">(</span><span class="n">viewport</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">scn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">con</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// swap OpenGL buffers (blocking call due to v-sync)</span>
<span class="w">  </span><span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// process pending GUI events, call GLFW callbacks</span>
<span class="w">  </span><span class="n">glfwPollEvents</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// close GLFW, free visualization storage</span>
<span class="n">glfwTerminate</span><span class="p">();</span>
<span class="n">mjv_freeScene</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scn</span><span class="p">);</span>
<span class="n">mjr_freeContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">con</span><span class="p">);</span>

<span class="c1">// ... free MuJoCo model and data</span>
</pre></div>
</div>
<section id="abstract-visualization-and-interaction">
<span id="abstract"></span><h2>Abstract visualization and interaction<a class="headerlink" href="#abstract-visualization-and-interaction" title="Permalink to this headline">#</a></h2>
<p>This stage populates the <a class="reference internal" href="../APIreference/APItypes.html#mjvscene"><span class="std std-ref">mjvScene</span></a> data structure with a list of geometric objects,
lights, cameras and everything else needed to produce a 3D rendering. It also provides abstract keyboard and mouse hooks
for user interaction.</p>
<section id="cameras">
<span id="vicamera"></span><h3>Cameras<a class="headerlink" href="#cameras" title="Permalink to this headline">#</a></h3>
<p>There are two types of camera objects: an abstract camera represented with the stand-alone data structure
<a class="reference internal" href="../APIreference/APItypes.html#mjvcamera"><span class="std std-ref">mjvCamera</span></a>, and a low-level OpenGL camera represented with the data structure
<a class="reference internal" href="../APIreference/APItypes.html#mjvglcamera"><span class="std std-ref">mjvGLCamera</span></a> which is embedded in mjvScene. When present, the abstract camera is
used during scene update to automatically compute the OpenGL camera parameters, which are then used by the OpenGL
renderer. Alternatively, the user can bypass the abstract camera mechanism and set the OpenGL camera parameters
directly, as discussed in the Virtual Reality section below.</p>
<p>The abstract camera can represent three different camera types as determined by mjvCamera.type. The possible settings
are defined by the enum mjtCamera:</p>
<dl class="simple">
<dt>mjCAMERA_FREE</dt><dd><p>This is the most commonly used abstract camera. It can be freely moved with the mouse. It has a lookat point,
distance to the lookat point, azimuth and elevation; twist around the line of sight is not allowed. The function
<a class="reference internal" href="../APIreference/APIfunctions.html#mjv-movecamera"><span class="std std-ref">mjv_moveCamera</span></a> is a mouse hook for controlling all these camera properties interactively with the mouse. When
<a class="reference internal" href="samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a> first starts, it uses the free camera.</p>
</dd>
<dt>mjCAMERA_TRACKING</dt><dd><p>This is similar to the free camera, except the lookat point is no longer a free parameter but instead is coupled to
the MuJoCo body whose id is given by mjvCamera.trackbodyid. At each update, the lookat point is set to the center of
mass of the kinematic subtree rooted at the specified body. There is also some filtering which produces smooth camera
motion. The distance, azimuth and elevation are controlled by the user and are not modified automatically. This is
useful for tracking a body as it moves around, without turning the camera. To switch from the free to the tracking
camera in <a class="reference internal" href="samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a>, hold Ctrl and right-double-click on the body of interest. Press Esc to go
back to the free camera.</p>
</dd>
<dt>mjCAMERA_FIXED</dt><dd><p>This refers to a camera explicitly defined in the model, unlike the free and tracking cameras which only exist in the
visualizer and are not defined in the model. The id of the model camera is given by mjvCamera.fixedcamid. This camera
is fixed in the sense that the visualizer cannot change its pose or any other parameters. However the simulator
computes the camera pose at each time step, and if the camera is attached to a moving body or is in tracking or
targeting mode, it will move.</p>
</dd>
<dt>mjCAMERA_USER</dt><dd><p>This means that the abstract camera is ignored during an update and the low-level OpenGL cameras are not changed. It
is equivalent to not specifying an abstract camera at all, i.e., passing a NULL pointer to mjvCamera in the update
functions explained below.</p>
</dd>
</dl>
<p>The low-level mjvGLCamera is what determines the actual rendering. There are two such cameras embedded in mjvScene, one
for each eye. Each has position, forward and up directions. Forward corresponds to the negative Z axis of the camera
frame, while up corresponds to the positive Y axis. There is also a frustum in the sense of OpenGL, except we store the
average of the left and right frustum edges and then during rendering compute the actual edges from the viewport aspect
ratio assuming 1:1 pixel aspect ratio. The distance between the two camera positions corresponds to the inter-pupilary
distance (ipd). When the low-level camera parameters are computed automatically from an abstract camera, the ipd as well
as vertical field of view (fovy) are taken from <code class="docutils literal notranslate"><span class="pre">mjModel.vis.global.ipd</span></code>/<code class="docutils literal notranslate"><span class="pre">fovy</span></code> for free and tracking cameras, and
from the camera-specific <code class="docutils literal notranslate"><span class="pre">mjModel.cam_ipd/fovy</span></code> for cameras defined in the model. When stereoscopic mode is not
enabled, as determined by mjvScene.stereo, the camera data for the two eyes are internally averaged during rendering.</p>
</section>
<section id="selection">
<span id="viselect"></span><h3>Selection<a class="headerlink" href="#selection" title="Permalink to this headline">#</a></h3>
<p>In many applications we need to click on a point and determine the 3D object to which this point/pixel belongs. This is
done with the function <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-select"><span class="std std-ref">mjv_select</span></a>, which uses <a class="reference internal" href="../APIreference/APIfunctions.html#raycollisions"><span class="std std-ref">ray collisions</span></a>. Ray collisions functionality
is engine-level and does not depend on the visualizer (indeed it is also used to simulate <a class="reference internal" href="../XMLreference.html#sensor-rangefinder"><span class="std std-ref">rangefinder</span></a> sensors independent of visualization), but the select function is implemented in the visualizer
because it needs information about the camera and viewport.</p>
<p>The function mjv_select returns the index of the geom at the specified window coordinates, or -1 if there is no geom
at those coordinates. The 3D position is also returned. See the code sample <a class="reference internal" href="samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a> for an
example of how to use this function. Internally, mjv_select calls the engine-level function <a class="reference internal" href="../APIreference/APIfunctions.html#mj-ray"><span class="std std-ref">mj_ray</span></a> which in turn
calls the per-geom functions <a class="reference internal" href="../APIreference/APIfunctions.html#mj-raymesh"><span class="std std-ref">mj_rayMesh</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mj-rayhfield"><span class="std std-ref">mj_rayHfield</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mju-raygeom"><span class="std std-ref">mju_rayGeom</span></a>. The user can implement
custom selection mechanisms by calling these functions directly. In a VR application for example, it would make sense to
use the hand-held controller as a “laser pointer” that can select objects.</p>
</section>
<section id="perturbations">
<span id="viperturb"></span><h3>Perturbations<a class="headerlink" href="#perturbations" title="Permalink to this headline">#</a></h3>
<p>Interactive perturbations have proven very useful in exploring the model dynamics as well as probing closed-loop control
systems. The user is free to implement any perturbation mechanism of their choice by setting <code class="docutils literal notranslate"><span class="pre">mjData.qfrc_applied</span></code> or
<code class="docutils literal notranslate"><span class="pre">mjData.xfrc_applied</span></code> to suitable forces (in generalized and Cartesian coordinates respectively).</p>
<p>Prior to MuJoCo version 1.40, user code had to maintain a collection of objects in order to implement perturbations.
All these objects are now grouped into the data structure <a class="reference internal" href="../APIreference/APItypes.html#mjvperturb"><span class="std std-ref">mjvPerturb</span></a>. Its use is illustrated in
<a class="reference internal" href="samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a>.
The idea is to select a MuJoCo body of interest, and provide a reference pose (i.e., a 3D position and quaternion
orientation) for that body. These are stored in mjPerturb.refpos/quat. The function <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-moveperturb"><span class="std std-ref">mjv_movePerturb</span></a> is a mouse
hook for controlling the reference pose with the mouse. The function <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-initperturb"><span class="std std-ref">mjv_initPerturb</span></a> is used to set the
reference pose equal to the selected body pose at the onset of perturbation, so as to avoid jumps.</p>
<p>This perturbation object can then be used to move the selected body directly (when the simulation is paused or when the
selected body is a mocap body), or to apply forces and torques to the body. This is done with the functions
<a class="reference internal" href="../APIreference/APIfunctions.html#mjv-applyperturbpose"><span class="std std-ref">mjv_applyPerturbPose</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-applyperturbforce"><span class="std std-ref">mjv_applyPerturbForce</span></a> respectively. The latter function writes the external
perturbation force to <code class="docutils literal notranslate"><span class="pre">mjData.xfrc_applied</span></code> for the selected body. However it does not clear <code class="docutils literal notranslate"><span class="pre">mjData.xfrc_applied</span></code>
for the remaining bodies, thus it is recommended to clear it in user code, in case the selected body changed and some
perturbation force was left over from a previous time step. If there is more than one device that can apply
perturbations or user code needs to add perturbations from other sources, the user must implement the necessary logic so
that only the desired perturbations are present in <code class="docutils literal notranslate"><span class="pre">mjData.xfrc_applied</span></code> and any old perturbations are cleared.</p>
<p>In addition to affecting the simulation, the perturbation object is recognized by the abstract visualizer and can be
rendered. This is done by adding a visual string to denote the positional difference, and a rotating cube to denote
the reference orientation of the selected body. The perturbation forces themselves can also be rendered when the
corresponding visualization flag in <a class="reference internal" href="../APIreference/APItypes.html#mjvoption"><span class="std std-ref">mjvOption</span></a> is enabled.</p>
</section>
<section id="scene-update">
<span id="viupdate"></span><h3>Scene update<a class="headerlink" href="#scene-update" title="Permalink to this headline">#</a></h3>
<p>Finally, we bring all of the above elements together and explain how mjvScene is updated before being passed to the
OpenGL rendering stage. This can be done with a single call to the function <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-updatescene"><span class="std std-ref">mjv_updateScene</span></a> at each frame.
mjvCamera and mjvPerturb are arguments to this function, or they can be NULL pointers in which case the corresponding
functionality is disabled. In VR applications the parameters of mjvScene.camera[n], n=0,1 must also be set at each
frame; this is done by user code outside mjv_updateScene. The function mjv_updateScene examines mjModel and mjData,
constructs all geoms that need to be rendered (according to the specified visualization options), and populates the
array mjvScene.geom with <a class="reference internal" href="../APIreference/APItypes.html#mjvgeom"><span class="std std-ref">mjvGeom</span></a> objects. Note that mjvGeom is an abstract geom, and is not in one-to-one
correspondence with the simulation geoms in mjModel and mjData. In particular, mjvGeom contains the geom pose, scale,
shape (primitive or mesh index in mjModel), material properties, textures (index in mjModel), labeling, and everything
else needed for specify how rendering should be done. mjvScene also contains up to eight OpenGL lights which are
copied from the model, as well as a headlight which is in light position 0 when present.</p>
<p>The above procedure is the most common approach, and it updates the entire scene at each frame. In addition, we
provide two functions for finer control. <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-updatecamera"><span class="std std-ref">mjv_updateCamera</span></a> updates only the camera (i.e., maps the abstract
mjvCamera to the low-level mjvGLCamera) but does not touch the geoms or lights. This is useful when the user is moving
the camera rapidly but the simulation state has not changed - in that case there is no point in re-creating the lists
of geoms and lights.</p>
<p>More advanced rendering effects can be achieved by manipulating the list of abstract geoms. For example, the user can
add custom geoms at the end of the list. Sometimes it is desirable to render a sequence of simulation states (i.e., a
trajectory) and not just the current state. For this purpose, we have provided the function <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-addgeoms"><span class="std std-ref">mjv_addGeoms</span></a> which
adds the geoms corresponding to the current simulation state to the list already in mjvScene. It does not change the
list of lights, because lighting is additive and having too many lights will make the scene too bright. Importantly,
the user can select which geom categories will be added, via a bitmask of enum type mjtCatBit:</p>
<dl class="simple">
<dt>mjCAT_STATIC</dt><dd><p>This selects MuJoCo geoms and sites belonging to the world body (which has body id 0).</p>
</dd>
<dt>mjCAT_DYNAMIC</dt><dd><p>This selects MuJoCo geoms and sites belonging to bodies other than the world body.</p>
</dd>
<dt>mjCAT_DECOR</dt><dd><p>This selects decorative elements such as force arrows, automatically-generated skeletons, equivalent inertia boxes,
and any other elements that were added by the abstract visualizer and do not correspond to MuJoCo geoms and sites
defined in the model.</p>
</dd>
<dt>mjCAT_ALL</dt><dd><p>This selects all of the above categories.</p>
</dd>
</dl>
<p>The main update function mjv_updateScene would normally be called with mjCAT_ALL. It clears the geom list and calls
mjv_addGeom to add only the geoms for the current model state. If we want to render a trajectory, we have to be careful
to avoid visual clutter. So it makes sense to render one of the frames with mjCAT_ALL (usually the first or the last
depending on the use case), and all other frames with mjCAT_DYNAMIC. Since the static/world objects are not moving,
rendering them in each frame will only slow down the GPU and create visual aliasing. As for the decor elements, there
could be situations where we want to render all of them - for example to visualize the evolution of contact forces over
time. In summary, there is plenty of flexibility in how mjvScene is constructed. We have provided automation for the
main use cases, but the user can also make programmatic changes as needed.</p>
</section>
<section id="virtual-reality">
<span id="vivr"></span><h3>Virtual reality<a class="headerlink" href="#virtual-reality" title="Permalink to this headline">#</a></h3>
<p>In desktop applications it is convenient to use an abstract mjvCamera allowing intuitive mouse control, and then
automatically map it to mjvGLCamera used for rendering. In VR applications the situation is very different. In that
case the head/eyes of the user as well as the projection surface are being tracked, and therefore have physical
presence in the room. If anything can be moved by the user (with a mouse or other input device) it is the position,
orientation and scale of the model relative to the room. This is called model transformation, and is represented in
mjvScene. The function <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-movemodel"><span class="std std-ref">mjv_moveModel</span></a> is a mouse hook for controlling this transformation. When using an
abstract mjvCamera during update, the model transformation is automatically disabled, by setting the flag
mjvScene.enabletransform = 0 rather than clearing the actual parameters. In this way the user can switch between VR
and desktop camera mode without losing the model transformation parameters.</p>
<p>Since we have introduced two spaces, namely model space and room space, we need to map between them as well as clarify
which spatial quantities are defined with respect to which spatial frame. Everything accessible by the simulator lives
in the model space. The room space is only accessible by the visualizer. The only quantities defined in room space are
the mjvGLCamera parameters. The functions <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-room2model"><span class="std std-ref">mjv_room2model</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-model2room"><span class="std std-ref">mjv_model2room</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mjv-camerainmodel"><span class="std std-ref">mjv_cameraInModel</span></a>,
<a class="reference internal" href="../APIreference/APIfunctions.html#mjv-camerainroom"><span class="std std-ref">mjv_cameraInRoom</span></a> perform the necessary transformations, and are needed for VR applications.</p>
<p>We now outline the procedure for hooking up head tracking to MuJoCo’s visualizer in a VR application. A code sample
illustrating this will soon be posted. We assume that a tracking device provides in real-time the positions of the two
eyes (usually generated by tracking the position and orientation of the head and assuming a user-specific ipd), as
well as the forward and up camera directions. We copy these data directly into the two mjvGLCameras, which are in
mjvScene.camera[n] where n=0 is the left eye and n=1 is the right eye. Note that the forward direction is normal to
the projection surface, and not necessarily aligned with the gaze direction; indeed the gaze direction is unknown
(unless we also have an eye-tracking device) and does not affect the rendering.</p>
<p>We must also set the mjvGLCamera frustum. How this is done depends on the nature of the VR system. For head-mounted
displays such as the Oculus Rift and HTC Vive, the projection surface moves with the head, and so the frustum is fixed
and provided by the SDK. In this case we simply copy it into mjvGLCamera, averaging the left and right edges to
compute the frustum_center parameter. Alternatively, the projection surface can be a monitor which is stationary in
the room (which is the case in the zSpace system). For such systems we must compute the frustum at each frame, by
taking into account the spatial relations between the monitor and the eyes/cameras. This assumes that the monitor is
also tracked. The natural approach here is to define the monitor as the center of the room coordinate frame, and track
the head relative to it. In the zSpace system this is done by embedding the motion capture cameras in the monitor
itself.</p>
<p>Apart from tracking the head and using the correct perspective projection, VR applications typically involve hand-held
spatial controllers that must be mapped to the motion of simulated objects or otherwise interact with the simulation.
The pose of these controllers is recorded by the motion capture system in room space. The transformation functions we
provide (mjv_room2model in particular) can be used to map to model space. Once we have the pose of the controller in
model space, we can use a MuJoCo mocap body (defined in the model) to insert the controller in the simulation. This is
precisely why mocap bodies were introduced in MuJoCo. Such bodies are treated as fixed from the viewpoint of physics,
yet the user is expected to move them programmatically at each simulation step. They can interact with the simulation
through contacts, or better yet, through soft equality constraints to regular bodies which in turn make contacts. The
latter approach is illustrated in the MPL models available on the Forum. It provides effective dynamic filtering and
avoids contacts involving bodies that behave as if they are infinitely heavy (which is what a fixed body is). Note
that the time-varying positions and orientations of the mocap bodies are stored in <code class="docutils literal notranslate"><span class="pre">mjData.mocap_pos/quat</span></code>, as opposed
to storing them in mjModel. This is because mjModel is supposed to remain constant. The fixed mocap body pose stored
in mjModel is only used at initialization and reset, when user code has not yet had a chance to update
mjData.mocap_pos/quat.</p>
</section>
</section>
<section id="opengl-rendering">
<span id="rendering"></span><h2>OpenGL Rendering<a class="headerlink" href="#opengl-rendering" title="Permalink to this headline">#</a></h2>
<p>This stage takes the mjvScene data structure populated in the abstract visualization stage, and renders it. It also
provides basic 2d drawing and framebuffer access, so that most applications would not need to call OpenGL directly.</p>
<section id="context-and-gpu-resources">
<span id="recontext"></span><h3>Context and GPU resources<a class="headerlink" href="#context-and-gpu-resources" title="Permalink to this headline">#</a></h3>
<p>The first step in the rendering process is create the model-specific GPU context <a class="reference internal" href="../APIreference/APItypes.html#mjrcontext"><span class="std std-ref">mjrContext</span></a>. This is done by
first clearing the data structure with the function <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-defaultcontext"><span class="std std-ref">mjr_defaultContext</span></a>, and then calling the function
<a class="reference internal" href="../APIreference/APIfunctions.html#mjr-makecontext"><span class="std std-ref">mjr_makeContext</span></a>. This was already illustrated earlier; the relevant code is:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">mjModel</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="n">mjrContext</span><span class="w"> </span><span class="n">con</span><span class="p">;</span>

<span class="c1">// clear mjrContext only once before first use</span>
<span class="n">mjr_defaultContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">con</span><span class="p">);</span>

<span class="c1">// create window with OpenGL context, make it current</span>
<span class="n">GLFWwindow</span><span class="o">*</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">1200</span><span class="p">,</span><span class="w"> </span><span class="mi">900</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Demo&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

<span class="c1">// ... load MuJoCo model</span>

<span class="c1">// make model-specific mjrContext</span>
<span class="n">mjr_makeContext</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">con</span><span class="p">,</span><span class="w"> </span><span class="n">mjFONTSCALE_100</span><span class="p">);</span>

<span class="c1">// ... load another MuJoCo model</span>

<span class="c1">// make mjrContext for new model (old context freed automatically)</span>
<span class="n">mjr_makeContext</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">con</span><span class="p">,</span><span class="w"> </span><span class="n">mjFONTSCALE_100</span><span class="p">);</span>

<span class="c1">// free context when done</span>
<span class="n">mjr_freeContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">con</span><span class="p">);</span>
</pre></div>
</div>
<p>How is mjrContext related to an OpenGL context? An OpenGL context is what enables the application to talk to the video
driver and send rendering commands. It must exist and must be current in the calling thread before mjr_makeContext is
called. GLFW and related libraries provide the necessary functions as shown above.</p>
<p>mjrContext is specific to MuJoCo. After creation, it contains references (called “names” in OpenGL) to all the
resources that were uploaded to the GPU by mjr_makeContext. These include model-specific resources such as meshes and
textures, as well as generic resources such as font bitmaps for the specified font scale, framebuffer objects for
shadow mapping and offscreen rendering, and associated renderbuffers. It also contains OpenGL-related options copied
from <code class="docutils literal notranslate"><span class="pre">mjModel.vis</span></code>, capabilities of the default window framebuffer that are discovered automatically, and the
currently active buffer for rendering; see <a class="reference internal" href="#rebuffer"><span class="std std-ref">buffers</span></a> below. Note that even though MuJoCo uses
fixed-function OpenGL, it avoids immediate mode rendering and instead uploads all resources to the GPU upfront. This
makes it as efficient as a modern shader, and possibly more efficient, because fixed-function OpenGL is now implemented
via internal shaders that have been written by the video driver developers and tuned extensively.</p>
<p>Most of the fields of mjrContext remain constant after the call to mjr_makeContext. The only exception is
mjrContext.currentBuffer which changes whenever the active buffer changes. Some of the GPU resources may also change
because the user can upload modified resources with the functions <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-uploadtexture"><span class="std std-ref">mjr_uploadTexture</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-uploadmesh"><span class="std std-ref">mjr_uploadMesh</span></a>,
<a class="reference internal" href="../APIreference/APIfunctions.html#mjr-uploadhfield"><span class="std std-ref">mjr_uploadHField</span></a>. This can be used to achieve dynamic effects such as inserting a video feed into the
rendering, or modulating a terrain map. Such modifications affect the resources residing on the GPU, but their OpenGL
names are reused, thus the change is not actually visible in mjrContext.</p>
<p>The user should <strong>never</strong> make changes to mjrContext directly. MuJoCo’s renderer assumes that only it can manage
mjrContext. In fact this kind of object would normally be opaque and its internal structure would not be exposed to
the user. We are exposing it because MuJoCo has an open design and also because users may want to interleave their own
OpenGL code with MuJoCo’s renderer, in which case they may need read access to some fields of mjrContext. For example
in VR applications the user needs to blit from MuJoCo’s offscreen buffer to a texture provided by a VR SDK.</p>
<p>When a different MuJoCo model is loaded, mjr_makeContext must be called again. There is also the function
<a class="reference internal" href="../APIreference/APIfunctions.html#mjr-freecontext"><span class="std std-ref">mjr_freeContext</span></a> which frees the GPU resources while preserving the initialization and capabilities flags. This
function should be called when the application is about to exit. It is called automatically from within
mjr_makeContext, so you do not need to call it directly when a different model is loaded, although it is not an error
to do so. The function mjr_defaultContext must be called once before rendering starts, to clear the memory allocated
for the data structure mjrContext. If you call it after calling mjr_makeContext, it will wipe out any record that GPU
resources were allocated without freeing those resources, so don’t do that.</p>
</section>
<section id="buffers-for-rendering">
<span id="rebuffer"></span><h3>Buffers for rendering<a class="headerlink" href="#buffers-for-rendering" title="Permalink to this headline">#</a></h3>
<p>In addition to the default window framebuffer, OpenGL can support unlimited framebuffer objects (FBOs) for custom
rendering. In MuJoCo we provide systematic support for two framebuffers: the default window framebuffer, and one
offscreen framebuffer. They are referred to by the constants in the enum type <a class="reference internal" href="../APIreference/APItypes.html#mjtframebuffer"><span class="std std-ref">mjtFramebuffer</span></a>, namely
mjFB_WINDOW and mjFB_OFFSCREEN. At any time, one of these two buffers is active for the purposes of MuJoCo rendering,
meaning that all subsequent commands are directed to it. There are two additional framebuffer objects referenced in
mjrContext, needed for shadow mapping and resolving multi-sample buffers, but these are used internally and the user
should not attempt to access them directly.</p>
<p>The active buffer is set with the function <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-setbuffer"><span class="std std-ref">mjr_setBuffer</span></a>. This sets the value of mjrContext.activeBuffer and
configures the OpenGL state accordingly. When mjr_makeContext is called, internally it calls mjr_setBuffer with
argument mjFB_WINDOW, so that rendering starts in the window buffer by default. If the specified buffer does not
exist, mjr_setBuffer automatically defaults to the other buffer (note that when using headless rendering on Linux,
there may be no window framebuffer).</p>
<p>From the perspective of OpenGL, there are important differences between the window framebuffer and offscreen
framebuffer, and these differences affect how the MuJoCo user interacts with the renderer. The window framebuffer is
created and managed by the operating system and not by OpenGL. As a result, properties such as resolution,
double-buffering, quad-buffered stereo, multi-samples, v-sync are set outside OpenGL; this is done by GLFW calls in our
code samples. All OpenGL can do is detect these properties; we do this in mjr_makeContext and record the results in the
various window capabilities fields of mjrContext. This is why such properties are not part of the MuJoCo model; they are
session/software-specific and not model-specific. In contrast, the offscreen framebuffer is managed entirely by OpenGL,
and so we can create that buffer with whatever properties we want, namely with the resolution and multi-sample
properties specified in <code class="docutils literal notranslate"><span class="pre">mjModel.vis</span></code>.</p>
<p>The user can directly access the pixels in the two buffers. This is done with the functions <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-readpixels"><span class="std std-ref">mjr_readPixels</span></a>,
<a class="reference internal" href="../APIreference/APIfunctions.html#mjr-drawpixels"><span class="std std-ref">mjr_drawPixels</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-blitbuffer"><span class="std std-ref">mjr_blitBuffer</span></a>. Read/draw transfer pixels from/to the active buffer to/from the CPU.
Blit transfers pixels between the two buffers on the GPU and is therefore much faster. The direction is from the
active buffer to the buffer that is not active. Note that mjr_blitBuffer has source and destination viewports that can
have different size, allowing the image to be scaled in the process.</p>
</section>
<section id="drawing-pixels">
<span id="redraw"></span><h3>Drawing pixels<a class="headerlink" href="#drawing-pixels" title="Permalink to this headline">#</a></h3>
<p>The main rendering function is <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-render"><span class="std std-ref">mjr_render</span></a>. Its arguments are a rectangular viewport for rendering, the mjvScene
which was populated by the abstract visualizer, and the mjrContext which was created by mjr_makeContext. The viewport
can be the entire active buffer, or part of it for custom effects. A viewport corresponding to the entire buffer can
be obtained with the function <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-maxviewport"><span class="std std-ref">mjr_maxViewport</span></a>. Note that while the offscreen buffer size does not change, the
window buffer size changes whenever the user resizes or maximizes the window. Therefore user code should not assume
fixed viewport size. In the code sample <a class="reference internal" href="samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a> we use a callback which is triggered whenever
the window size changes, while in <a class="reference internal" href="samples.html#sabasic"><span class="std std-ref">basic.cc</span></a> we simply check the window size every time we render. On
certain scaled displays (only on OSX it seems) the window size and framebuffer size can be different. So if you are
getting the size with GLFW functions, use glfwGetFramebuferSize rather than glfwGetWindowSize. On the other hand,
mouse coordinates are returned by the operating system in window rather than framebuffer units; thus the mouse
interaction functions discussed earlier should use glfwGetWindowSize to obtain the window height needed to normalize
the mouse displacement data.</p>
<p>mjr_render renders all mjvGeoms from the list mjvScene.geom. The abstract visualization options mjvOption are no
longer relevant here; they are used by mjv_updateScene to determine which geoms to add, and as far as mjr_render is
concerned these options are already baked-in. There is however another set of rendering options that are embedded in
mjvScene, and these affect the OpenGL rendering process. The array mjvScene.flags contains flags indexed by the enum
type <a class="reference internal" href="../APIreference/APItypes.html#mjtrndflag"><span class="std std-ref">mjtRndFlag</span></a> and include options for enabling and disabling wireframe mode, shadows, reflections, skyboxes
and fog. Shadows and reflections involve additional rendering passes. MuJoCo’s renderer is very efficient, but
depending on the model complexity and available GPU, it may be necessary to disable one or both of these effects in
some cases.</p>
<p>The parameter mjvScene.stereo determines the stereo mode. The possible values are given by the enum type
<a class="reference internal" href="../APIreference/APItypes.html#mjtstereo"><span class="std std-ref">mjtStereo</span></a> and are as follows:</p>
<dl class="simple">
<dt>mjSTEREO_NONE</dt><dd><p>Stereo rendering is disabled. The average of the two OpenGL cameras in mjvScene is used. Note that the renderer
always expects both cameras to be properly defined, even if stereo is not used.</p>
</dd>
<dt>mjSTEREO_QUADBUFFERED</dt><dd><p>This mode works only when the active buffer is the window, and the window supports quad-buffered OpenGL. This
requires a professional video card. The code sample <a class="reference internal" href="samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a> attempts to open such a window.
In this mode MuJoCo’s renderer uses the GL_BACK_LEFT and GL_BACK_RIGHT buffers to render the two views (as determined
by the two OpenGL cameras in mjvScene) when the window is double-buffered, and GL_FRONT_LEFT and GL_FRONT_RIGHT
otherwise. If the window does not support quad-buffered OpenGL or the active buffer is the offscreen buffer, the
renderer reverts to the side-by-side mode described next.</p>
</dd>
<dt>mjSTEREO_SIDEBYSIDE</dt><dd><p>This stereo mode does not require special hardware and is always available. The viewport given to mjr_render is split
in two equal rectangles side-by-side. The left view is rendered on the left side and the right view on the right
side. In principle users can cross their eyes and see stereo on a regular monitor, but the goal here is to show it in
a stereoscopic device. Most head-mounted displays support this stereo mode.</p>
</dd>
</dl>
<p>In addition to the main mjr_render function, we provide several functions for “decorating” the image. These are 2d
rendering functions and include <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-overlay"><span class="std std-ref">mjr_overlay</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-text"><span class="std std-ref">mjr_text</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-rectangle"><span class="std std-ref">mjr_rectangle</span></a>, <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-figure"><span class="std std-ref">mjr_figure</span></a>. The user
can draw additional decorations with their own OpenGL code. This should be done after mjr_render, because mjr_render
clears the viewport.</p>
<p>We also provide the functions <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-finish"><span class="std std-ref">mjr_finish</span></a> and <a class="reference internal" href="../APIreference/APIfunctions.html#mjr-geterror"><span class="std std-ref">mjr_getError</span></a> for explicit synchronization with the GPU and
for OpenGL error checking. They simply call glFinish and glGetError internally. This together with the basic 2d
drawing functions above is meant to provide enough functionality so that most users will not need to write OpenGL
code. Of course we cannot achieve this in all cases, short of providing wrappers for all of OpenGL.</p>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="samples.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Code samples</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="simulation.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Simulation</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; DeepMind Technologies Limited
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Visualization</a><ul>
<li><a class="reference internal" href="#abstract-visualization-and-interaction">Abstract visualization and interaction</a><ul>
<li><a class="reference internal" href="#cameras">Cameras</a></li>
<li><a class="reference internal" href="#selection">Selection</a></li>
<li><a class="reference internal" href="#perturbations">Perturbations</a></li>
<li><a class="reference internal" href="#scene-update">Scene update</a></li>
<li><a class="reference internal" href="#virtual-reality">Virtual reality</a></li>
</ul>
</li>
<li><a class="reference internal" href="#opengl-rendering">OpenGL Rendering</a><ul>
<li><a class="reference internal" href="#context-and-gpu-resources">Context and GPU resources</a></li>
<li><a class="reference internal" href="#buffers-for-rendering">Buffers for rendering</a></li>
<li><a class="reference internal" href="#drawing-pixels">Drawing pixels</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/katex.min.js"></script>
    <script src="../_static/auto-render.min.js"></script>
    <script src="../_static/katex_autorenderer.js"></script>
    </body>
</html>