<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
    <link sizes="16x16" href="_static/favicons/favicon-16x16.png" rel="icon" type="image/png">
    <link sizes="32x32" href="_static/favicons/favicon-32x32.png" rel="icon" type="image/png">
    <link rel="apple-touch-icon" sizes="180x180" href="_static/favicons/favicon-180x180.png" type="image/png">
    <link sizes="180x180" href="_static/favicons/favicon-180x180.png" rel="icon" type="image/png">
    <link sizes="192x192" href="_static/favicons/favicon-192x192.png" rel="icon" type="image/png"><link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="Modeling" href="modeling.html" /><link rel="prev" title="Overview" href="overview.html" />

    <meta name="generator" content="sphinx-4.5.0, furo 2022.09.29"/>
        <title>Computation - MuJoCo Documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="_static/katex-math.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="_static/theme_overrides.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --font-stack--monospace: Inconsolata,Consolas,ui-monospace,monospace;
  --at-color: #bc103e;
  --at-val-color: #bc103e;
  --body-color: #14234b;
  --color-highlight-on-target: #e5e8ed;
  --primary-header-color: #0053d6;
  --row-odd-background-color: #f0f3f7;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #123693;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --at-color: #ff95a6;
  --at-val-color: #ff95a6;
  --body-color: #14234b;
  --color-admonition-background: #1e1e21;
  --color-highlight-on-target: #3d4045;
  --primary-header-color: #a8caff;
  --row-odd-background-color: #222326;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #458dff;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --at-color: #ff95a6;
  --at-val-color: #ff95a6;
  --body-color: #14234b;
  --color-admonition-background: #1e1e21;
  --color-highlight-on-target: #3d4045;
  --primary-header-color: #a8caff;
  --row-odd-background-color: #222326;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #458dff;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">MuJoCo Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="_static/banner.svg" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">MuJoCo Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="XMLreference.html">XML Reference</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="programming/index.html">Programming</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="programming/simulation.html">Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming/visualization.html">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming/samples.html">Code samples</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming/extension.html">Extensions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="APIreference/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="APIreference/APItypes.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="APIreference/APIfunctions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="APIreference/APIglobals.html">Globals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="python.html">Python Bindings</a></li>
<li class="toctree-l1"><a class="reference internal" href="unity.html">Unity Plug-in</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">Model Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="computation">
<h1>Computation<a class="headerlink" href="#computation" title="Permalink to this headline">#</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h2>
<p>This chapter describes the mathematical and algorithmic foundations of MuJoCo. The overall framework is fairly standard
for readers familiar with modeling and simulation in generalized or joint coordinates. Therefore we summarize that
material briefly. Most of the chapter is devoted to how we handle contacts and other constraints. This approach is based
on our recent research and is unique to MuJoCo, so we take the time to motivate it and explain it in detail. Additional
information can be found in the paper below, although some of the technical ideas in this chapter are new and have not
been described elsewhere.</p>
<blockquote>
<div><p><a class="reference external" href="https://scholar.google.com/scholar?cluster=9217655838195954277">Analytically-invertible dynamics with contacts and constraints: Theory and implementation in MuJoCo</a> E. Todorov (2014).</p>
</div></blockquote>
</section>
<section id="motivation-for-soft-contact-model">
<span id="motivation"></span><h2>Motivation for soft contact model<a class="headerlink" href="#motivation-for-soft-contact-model" title="Permalink to this headline">#</a></h2>
<p>Robots as well as humans interact with their environment primarily through physical contact. Given the increasing
importance of physics modeling in robotics, machine learning, animation, virtual reality, biomechanics and other fields,
there is need for simulation models of contact dynamics that are both physically accurate and computationally efficient.
One application of simulation models is to assess candidate estimation and control strategies before deploying them on
physical systems. Another application is to automate the design of those strategies - usually through numerical
optimization that uses simulation in an inner loop. The latter application imposes an additional constraint: the
objective function defined with respect to the contact dynamics should be amenable to numerical optimization. The
contact model underlying MuJoCo has benefits along these and other relevant dimensions. In the following sections we
discuss its benefits, while clarifying the differences from the linear complementarity (LCP) family of contact models
which are the <em>de facto</em> standard.</p>
<section id="physical-realism-and-soft-contacts">
<span id="morealism"></span><h3>Physical realism and soft contacts<a class="headerlink" href="#physical-realism-and-soft-contacts" title="Permalink to this headline">#</a></h3>
<p>Many of the advantages of our contact model can be traced to the fact that we drop the strict complementarity constraint
at the heart of the LCP formulation. We will call this family of models convex; see <a class="reference internal" href="#references"><span class="std std-ref">References</span></a> for related work.
For frictionless contacts dropping the explicit complementarity constraint makes no difference, because the
Karush-Kuhn-Tucker (KKT) optimality conditions for the resulting convex quadratic program are equivalent to an LCP. But
for frictional contacts there are differences.</p>
<p>If one sees convex models as approximations to LCP, the logical question to ask is how good that approximation is.
However we do not see it that way. Instead, we see both LCP models and convex models as different approximations to
physical reality, each with its strengths and weaknesses. The immediate consequence of dropping strict complementarity
and replacing it with a cost is that complementarity can be violated - meaning that force and velocity in the contact
normal direction can be simultaneously positive, and frictional forces may not be maximally dissipative. A related
phenomenon is that the only way to initiate slip is to generate some motion in the normal direction. These effects are
numerically small yet undesirable. This shortcoming however has little practical relevance, because it is premised on
the assumption of hard contact. Yet all physical materials allow some deformation. This is particularly important in
robotics, where the parts of the robot that come in contact with the environment are usually designed to be soft. For
soft contacts complementarity has to be violated: when there is penetration and the material is pushing the contacting
bodies apart, both the normal force and velocity are positive. Furthermore if an object is resting on a soft surface
with some penetration, and we push it sideways, we would expect it to move up a bit as it starts sliding. So the
deviations from LCP actually increase physical realism in the presence of soft contacts.</p>
<p>Of course not every soft model is desirable; for example spring-damper models are soft but are plagued by instabilities.
At the same time different materials have different profiles, and so unlike hard contact models, a soft model must have
sufficiently rich parameterization if it is to be adapted to multiple systems of interest. This in turn facilitates
system identification of contact model parameters.</p>
</section>
<section id="computational-efficiency">
<span id="moefficiency"></span><h3>Computational efficiency<a class="headerlink" href="#computational-efficiency" title="Permalink to this headline">#</a></h3>
<p>LCP models with frictional contact correspond to NP-hard optimization problems. This has given rise to an industry of
approximate solvers, with the unfortunate side-effect that many popular physics engines use poorly-documented shortcuts
and the resulting equations of motion are difficult to characterize. To be fair, NP-hardness is a statement about
worst-case performance and does not mean that solving the LCP quickly is impossible in practice. Still, convex
optimization has well-established advantages. In MuJoCo we have observed that for typical robotic models, 10 sweeps of a
projected Gauss-Seidel method (PGS) yield solutions which for practical purposes are indistinguishable from the global
minimum. Of course there are problems that are much harder to solve numerically, even though they are convex, and for
such problems we have conjugate gradient solvers with higher-order convergence.</p>
<p>The requirements for computational efficiency are different depending on the use case. If all we need is real-time
simulation, modern computers are fast enough to handle most robotic systems of interest even with inefficient solvers.
In the context of optimization however, there is no such thing as fast-enough simulation. If the objective functions and
their derivatives can be computed faster, this translates into larger search horizons or training sets or sample sizes,
which in turn leads to increased performance. This is why we have invested a lot of effort in developing efficient
solvers.</p>
</section>
<section id="continuous-time">
<span id="mocontinuous"></span><h3>Continuous time<a class="headerlink" href="#continuous-time" title="Permalink to this headline">#</a></h3>
<p>One might have thought that the equations of motion for any physical system would be uniquely defined in continuous
time. However frictional contacts are problematic because the Coulomb friction model is not well-defined in continuous
time (Painleve’s paradox). This has made discrete-time approximations and associated velocity-stepping schemes very
popular. The continuous-time limit of these models is rarely investigated. For a single contact and under not
necessarily realistic assumptions on the applied forces, the limit satisfies the differential-inclusion form of the
Coulomb friction model, while for multiple simultaneous contacts there can be multiple solutions depending on how
exactly the continuous-time limit is taken. These difficulties can be traced to the assumption of hard contact.</p>
<p>Convex models of frictional contact have also relied on discrete-time approximations in the past, but this is not
necessary. The present model is defined in continuous-time, in terms of forces and accelerations. This is more natural
given that time in the real world is continuous. It is also the preferred formulation in the controls literature, and
indeed we are hoping that MuJoCo will attract users from that community. Another advantage of continuous-time
formulations is that they are amenable to sophisticated numerical integration, without having to pay the computational
overhead of discrete-time variational integrators (which are necessarily implicit when the inertia is
configuration-dependent). Continuous-time dynamics are also well-defined backward in time, which is needed in some
optimization algorithms.</p>
</section>
<section id="inverse-dynamics-and-optimization">
<span id="moinverse"></span><h3>Inverse dynamics and optimization<a class="headerlink" href="#inverse-dynamics-and-optimization" title="Permalink to this headline">#</a></h3>
<p>The objective of inverse dynamics is to recover the applied force and contact force given the position, velocity and
acceleration of the multi-joint system. With hard contacts this computation is impossible. Consider pushing against a
wall without moving. The contact force cannot be recovered from the kinematics, unless of course we consider the
material deformations - in which case we need a soft contact model. Inverse dynamics are trivial to compute with
spring-damper models of contact, because in that case the contact force is only a function of position and velocity and
does not depend on applied force. But this is also the reason why spring-damper models are undesirable: ignoring the
applied force means that an error is introduced at each time step, and so the simulator is perpetually in
error-correction mode, in turn causing instabilities. In contrast, modern contact solvers take the applied force (as
well as all internal forces) into account when computing the contact force/impulse. But this complicates inversion. The
present contact model has a uniquely-defined inverse. The inverse dynamics are in fact easier to compute than the
forward dynamics, because the optimization problem becomes diagonal and decomposes into independent optimization
problems over individual contacts - which can be solved analytically.</p>
<p>Inverse dynamics play a key role in optimization algorithms arising in system identification, estimation and control.
They make it possible to treat the sequence of positions (or a parametric representation thereof) as the object being
optimized. Velocities and acceleration are then computed by differentiating the positions; inverse dynamics are used to
compute the applied and contact forces; and finally an objective function is constructed which can depend on all of the
above. This is interchangeably called space-time optimization, spectral method, direct collocation. MuJoCo is uniquely
suited to facilitate such computations in the presence of contacts and other constraints.</p>
</section>
</section>
<section id="general-framework">
<span id="framework"></span><h2>General framework<a class="headerlink" href="#general-framework" title="Permalink to this headline">#</a></h2>
<p>Our notation is summarized in the table below. Additional notation specific to constraints will be introduced later.
When available, we also show the fields of main data structures <a class="reference internal" href="APIreference/APItypes.html#mjmodel"><span class="std std-ref">mjModel</span></a> and <a class="reference internal" href="APIreference/APItypes.html#mjdata"><span class="std std-ref">mjData</span></a> corresponding to the
mathematical notation.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Symbol</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>MuJoCo field</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math">\(n_Q\)</span></p></td>
<td></td>
<td><p>number of
position
coordinates</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mjModel.nq</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(n_V\)</span></p></td>
<td></td>
<td><p>number of
degrees of
freedom</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mjModel.nv</span></code></p></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(n_C\)</span></p></td>
<td></td>
<td><p>number of
active
constraints</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mjData.nefc</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(q\)</span></p></td>
<td><p><span class="math">\(n_Q\)</span></p></td>
<td><p>joint position</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mjData.qpos</span></code></p></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(v\)</span></p></td>
<td><p><span class="math">\(n_V\)</span></p></td>
<td><p>joint velocity</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mjData.qvel</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(\tau\)</span></p></td>
<td><p><span class="math">\(n_V\)</span></p></td>
<td><p>applied force:
passive,
actuation,
external</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(c(q, v)\)</span></p></td>
<td><p><span class="math">\(n_V\)</span></p></td>
<td><p>bias force:
Coriolis,
centrifugal,
gravitational</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mjData.qfrc_bias</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(M(q)\)</span></p></td>
<td><p><span class="math">\(n_V
\times n_V\)</span></p></td>
<td><p>inertia in
joint space</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mjData.qM</span></code></p></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(J(q)\)</span></p></td>
<td><p><span class="math">\(n_C
\times n_V\)</span></p></td>
<td><p>constraint
Jacobian</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mjData.efc_J</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(r(q)\)</span></p></td>
<td><p><span class="math">\(n_C\)</span></p></td>
<td><p>constraint
residual</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mjData.efc_pos</span></code></p></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(f(q, v,
\tau)\)</span></p></td>
<td><p><span class="math">\(n_C\)</span></p></td>
<td><p>constraint
force</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mjData.efc_force</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<p>All model elements are enumerated at compile time and assembled into the above system-level vectors and matrices. In our
earlier arm model <a class="reference internal" href="overview.html#examples"><span class="std std-ref">example</span></a> the model has <span class="math">\(n_V = 13\)</span> degrees of freedom: 3 for the ball joint, one
for each of the 4 hinge joints, and 6 for the free-floating object. They appear in the same order in all system-level
vectors and matrices whose dimensionality is <span class="math">\(n_V\)</span>. The data corresponding to a given model element can be
recovered via indexing operations as illustrated in the <a class="reference internal" href="overview.html#clarifications"><span class="std std-ref">Clarifications</span></a> section in the Overview chapter. Vectors
and matrices with dimensionality <span class="math">\(n_C\)</span> are somewhat different because the active <a class="reference internal" href="#constraint"><span class="std std-ref">constraints</span></a>
change at runtime. In that case there is still a fixed enumeration order (corresponding to the order in which the model
elements appear in <code class="docutils literal notranslate"><span class="pre">mjModel</span></code>) but any inactive constraints are omitted.</p>
<p>The number of position coordinates <span class="math">\(n_Q\)</span> is larger than the number of degrees of freedom <span class="math">\(n_V\)</span> whenever
quaternions are used to represent 3D orientations. This occurs when the model contains ball joints or free joints (i.e.,
in most models). In that case <span class="math">\(\dot{q}\)</span> does not equal <span class="math">\(v\)</span>, at least not in the usual sense. Instead one has
to consider the group of rigid body orientations <span class="math">\(SO(3)\)</span> - which has the geometry of a unit sphere in 4D space.
Velocities live in the 3D tangent space to this sphere. This is taken into account by all internal computations. For
custom computations, MuJoCo provides the function <a class="reference internal" href="APIreference/APIfunctions.html#mj-differentiatepos"><span class="std std-ref">mj_differentiatePos</span></a> which “subtracts” two position vectors with
dimensionality <span class="math">\(n_Q\)</span> and returns a velocity vector with dimensionality <span class="math">\(n_V\)</span>. A number of quaternion-related
utility functions are also provided.</p>
<p>MuJoCo computes both forward and inverse dynamics in continuous time. Forward dynamics are then integrated over the
specified <code class="docutils literal notranslate"><span class="pre">mjModel.opt.timestep</span></code> with the chosen <a class="reference internal" href="#geintegration"><span class="std std-ref">numerical
integrator</span></a>. The general equations of motion in continuous time are</p>
<div class="math-wrapper docutils container" id="equation-eq-motion">
<div class="math" id="equation-eq-motion">
<span class="eqno">(1)<a class="headerlink" href="#equation-eq-motion" title="Permalink to this equation">#</a></span>\[M \dot{v} + c = \tau + J^T f

\]</div>
</div>
<p>The Jacobian establishes the relationship between quantities in joint and constraint coordinates. It maps motion vectors
(velocities and accelerations) from joint to constraint coordinates: the joint velocity <span class="math">\(v\)</span> maps to velocity
<span class="math">\(J v\)</span> in constraint coordinates. The transpose of the Jacobian maps force vectors from constraint to joint
coordinates: the constraint force <span class="math">\(f\)</span> maps to force <span class="math">\(J^T f\)</span> in joint coordinates.</p>
<p>The joint-space inertia matrix <span class="math">\(M\)</span> is always invertible. Therefore once the constraint force <span class="math">\(f\)</span> is known,
we can finalize the forward and inverse dynamics computations as</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
\text{forward:} & & \dot{v} &= M^{-1} (\tau + J^T f - c) \\
\text{inverse:} & & \tau    &= M \dot{v} + c - J^T f \\
\end{aligned}

\]</div>
</div>
<p>The computation of the constraint force is the hard part and will be described later. But first, we complete the
description of the general framework by summarizing how the above quantities up to the constraint Jacobian are computed.</p>
<ul class="simple">
<li><p>The applied force <span class="math">\(\tau\)</span> includes <a class="reference internal" href="#gepassive"><span class="std std-ref">passive</span></a> forces from spring-dampers and fluid dynamics,
<a class="reference internal" href="#geactuation"><span class="std std-ref">actuation</span></a> forces, and additonal forces specified by the user.</p></li>
<li><p>The bias force <span class="math">\(c\)</span> includes Coriolis, centrifugal and gravitational forces. Their sum is computed using the
Recursive Newton-Euler (RNE) algorithm with acceleration set to 0.</p></li>
<li><p>The joint-space inertia matrix <span class="math">\(M\)</span> is computed using the Composite Rigid-Body (CRB) algorithm. This matrix is
usually quite sparse, and we represent it as such, in a custom format tailored to kinematic trees.</p></li>
<li><p>Since we often need to multiply vectors by the inverse of <span class="math">\(M\)</span>, we compute its <span class="math">\(L^T D L\)</span> factorization in
a way that preserves sparsity. When a quantity of the form <span class="math">\(M^{-1} x\)</span> is needed later, it is computed via
sparse back-substitution.</p></li>
</ul>
<p>Before any of these computations we apply forward kinematics, which computes the global position and orientation of all
spatial objects as well as the joint axes. While it is often recommended to apply RNE and CRB in local coordinates, here
we are setting the stage for collision detection which is done in global coordinates, thus RNE and CRB are also
implemented in global coordinates. Nevertheless, to improve floating point accuracy, we represent the data for each
kinematic subtree in a global frame centered at the subtree center of mass (fields starting with c in <code class="docutils literal notranslate"><span class="pre">mjData</span></code>). A
detailed summary of the <a class="reference internal" href="#pipeline"><span class="std std-ref">simulation pipeline</span></a> is given at the end of the chapter.</p>
<section id="actuation-model">
<span id="geactuation"></span><h3>Actuation model<a class="headerlink" href="#actuation-model" title="Permalink to this headline">#</a></h3>
<p>MuJoCo provides a flexible actuator model. All actuators are single-input-single-output (SISO). The input to actuator
<span class="math">\(i\)</span> is a scalar control <span class="math">\(u_i\)</span> specified by the user. The output is a scalar force <span class="math">\(p_i\)</span> which is
mapped to joint coordinates by a vector of moment arms determined by the transmission. An actuator can also have
activation state <span class="math">\(w_i\)</span> with its own dynamics. The control inputs for all actuators are stored in <code class="docutils literal notranslate"><span class="pre">mjData.ctrl</span></code>,
the force outputs are stored in <code class="docutils literal notranslate"><span class="pre">mjData.actuator_force</span></code>, and the activation states (if any) are stored in
<code class="docutils literal notranslate"><span class="pre">mjData.act</span></code>.</p>
<p>These three components of an actuator - transmission, activation dynamics, and force generation - determine how the
actuator works. The user can set them independently for maximum flexibility, or use <a class="reference internal" href="modeling.html#cactuator"><span class="std std-ref">Actuator shortcuts</span></a> which instantiate common actuator types.</p>
<section id="transmission">
<span id="getransmission"></span><h4>Transmission<a class="headerlink" href="#transmission" title="Permalink to this headline">#</a></h4>
<p>Each actuator has a scalar length <span class="math">\(l_i(q)\)</span> defined by the type of transmission and its parameters. The gradient
<span class="math">\(\nabla l_i\)</span> is an <span class="math">\(n_V\)</span>-dimensional vector of moment arms. It determines the mapping from scalar
actuator force to joint force. The transmission properties are determined by the MuJoCo object to which the actuator
is attached; the possible attachment object types are <span class="at">joint</span>, <span class="at">tendon</span>, <span class="at">jointinparent</span>,
<span class="at">slider-crank</span>, <span class="at">site</span>, and <span class="at">body</span>.</p>
<dl>
<dt><span class="at">joint</span> and <span class="at">tendon</span></dt><dd><p>The <span class="at">joint</span> and <span class="at">tendon</span> transmission types act as expected and correspond to the actuator applying forces or
torques to the target object. Ball joints are special, see the <a class="reference internal" href="XMLreference.html#actuator-general-joint"><span class="std std-ref">actuator/general/joint</span></a>
documentation for more details.</p>
</dd>
<dt><span class="at">jointinparent</span></dt><dd><p>The <span class="at">jointinparent</span> transmission is unique to ball and free joint and asserts that rotation should be measured
in the parent rather than child frame.</p>
</dd>
<dt><span class="at">slider-crank</span></dt><dd><p><span class="at">slider-crank</span> <a class="reference external" href="https://en.wikipedia.org/wiki/Slider-crank_linkage">transmissions</a> transform a linear force to
a torque, as in a piston-driven combustion engine. <a class="reference external" href="https://github.com/deepmind/mujoco/tree/main/model/slider_crank">This model</a> contains pedagogical examples. Slider-cranks can
also be modeled explicitly by creating MuJoCo bodies and coupling them with equality constraints to the rest of the
system, but that would be less efficient.</p>
</dd>
<dt><span class="at">site</span></dt><dd><p><span class="at">site</span> transmission (without a <span class="at">refsite</span>, see below) and <span class="at">body</span> transmission targets have a fixed zero
length <span class="math">\(l_i(q) = 0\)</span>. They can therefore not be used to maintain a desired length, but can be used to apply
forces. Site transmissions correspond to applying a Cartsian force/torque at the site, and are useful for modeling
jets and propellors. <span class="el">body</span> transmissions correspond to applying forces at contact points belonging to a body, in
order to model vacuum grippers and biomechanical adhesive appendages. For more information about adhesion, see the
<a class="reference internal" href="XMLreference.html#actuator-adhesion"><span class="std std-ref">adhesion</span></a> actuator documentation.</p>
<p>If a <span class="at">site</span> transmission target is defined with the optional <span class="at">refsite</span> attribute, forces and torques are
applied in the frame of the reference site rather than the site’s own frame. If a reference site is defined then
the length of the actuator is nonzero and corresponds to the pose difference of the two sites. This length can then
be controlled with a <span class="el">position</span> actuator, enabling Cartesian end-effector control. See the
<a class="reference internal" href="XMLreference.html#actuator-general-refsite"><span class="std std-ref">refsite</span></a> documentation for more details.</p>
</dd>
</dl>
</section>
<section id="activation-dynamics">
<span id="geactivation"></span><h4>Activation dynamics<a class="headerlink" href="#activation-dynamics" title="Permalink to this headline">#</a></h4>
<p>Some actuators such as pneumatic and hydraulic cylinders as well as biological muscles have an internal state called
“activation”. This is a true dynamic state, beyond the joint positions <span class="math">\(q\)</span> and velocities <span class="math">\(v\)</span>. Including
such actuators in the model results in 3rd-order dynamics. We denote the vector of actuator activations <span class="math">\(w\)</span>.
They have some first-order dynamics</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\dot{w}_i \left( u_i, w_i, l_i, \dot{l}_i \right)

\]</div>
</div>
<p>determined by the activation type and corresponding model parameters. Note that each actuator has scalar dynamics
independent of the other actuators. The activation types currently implemented are</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
\text{integrator}:  & & \dot{w}_i &= u_i \\
\text{filter}:      & & \dot{w}_i &= (u_i - w_i) / t \\
\text{filterexact}: & & \dot{w}_i &= (u_i - w_i) / t \\
\end{aligned}

\]</div>
</div>
<p>where <span class="math">\(t\)</span> is an actuator-specific time constant stored in <code class="docutils literal notranslate"><span class="pre">mjModel.actuator_dynprm</span></code>. In addition the type can
be “user”, in which case <span class="math">\(w_i\)</span> is computed by the user-defined callback <a class="reference internal" href="APIreference/APIglobals.html#mjcb-act-dyn"><span class="std std-ref">mjcb_act_dyn</span></a>. The type can also
be “none” which corresponds to a regular actuator with no activation state. The dimensionality of <span class="math">\(w\)</span> equals
the number of actuators whose activation type is different from “none”.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">filterexact</span></code> activation dynamics, Euler integration of <span class="math">\(\dot{w}\)</span> is replaced with the analytic integral:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
\text{filter}:      & & w_{i+1} &= w_i + h (u_i - w_i) / t \\
\text{filterexact}: & & w_{i+1} &= w_i + (u_i - w_i) (1 - e^{-h / t}) \\
\end{aligned}

\]</div>
</div>
<p>The two expressions converge to the same value in the <span class="math">\(h \rightarrow 0\)</span> limit.</p>
<p>Note that Euler-integrated filters diverge for <span class="math">\(t &lt; h\)</span>, while exactly-integrated filters are stable for any
<span class="math">\(t &gt; 0\)</span>.</p>
</section>
<section id="force-generation">
<span id="geactuatorforce"></span><h4>Force generation<a class="headerlink" href="#force-generation" title="Permalink to this headline">#</a></h4>
<p>Each actuator generates a scalar force <span class="math">\(p_i\)</span> which is some function</p>
<div class="math-wrapper docutils container">
<div class="math">
\[p_i \left( u_i, w_i, l_i, \dot{l}_i \right)

\]</div>
</div>
<p>Similarly to activation dynamics, the force generation mechanism is actuator-specific and cannot interact with the
other actuators in the model. Currently the force is affine in the activation state when present, and in the control
otherwise:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[p_i = (a w_i \; \text{or} \; a u_i) + b_0 + b_1 l_i + b_2 \dot{l}_i

\]</div>
</div>
<p>Here <span class="math">\(a\)</span> is an actuator-specific gain parameter and <span class="math">\(b_0, b_1, b_2\)</span> are actuator-specific bias
parameters, stored in <code class="docutils literal notranslate"><span class="pre">mjModel.actuator_gainprm</span></code> and <code class="docutils literal notranslate"><span class="pre">mjModel.actuator_biasprm</span></code> respectively. Different settings
of the gain and bias parameters can be used to model direct force control as well as position and velocity servos -in
which case the control/activation has the meaning of reference position or velocity. One can also compute custom gain
and bias terms by installing the callbacks <a class="reference internal" href="APIreference/APIglobals.html#mjcb-act-gain"><span class="std std-ref">mjcb_act_gain</span></a> and <a class="reference internal" href="APIreference/APIglobals.html#mjcb-act-bias"><span class="std std-ref">mjcb_act_bias</span></a> and setting the gain and
bias type to “user”. Note that affine force generation makes it possible to infer the controls/activations from the
applied force computed in inverse dynamics, using the pseudo-inverse of the matrix of moment arms. However some of
the actuators used in the real world are not affine (especially those that have embedded low-level controllers), so
we are considering extensions to the above model.</p>
<p>Putting all this together, the net force in generalized coordinates contributed by all actuators is</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\sum_i \nabla l_i(q) \; p_i \left(u_i, w_i, l_i(q), \dot{l}_i(q, v) \right)

\]</div>
</div>
<p>This quantity is stored in <code class="docutils literal notranslate"><span class="pre">mjData.qfrc_actuator</span></code>. It is added to the applied force vector <span class="math">\(\tau\)</span>, together
with any user-defined forces in joint or Cartesian coordinates (which are stored in <code class="docutils literal notranslate"><span class="pre">mjData.qfrc_applied</span></code> and
<code class="docutils literal notranslate"><span class="pre">mjData.xfrc_applied</span></code> respectively).</p>
<p>Optionally, the <a class="reference internal" href="XMLreference.html#actuator-general-actearly"><span class="std std-ref">actearly</span></a> attribute on an actuator computes <code class="docutils literal notranslate"><span class="pre">mjData.qfrc_actuator</span></code>
based on the value of <span class="math">\(w_{i+1}\)</span> after integration, reducing the delay between changes to <span class="math">\(u\)</span> and
<span class="math">\(t\)</span>.</p>
</section>
</section>
<section id="passive-forces">
<span id="gepassive"></span><h3>Passive forces<a class="headerlink" href="#passive-forces" title="Permalink to this headline">#</a></h3>
<p>Passive forces are defined as forces that depend only on position and velocity, and not on control in forward dynamics
or acceleration in inverse dynamics. As a result, such forces are inputs to both the forward and inverse dynamics
computations, and are identical in both cases. They are stored in <code class="docutils literal notranslate"><span class="pre">mjData.qfrc_passive</span></code>. The passive forces computed
by MuJoCo are also passive in the sense of physics, i.e., they do not increase energy, however the user can install the
callback <a class="reference internal" href="APIreference/APIglobals.html#mjcb-passive"><span class="std std-ref">mjcb_passive</span></a> and add forces to <code class="docutils literal notranslate"><span class="pre">mjData.qfrc_passive</span></code> that may increase energy. This will not interfere
with MuJoCo’s operation as long as such user forces depend only on position and velocity.</p>
<p>MuJoCo can compute three types of passive forces: spring-dampers in joints and tendons, gravity compensation forces, and
fluid dynamics.</p>
<p>When Euler or the implicit integator are used, joint damping is integrated implicitly which significantly increases
stability. Thus, even though damping can be modeled as an actuator property, it is better to model it as a joint
property. Note also the XML <a class="reference internal" href="XMLreference.html#body-joint"><span class="std std-ref">joint</span></a> attribute springdamper which automates the creation of mass-
spring-dampers with desired time constants and damping ratios; in that case the compiler computes the stiffness and
damping coefficients of the joint by taking the joint inertia into account.</p>
<p>Gravity compensation is a force applied to a body’s center of mass opposing gravity, see <a class="reference internal" href="XMLreference.html#body"><span class="std std-ref">body gravcomp</span></a> for
details.</p>
<p>Proper simulation of fluid dynamics is beyond the scope of MuJoCo, and would be too slow for the applications we aim to
facilitate. Nevertheless we provide a phenomenological model which is sufficient for simulating behaviors such as flying
and swimming. It is enabled by setting <code class="docutils literal notranslate"><span class="pre">mjModel.opt.viscosity</span></code> and <code class="docutils literal notranslate"><span class="pre">mjModel.opt.density</span></code> to positive values (they
are zero by default). These parameters specify the viscosity <span class="math">\(\beta\)</span> and density <span class="math">\(\rho\)</span> of the medium and
apply to all bodies. The shape of each body for fluid dynamics purposes is assumed to be the equivalent inertia box,
which can also be visualized. Each forward-facing (relative to the linear velocity) face of the box experiences force
along its normal direction. All faces also experience torque due to the angular velocity; this torque is obtained by
integrating the force resulting from the rotation over the surface area. In this sub-section only, let <span class="math">\(v\)</span> and
<span class="math">\(\omega\)</span> denote the linear and angular body velocity in its local frame (which is aligned with the equivalent
inertia box), and <span class="math">\(s\)</span> the 3D vector of box sizes. When the contributions from all faces are added, the resulting
force and torque in local body coordinates have <span class="math">\(i\)</span>-th component</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
\text{density force} : \quad &- {1 \over 2} \rho s_j s_k |v_i| v_i \\
\text{density torque} : \quad &- {1 \over 64} \rho s_i \left(s_j^4 + s_k^4 \right) |\omega_i| \omega_i \\
\end{aligned}

\]</div>
</div>
<p>This model implicitly assumes high Reynolds numbers, with lift-to-drag ratio equal to the tangent of the angle of
attack. One can also specify a non-zero <code class="docutils literal notranslate"><span class="pre">mjModel.opt.wind</span></code>, which is a 3D vector subtracted from the body linear
velocity in the fluid dynamics computation.</p>
<p>Each body also experiences a force and a torque proportional to viscosity and opposite to its linear and angular
velocity. Note that viscosity can be used independent of density, to make the simulation more damped. We use the
formulas for a sphere at low Reynolds numbers, with diameter <span class="math">\(d\)</span> equal to the average of the equivalent inertia
box sizes. The resulting 3D force and torque in local body coordinates are</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
\text{viscosity force} : \quad &- 3 \beta \pi d v \\
\text{viscosity torque} : \quad &- \beta \pi d^3 \omega \\
\end{aligned}

\]</div>
</div>
<p>Existing phenomenological models of fluid dynamics tend to be valid for one regime (e.g. flat vs. spherical objects) and
it is difficult to construct a model which can be simulated efficiently and is broadly valid. For example, drag forces
are known to transition from being linear in velocity at low Reynolds numbers, to being quadratic in velocity at high
Reynolds numbers. However it is not clear how this transition should occur for lift forces. This motivated the above
separation, using density to compute all quadratic forces and viscosity to compute all linear forces. Users who need a
more detailed simulation of fluid dynamics should leave the density and viscosity parameters set to zero so as to
disable the built-in mechanism. A custom model of fluid dynamics (or any other force field that depends only on position
and velocity) can be implemented in the callback <a class="reference internal" href="APIreference/APIglobals.html#mjcb-passive"><span class="std std-ref">mjcb_passive</span></a>.</p>
</section>
<section id="numerical-integration">
<span id="geintegration"></span><h3>Numerical integration<a class="headerlink" href="#numerical-integration" title="Permalink to this headline">#</a></h3>
<p>MuJoCo computes forward and inverse dynamics in continuous time. The end result of forward dynamics is the joint
acceleration <span class="math">\(a=\dot{v}\)</span> as well as the actuator activations <span class="math">\(\dot{w}\)</span> when present in the model. These are
used to advance the simulation time from <span class="math">\(t\)</span> to <span class="math">\(t+h\)</span>, and to update the state variables <span class="math">\(q, v, w\)</span>.</p>
<p>Four numerical integrators are available, three single-step integrators and the multi-step 4th order Runge-Kutta
integrator. Before describing the integrators, we begin with a general description of single-step Euler integrators:
<em>explicit</em>, <em>semi-implicit</em> and <em>implicit-in-velocity</em>. The <em>explicit</em> Euler method is not supported by MuJoCo but has
pedagogical value. It can be written as:</p>
<div class="math-wrapper docutils container" id="equation-eq-explicit">
<div class="math" id="equation-eq-explicit">
<span class="eqno">(2)<a class="headerlink" href="#equation-eq-explicit" title="Permalink to this equation">#</a></span>\[\begin{aligned}
   \textrm{activation:}\quad w_{t+h} &= w_t + h \dot{w}_t \\
   \textrm{velocity:}\quad v_{t+h} &= v_t + h a_t \\
   \textrm{position:}\quad q_{t+h} &= q_t + h v_t
\end{aligned}\]</div>
</div>
<p>Note that in the presence of quaternions, the operation <span class="math">\(q_t + h v_t\)</span> is more involved than a simple summation, as
the dimensionalities of <span class="math">\(q\)</span> and <span class="math">\(v\)</span> are different. The reason explicit Euler is not implemented is that the
following formulation, known as <em>semi-implicit</em> Euler is <a class="reference external" href="https://en.wikipedia.org/wiki/Semi-implicit_Euler_method">strictly better</a>, and standard in physics simulation:</p>
<div class="math-wrapper docutils container" id="equation-eq-semimplicit">
<div class="math" id="equation-eq-semimplicit">
<span class="eqno">(3)<a class="headerlink" href="#equation-eq-semimplicit" title="Permalink to this equation">#</a></span>\[ \begin{aligned}
    v_{t+h} &= v_t + h a_t \\
    q_{t+h} &= q_t + h v_{\color{red}t+h}
 \end{aligned}\]</div>
</div>
<p>Comparing <a class="reference internal" href="#equation-eq-explicit">(2)</a> and <a class="reference internal" href="#equation-eq-semimplicit">(3)</a>, we see that in semi-implicit Euler, the position is updated using
the <em>new</em> velocity. <em>Implicit</em> Euler means:</p>
<div class="math-wrapper docutils container" id="equation-eq-implicit">
<div class="math" id="equation-eq-implicit">
<span class="eqno">(4)<a class="headerlink" href="#equation-eq-implicit" title="Permalink to this equation">#</a></span>\[\begin{aligned}
   v_{t+h} &= v_t + h a_{\color{red}t+h} \\
   q_{t+h} &= q_t + h v_{t+h}
\end{aligned}\]</div>
</div>
<p>Comparing <a class="reference internal" href="#equation-eq-semimplicit">(3)</a> and <a class="reference internal" href="#equation-eq-implicit">(4)</a>, we see that the acceleration <span class="math">\(a_{t+h}=\dot{v}_{t+h}\)</span> on the
right hand side of the velocity update is evaluated at the <em>next time step</em>. While evaluating the next acceleration
is not possible without stepping, we can use a first-order Taylor expansion to approximate this quantity, and
take a single step of Newton’s method. When the expansion is only with respect to velocity (and not position), the
integrator is known as <em>implicit-in-velocity</em> Euler. This approach is particularly effective in systems where
instabilities are caused by velocity-dependent forces: multi-joint pendulums, bodies tumbling through space, systems
with lift and drag forces, and systems with substantial damping in tendons and actuators. Writing the
acceleration as a function of velocity: <span class="math">\(a_t = a(v_t)\)</span>, the velocity update we aim to approximate is</p>
<div class="math-wrapper docutils container">
<div class="math">
\[v_{t+h} = v_t + h a(v_{t+h})

\]</div>
</div>
<p>This is a non-linear equation in the unknown vector <span class="math">\(v_{t+h}\)</span> and can be solved numerically at each time step
using a first-order expansion of <span class="math">\(a(v_{t+h})\)</span> around <span class="math">\(v_t\)</span>. Recall that the forward dynamics are</p>
<div class="math-wrapper docutils container">
<div class="math">
\[a(v) = M^{-1} \big(\tau(v) - c(v) + J^T f(v)\big)

\]</div>
</div>
<p>Thus we define the derivative</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
    {\partial a(v) \over \partial v} &= M^{-1} D \\
    D &\equiv {\partial \over \partial v} \Big(\tau(v) - c (v) + J^T f(v)\Big)
\end{aligned}

\]</div>
</div>
<p>The velocity update corresponding to Newton’s method is as follows. First, we expand the right hand side to first order</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
   v_{t+h} &= v_t + h a(v_{t+h}) \\
           &\approx v_t + h \big( a(v_t) + {\partial a(v) \over \partial v} \cdot (v_{t+h}-v_t) \big) \\
           &= v_t + h a(v_t) + h M^{-1} D \cdot (v_{t+h}-v_t)
\end{aligned}

\]</div>
</div>
<p>Premultiplying by <span class="math">\(M\)</span> and rearranging yields</p>
<div class="math-wrapper docutils container">
<div class="math">
\[(M-h D) v_{t+h} = (M-h D) v_t + h M a(v_t)

\]</div>
</div>
<p>Solving for <span class="math">\(v_{t+h}\)</span>, we obtain the implicit-in-velocity update</p>
<div class="math-wrapper docutils container" id="equation-eq-implicit-update">
<div class="math" id="equation-eq-implicit-update">
<span class="eqno">(5)<a class="headerlink" href="#equation-eq-implicit-update" title="Permalink to this equation">#</a></span>\[v_{t+h} = v_t + h (M-h D)^{-1} M a(v_t)\]</div>
</div>
<p>All three single-step integrators in MuJoCo use the update <a class="reference internal" href="#equation-eq-implicit-update">(5)</a>, with different definitions of the
<span class="math">\(D\)</span> matrix, which is always computed analytically.</p>
<dl>
<dt>Semi-implicit with implicit joint damping (<code class="docutils literal notranslate"><span class="pre">Euler</span></code>)</dt><dd><p>For this method, <span class="math">\(D\)</span> only includes derivatives of joint damping. Note that in this case <span class="math">\(D\)</span> is diagonal
and <span class="math">\(M-h D\)</span> is symmetric, so Cholesky decomposition can be used. If the model has no joint damping or the
<a class="reference internal" href="XMLreference.html#option-flag-eulerdamp"><span class="std std-ref">eulerdamp</span></a> disable-flag is set, implicit damping is disabled and the semi-implicit
update <a class="reference internal" href="#equation-eq-semimplicit">(3)</a> is used, rather than <a class="reference internal" href="#equation-eq-implicit-update">(5)</a>.</p>
</dd>
<dt>Implicit-in-velocity (<code class="docutils literal notranslate"><span class="pre">implicit</span></code>)</dt><dd><p>For this method, <span class="math">\(D\)</span> includes derivatives of all forces except the constraint forces <span class="math">\(J^T f(v)\)</span>. These
are currently ignored since even though computing them is possible, it is complicated, and numerical tests show that
including them does not confer much benefit. That said, analytical derivatives of constraint forces are planned for a
future version. Additionally, we restrict <span class="math">\(D\)</span> to have the same sparsity pattern as <span class="math">\(M\)</span>, for computational
efficiency. This restriction will exclude damping in tendons which connect bodies that are on different branches of
the kinematic tree. Since <span class="math">\(D\)</span> is not symmetric, we cannot use Cholesky factorization, but because <span class="math">\(D\)</span> and
<span class="math">\(M\)</span> have the same sparsity pattern corresponding to the topology of the kinematic tree, reverse-order LU
factorization of <span class="math">\(M-h D\)</span> is <a class="reference external" href="https://link.springer.com/book/10.1007/978-1-4899-7560-7">guaranteed to have no fill-in</a>.  This factorization is stored <code class="docutils literal notranslate"><span class="pre">mjData.qLU</span></code>.</p>
</dd>
<dt>Fast implicit-in-velocity (<code class="docutils literal notranslate"><span class="pre">implicitfast</span></code>)</dt><dd><p>For this method, <span class="math">\(D\)</span> includes derivatives of all forces used in the implicit method, with the exception of the
centripetal and Coriolis forces <span class="math">\(c (v)\)</span> computed by the RNE algorithm. Additionally, it is symmetrized <span class="math">\(D
\leftarrow (D + D^T)/2\)</span>. One reason for dropping the RNE derivatives is that they are the most expensive to compute.
Second, these forces change rapidly only at high rotational velocities of complex pendula and spinning bodies,
scenarios which are not common and already well-handled by the Runge-Kutta integrator (see below). Because the RNE
derivatives are also the main source of asymmetry of <span class="math">\(D\)</span>, by dropping them and symmetrizing, we can use the
faster Cholesky rather than LU decomposition.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The implicitfast integrator has similar computational cost to Euler, yet provides increased stability, and is
therefore a strict improvement. It is the recommended integrator and will become the default in a future version.</p>
</div>
</dd>
<dt>4th-order Runge-Kutta (<code class="docutils literal notranslate"><span class="pre">RK4</span></code>)</dt><dd><p>One advantage of our continuous-time formulation is that we can use higher order integrators such as Runge-Kutta or
multistep methods. The only such integrator currently implemented is the fixed-step <a class="reference external" href="https://en.wikipedia.org/wiki/Runge–Kutta_methods#Derivation_of_the_Runge–Kutta_fourth-order_method">4th-order Runge-Kutta method</a>, though users
can easily implement other integrators by calling <a class="reference internal" href="APIreference/APIfunctions.html#mj-forward"><span class="std std-ref">mj_forward</span></a> and integrating accelerations themselves. We have
observed that for energy-conserving systems (<a class="reference external" href="https://github.com/deepmind/mujoco/blob/main/test/engine/testdata/derivative/energy_conserving_pendulum.xml">example</a>) RK4
is qualitatively better than the single-step methods, both in terms of stability and accuracy, even when the timestep
is decreased by a factor of 4 (so the computational effort is identical).  In the presence of large velocity-
dependent forces, if the chosen single-step method integrates those forces implicitly, single-step methods can be
significantly more stable than RK4.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The accuracy and stability of all integrators can be improved by reducing the time step <span class="math">\(h\)</span> which is stored in
<code class="docutils literal notranslate"><span class="pre">mjModel.opt.timestep</span></code>. Of course this also slows down the simulation. The time step is perhaps the most important
parameter that the user can adjust. If it is too large, the simulation will become unstable. If it is too small, CPU
time will be wasted without meaningful improvement in accuracy. There is always a comfortable range where the time
step is “just right”, but that range is model-dependent.</p>
</div>
</section>
<section id="the-state">
<span id="gestate"></span><h3>The State<a class="headerlink" href="#the-state" title="Permalink to this headline">#</a></h3>
<p>To complete our description of the general framework we will now discuss the notion of <em>state</em>. MuJoCo has a compact,
well-defined internal state which, together with the <a class="reference internal" href="#pireproducibility"><span class="std std-ref">deterministic computational pipeline</span></a>,
means that operations like resetting the state and computing dynamics derivatives are also well-defined.</p>
<p>The state is entirely encapsulated in the <a class="reference internal" href="APIreference/APItypes.html#mjdata"><span class="std std-ref">mjData</span></a> struct and consists of several components. The components are
enumerated in <a class="reference internal" href="APIreference/APItypes.html#mjtstate"><span class="std std-ref">mjtState</span></a> as bit flags, along with several common combinations, corresponding to the groupings
below. Concatenated state vectors can be conveniently read from and written into <a class="reference internal" href="APIreference/APItypes.html#mjdata"><span class="std std-ref">mjData</span></a> using <a class="reference internal" href="APIreference/APIfunctions.html#mj-getstate"><span class="std std-ref">mj_getState</span></a>
and <a class="reference internal" href="APIreference/APIfunctions.html#mj-setstate"><span class="std std-ref">mj_setState</span></a>, respectively.</p>
<section id="physics-state">
<span id="gephysicsstate"></span><h4>Physics state<a class="headerlink" href="#physics-state" title="Permalink to this headline">#</a></h4>
<p>The <em>physics state</em> (<a class="reference internal" href="APIreference/APItypes.html#mjtstate"><span class="std std-ref">mjSTATE_PHYSICS</span></a>) contains the main quantities which are time-integrated during
stepping. These are <code class="docutils literal notranslate"><span class="pre">mjData.{qpos,</span> <span class="pre">qvel,</span> <span class="pre">act}</span></code>:</p>
<dl class="simple">
<dt>Position: <code class="docutils literal notranslate"><span class="pre">qpos</span></code></dt><dd><p>The configuration in generalized coodinates, denoted above as <span class="math">\(q\)</span>.</p>
</dd>
<dt>Velocity: <code class="docutils literal notranslate"><span class="pre">qvel</span></code></dt><dd><p>The generalized velocities, denoted above as <span class="math">\(v\)</span>.</p>
</dd>
<dt>Actuator activation: <code class="docutils literal notranslate"><span class="pre">act</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mjData.act</span></code> contains the internal states of stateful actuators, denoted above as <span class="math">\(w\)</span>.</p>
</dd>
</dl>
</section>
<section id="full-physics-state">
<span id="gefullphysics"></span><h4>Full physics state<a class="headerlink" href="#full-physics-state" title="Permalink to this headline">#</a></h4>
<p>The <em>full physics state</em> (<a class="reference internal" href="APIreference/APItypes.html#mjtstate"><span class="std std-ref">mjSTATE_FULLPHYSICS</span></a>) contains the physics state and two additional
components:</p>
<dl class="simple">
<dt>Time: <code class="docutils literal notranslate"><span class="pre">time</span></code></dt><dd><p>The simulation time is given by the scalar <code class="docutils literal notranslate"><span class="pre">mjData.time</span></code>. Since physics is time-invariant, it is
excluded from the <em>physics state</em>; exceptions include time-dependent user callbacks and plugins (e.g., an open-loop
controller), in which case time should be included.</p>
</dd>
<dt>Plugin state: <code class="docutils literal notranslate"><span class="pre">plugin_state</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mjData.plugin_state</span></code> are states declared by <a class="reference internal" href="programming/extension.html#explugin"><span class="std std-ref">engine plugins</span></a>. Please see the <a class="reference internal" href="programming/extension.html#expluginstate"><span class="std std-ref">Plugin state</span></a>
section for more details.</p>
</dd>
</dl>
</section>
<section id="user-inputs">
<span id="geinput"></span><h4>User inputs<a class="headerlink" href="#user-inputs" title="Permalink to this headline">#</a></h4>
<p>These input fields (<a class="reference internal" href="APIreference/APItypes.html#mjtstate"><span class="std std-ref">mjSTATE_USER</span></a>) are set by the user and affect the physics simulation, but are
untouched by the simulator. All input fields except for MoCap poses default to 0.</p>
<dl>
<dt>Control: <code class="docutils literal notranslate"><span class="pre">ctrl</span></code></dt><dd><p>Controls are defined by the <a class="reference internal" href="XMLreference.html#actuator"><span class="std std-ref">actuator</span></a> section of the XML. <code class="docutils literal notranslate"><span class="pre">mjData.ctrl</span></code> values either produce
generalized forces directly (stateless actuators), or affect the actuator activations in <code class="docutils literal notranslate"><span class="pre">mjData.act</span></code>, which then
produce forces.</p>
</dd>
<dt>Auxillary Controls: <code class="docutils literal notranslate"><span class="pre">qfrc_applied</span></code> and <code class="docutils literal notranslate"><span class="pre">xfrc_applied</span></code></dt><dd><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">mjData.qfrc_applied</span></code> are directly applied generalized forces.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">mjData.xfrc_applied</span></code> are Cartesian wrenches applied to the CoM of individual bodies. This field is used for
example, by the <a class="reference internal" href="programming/samples.html#sasimulate"><span class="std std-ref">native viewer</span></a> to apply mouse perturbations.</div>
<div class="line">Note that the effects of <code class="docutils literal notranslate"><span class="pre">qfrc_applied</span></code> and <code class="docutils literal notranslate"><span class="pre">xfrc_applied</span></code> can usually be recreated by appropriate actuator
definitions.</div>
</div>
</dd>
<dt>MoCap poses: <code class="docutils literal notranslate"><span class="pre">mocap_pos</span></code> and <code class="docutils literal notranslate"><span class="pre">mocap_quat</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mjData.mocap_pos</span></code> and <code class="docutils literal notranslate"><span class="pre">mjData.mocap_quat</span></code> are special optional kinematic states <a class="reference internal" href="modeling.html#cmocap"><span class="std std-ref">described here</span></a>,
which allow the user to set the positions and orientations of static bodies in real-time, for example when streaming
6D poses from a motion-capture device. The default values set by <a class="reference internal" href="APIreference/APIfunctions.html#mj-resetdata"><span class="std std-ref">mj_resetData</span></a> are the poses of the bodies at
the default configuration.</p>
</dd>
<dt>User data: <code class="docutils literal notranslate"><span class="pre">userdata</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mjData.userdata</span></code> acts as a user-defined memory space untouched by the engine. For example it can be used by
callbacks. This is described in more detail in the <a class="reference internal" href="programming/simulation.html#sisimulation"><span class="std std-ref">Programming chapter</span></a>.</p>
</dd>
</dl>
</section>
<section id="warmstart-acceleration">
<span id="gewarmstart"></span><h4>Warmstart acceleration<a class="headerlink" href="#warmstart-acceleration" title="Permalink to this headline">#</a></h4>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">qacc_warmstart</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mjData.qacc_warmstart</span></code> are accelerations used to warmstart the constraint solver, saved from the previous step.
When using a slowly-converging <a class="reference internal" href="#solver"><span class="std std-ref">constraint solver</span></a> like PGS, these can speed up simulation by reducing
the number of iterations required for convergence. Note however that the default Newton solver converges so quickly
(usually 2-3 iterations), that warmstarts often have no effect on speed and can be disabled.</p>
<p>Different warmstarts have no perceptible effect on the dynamics but should be saved if perfect numerical
reproducibility is required when loading a non-initial state. Note that even though their effect on physics is
negligible, many physical systems will accumulate small differences  <a class="reference external" href="https://en.wikipedia.org/wiki/Lyapunov_exponent">exponentially</a> when time-stepping, quickly leading to divergent trajectories
for different warmstarts.</p>
</dd>
</dl>
</section>
<section id="integration-state">
<span id="geintegrationstate"></span><h4>Integration state<a class="headerlink" href="#integration-state" title="Permalink to this headline">#</a></h4>
<p>The <em>integration state</em> (<a class="reference internal" href="APIreference/APItypes.html#mjtstate"><span class="std std-ref">mjSTATE_INTEGRATION</span></a>) is the union of all the above <a class="reference internal" href="APIreference/APItypes.html#mjdata"><span class="std std-ref">mjData</span></a> fields and
constitutes the entire set of inputs to the <em>forward dynamics</em>. In the case of <em>inverse dynamics</em>, <code class="docutils literal notranslate"><span class="pre">mjData.qacc</span></code> is
also treated as an input variable. All other <a class="reference internal" href="APIreference/APItypes.html#mjdata"><span class="std std-ref">mjData</span></a> fields are functions of the integration state.</p>
<p>Note that the full integration state as given by <a class="reference internal" href="APIreference/APItypes.html#mjtstate"><span class="std std-ref">mjSTATE_INTEGRATION</span></a> is maximalist and includes fields
which are often unused. If a small state size is desired, it might be sensible to avoid saving unused fields.
In particular <code class="docutils literal notranslate"><span class="pre">xfrc_applied</span></code> can be quite large (<code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">nbody</span></code>) yet is often unused.</p>
</section>
<section id="simulation-state-mjdata">
<span id="gesimulationstate"></span><h4>Simulation state: <code class="docutils literal notranslate"><span class="pre">mjData</span></code><a class="headerlink" href="#simulation-state-mjdata" title="Permalink to this headline">#</a></h4>
<p>The <em>simulation state</em> is the entirety of the <a class="reference internal" href="APIreference/APItypes.html#mjdata"><span class="std std-ref">mjData</span></a> struct and associated memory buffer. This state includes
all derived quantities computed during dynamics computation. Because the <a class="reference internal" href="APIreference/APItypes.html#mjdata"><span class="std std-ref">mjData</span></a> buffers are preallocated for the
worst case, it is often significantly faster to recompute derived quantities from the <em>integration state</em> rather than
using <a class="reference internal" href="APIreference/APIfunctions.html#mj-copydata"><span class="std std-ref">mj_copyData</span></a>.</p>
</section>
</section>
</section>
<section id="constraint-model">
<span id="constraint"></span><h2>Constraint model<a class="headerlink" href="#constraint-model" title="Permalink to this headline">#</a></h2>
<p>MuJoCo has a very flexible constraint model, which is nevertheless handled in a uniform way by the
<a class="reference internal" href="#solver"><span class="std std-ref">solver</span></a> described later. Here we explain what the individual constraints are conceptually, and how they
are laid out in the system-level vector and matrices with dimensionality <span class="math">\(n_C\)</span>. Each conceptual constraint can
contribute one or more scalar constraints towards the total count <span class="math">\(n_C\)</span>, and each scalar constraint has a
corresponding row in the constraint Jacobian <span class="math">\(J\)</span>. Active constraints are ordered by type in the order in which the
types are described below, and then by model element within each type. The types are: equality, friction loss, limit,
contact. Limits are handled as frictionless contacts by the solver and are not treated as a separate type internally. We
use the prefix <code class="docutils literal notranslate"><span class="pre">efc</span></code> in <code class="docutils literal notranslate"><span class="pre">mjData</span></code> to denote system-level vectors and matrices with constraint-related data.</p>
<section id="equality">
<span id="coequality"></span><h3>Equality<a class="headerlink" href="#equality" title="Permalink to this headline">#</a></h3>
<p>MuJoCo can model equality constraints in the general form <span class="math">\(r(q) = 0\)</span> where <span class="math">\(r\)</span> can be any differentiable
scalar or vector function of the position vector <span class="math">\(q\)</span>. It has the semantics of a residual. The solver can actually
work with non-holonomic constraints as well, but we do not yet have such constraint types defined. Each equality
constraint contributes <span class="math">\(\dim(r)\)</span> elements to the total constraint count <span class="math">\(n_C\)</span>. The corresponding block in
<span class="math">\(J\)</span> is simply the Jacobian of the residual, namely <span class="math">\(\partial r / \partial q\)</span>. Note that due to the
properties of quaternions, differentiation with respect to <span class="math">\(q\)</span> produces vectors of size <span class="math">\(n_V\)</span> rather than
<span class="math">\(n_Q\)</span>.</p>
<p>Among other applications, equality constraints can be used to create “loop joints”, i.e., joints that cannot be modeled
via the kinematic tree. Gaming engines represent all joints in this way. The same can be done in MuJoCo but is not
recommended - because it leads to both slower and less accurate simulation, effectively turning MuJoCo into a gaming
engine. The only reason to represent joints with equality constraints would be to model soft joints - which can be done
via the constraint solver but not via the kinematic tree.</p>
<p>There are five types of equality constraints described next. The numbers in the headings correspond to the
dimensionality of the constraint residual in each case.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">connect</span></code><span class="classifier">3</span></dt><dd><p>This constraint connects two bodies at a point, effectively creating a ball joint outside the kinematic tree. The
model specifies the two bodies to be connected, and a point (or “anchor”) in the local frame of each body. The
constraint residual is then defined as the difference between the global 3D positions of these points. Note that
specifying two connect constraints for the same pair of bodies can be used to model a hinge joint outside the
kinematic tree. Specifying three or more connect constraints (whose anchors are not co-linear) is mathematically
equivalent to a weld constraint but is less efficient computationally.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">weld</span></code><span class="classifier">6</span></dt><dd><p>This constraint welds two bodies together, suppressing all relative degrees of freedom between them. The relative
body positions and orientations that are being enforced by the constraint solver are parameters in <code class="docutils literal notranslate"><span class="pre">mjModel</span></code>. The
compiler computes them from the initial configuration in which the model is defined, namely <code class="docutils literal notranslate"><span class="pre">mjModel.qpos0</span></code>, but
the user can change them later. The 6D residual has a 3D position component identical to the connect constraint,
followed by a 3D orientation component. The latter is defined as <span class="math">\(\sin(\theta/2)
(x, y, z)\)</span> where <span class="math">\(\theta\)</span> is the rotation angle in radians and <span class="math">\((x, y, z)\)</span> is the unit vector
corresponding to the rotation axis. For small angles this approaches the exponential map representation of the
orientation difference (modulo a factor of 2). For large angles it avoids the wrap-around discontinuity that would
result if we used <span class="math">\(\theta\)</span> instead of <span class="math">\(\sin(\theta/2)\)</span>. It does have a drawback though: when the angle
approaches 180 deg the constraint becomes weak. Note also that if one body is a child of the other body, a faster and
more accurate way to implement the weld constraint is to simply remove all joints defined in the child body.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">joint</span></code><span class="classifier">1</span></dt><dd><p>This constraint applies only to scalar joints: hinge and slide. It can be used to lock one joint into a constant
position, or to couple two joints via a quartic polynomial. Locking a joint is better achieved by removing the joint,
however it can be useful in special cases such as modeling backlash (via a soft equality constraint). Coupling of two
joints is useful for modeling helical joints, or other forms of mechanical coupling. The quartic polynomial model is
defined as follows. Suppose <span class="math">\(y\)</span> is the position of the first joint and <span class="math">\(x\)</span> is the position of the second
joint, and the subscript 0 denotes the corresponding joint positions when the model is in the initial configuration
<code class="docutils literal notranslate"><span class="pre">mjModel.qpos0</span></code>. Then the equality constraint is</p>
<div class="math-wrapper docutils container">
<div class="math">
\[y-y_0 = a_0 + a_1 \left( x-x_0 \right) + a_2 \left( x-x_0 \right)^2 +
        a_3 \left( x-x_0 \right)^3 + a_4 \left( x-x_0 \right)^4

\]</div>
</div>
<p>where <span class="math">\(a_0, \ldots, a_4\)</span> are coefficients defined in the model. If the constraint involves only one joint, it
reduces to <span class="math">\(y-y_0 = a_0\)</span>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tendon</span></code><span class="classifier">1</span></dt><dd><p>This constraint is very similar to the joint constraint above, but applies to the length of tendons instead of the
position of joints. Tendons are length quantities that depend on the vector of positions. This dependence can be a
linear combination of scalar joint positions, or a minimal-length string wrapping around spatial obstacles. Unlike
joints whose positions in model configuration <code class="docutils literal notranslate"><span class="pre">mjModel.qpos0</span></code> can be read directly from the position vector, the
computation of tendon lengths is less trivial. This is why the “resting lengths” of all tendons are computed by the
compiler and stored in <code class="docutils literal notranslate"><span class="pre">mjModel</span></code>. In general, all fields of <code class="docutils literal notranslate"><span class="pre">mjModel</span></code> whose names end with 0 are quantities
computed by the compiler in the initial model configuration <code class="docutils literal notranslate"><span class="pre">mjModel.qpos0</span></code>.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">distance</span></code> : 1</p>
<blockquote>
<div><div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>Distance equality constraints were removed in MuJoCo version 2.2.2. If you are using an earlier version, please
switch to the corresponding version of the documentation.</p>
</div>
</div></blockquote>
</section>
<section id="friction-loss">
<span id="cofriction"></span><h3>Friction loss<a class="headerlink" href="#friction-loss" title="Permalink to this headline">#</a></h3>
<p>Friction loss is also known as dry friction, or static friction, or load-independent friction (in contrast with Coulomb
friction which scales with normal force). Similar to damping or viscosity, it has the effect of opposing motion. However
it acts preemptively before the onset of motion, and so it cannot be modeled as a velocity-dependent force. Instead it
is modeled as a constraint, namely an upper limit on the absolute value of the force that friction can generate. This
limit is specified via the attribute frictionloss of the corresponding model element, and can be applied to joints and
tendons.</p>
<p>Friction loss is different from all other constraint types in that there is no position residual that can be associated
with it; so we formally set the corresponding components of <span class="math">\(r(q)\)</span> to zero. Indeed we will see later that our
constraint solver formulation needs to be extended in an unusual way to incorporate this constraint. Nevertheless the
velocity of the affected joint or tendon acts as a velocity “residual” - because the effect of the constraint is to
reduce this velocity and ideally keep it at zero. Thus the corresponding block in the constraint Jacobian is simply the
Jacobian of the joint position (or tendon length) with respect to <span class="math">\(q\)</span>. For scalar joints this is a vector of 0s
with a 1 at the joint address. For tendons this is known as the moment arm vector.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">joint</span></code><span class="classifier">1, 3 or 6</span></dt><dd><p>Friction loss can be defined not only for scalar joints (slide and hinge), but also for ball joints which have 3
degrees of freedom, and free joints which have 6 degrees of freedom. When defined, it is applied independently to all
degrees of freedom of the affected joint. The frictionloss parameter has implicit units compatible with the joint
(linear or angular). Free joints are an exception because they have both linear and angular components, and the MJCF
model format allows a single frictionloss parameter per joint. In that case the same parameter is used for both the
linear and angular components. It could be argued that friction loss in free joints should not be allowed. However we
allow it because it can model useful non-physical effects, such as keeping an object in place until something pushes
it with sufficient force.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tendon</span></code><span class="classifier">1</span></dt><dd><p>Tendons are scalar quantities, thus defining friction loss for a tendon always adds one scalar constraint. For
spatial tendons this could be used to model friction between the tendon and the surfaces it wraps around. Such
friction will be load-independent though. To construct a more detailed model of this phenomenon, create several small
floating spheres and connect them with tendons in series. Then the contacts between the spheres and the surrounding
surfaces will have load-dependent (i.e., Coulomb) friction, but this is less efficient to simulate.</p>
</dd>
</dl>
</section>
<section id="limit">
<span id="colimit"></span><h3>Limit<a class="headerlink" href="#limit" title="Permalink to this headline">#</a></h3>
<p>Limits as well as contacts have a well-defined spatial residual, but unlike equality constraints they are uni-lateral,
i.e. they introduce inequality rather than equality constraints. Limits can be defined for joints and tendons. This is
done by tagging the corresponding model element as “limited” and defining its “range” parameter. The residual
<span class="math">\(r(q)\)</span> is the distance between the current position/length and the closer of the two limiting values specified in
range. The sign of this distance is automatically adjusted so that it is positive if the limit is not yet reached, zero
at the limit, and negative if the limit is violated. The constraint becomes active when this distance falls below the
“margin” parameter. However this is not the same as offsetting limit by margin and setting margin to 0. Instead the
constraint force depends on distance through the solver <a class="reference internal" href="#soparameters"><span class="std std-ref">parameters</span></a> described later.</p>
<p>It is possible that both the lower and the upper limits for a given joint or tendon become active. In that case they are
both included in the list of scalar constraints, however this situation should be avoided - by increasing the range or
decreasing the margin. In particular, avoid using narrow ranges to approximate an equality constraint. Instead use an
explicit equality constraint, and if some slack is desired make the constraint soft by adjusting the solver parameters.
This is more efficient computationally, not only because it involves one scalar constraint instead of two, but also
because solving for equality constraint forces is generally faster.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">joint</span></code><span class="classifier">1 or 2</span></dt><dd><p>Limits can be defined for scalar joints (hinge and slide) as well as for ball joints. Scalar joints are treated as
described above. Ball joint limits are applied to the exponential-map or angle-axis representation of the joint
quaternion, i.e., the vector <span class="math">\((\theta x, \theta y, \theta z)\)</span> where <span class="math">\(\theta\)</span> is the rotation angle and
<span class="math">\((x, y, z)\)</span> is the unit vector corresponding to the rotation axis. The limit is applied to the absolute value
of the rotation angle <span class="math">\(\theta\)</span>. At runtime the limit is determined by the larger of the two range parameters.
For semantic clarity however, one should use the second range parameter to specify the limit and set the first range
parameter to 0. This rule is enforced by the compiler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tendon</span></code><span class="classifier">1 or 2</span></dt><dd><p>Tendon are scalar quantities and their limits are treated as described above. Note that fixed tendons (which are
linear combinations of scalar joint positions) can have both positive and negative “lengths”, because joint positions
are defined relative to the joint reference and can be both positive and negative. Spatial tendons however have true
lengths which cannot be negative. Keep this in mind when setting ranges and margins for tendon limits.</p>
</dd>
</dl>
</section>
<section id="contact">
<span id="cocontact"></span><h3>Contact<a class="headerlink" href="#contact" title="Permalink to this headline">#</a></h3>
<p>Contacts are the most elaborate constraint type, both in terms of specifying them in the model and in terms of the
computations that need to be performed. This is because contact modeling is challenging to begin with, and furthermore
we support a general contact model allowing tangential, torsional and rolling friction, as well as elliptic and
pyramidal friction cones.</p>
<p>MuJoCo works with point contacts, defined geometrically by a point between two geoms and a spatial frame centered at
that point, both expressed in global coordinates. The first (<span class="math">\(x\)</span>) axis of this frame is the contact normal
direction, while the remaining (<span class="math">\(y\)</span> and <span class="math">\(z\)</span>) axes define the tangent plane. One might have expected the
normal to correspond to the <span class="math">\(z\)</span> axis, as in MuJoCo’s visualization convention, but we support frictionless
contacts where only the normal axis is used, which is why we want to have the normal in first position. Similar to
limits, the contact distance is positive when the two geoms are separated, zero when they touch, and negative when they
penetrate. The contact point is in the middle between the two surfaces along the normal axis (for mesh collisions this
may be approximate). <a class="reference internal" href="#collision"><span class="std std-ref">Collision
detection</span></a> is a separate topic discussed in detail below. All we need for now is that the contact point,
spatial frame and normal distance are given by the collision detector.</p>
<p>In addition to the above quantities which are computed online, each contact has several parameters obtained from the
model definition.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">condim</span></code></p></td>
<td><p>Dimensionality of the contact
force/torque in the contact
frame. It can be 1, 3, 4 or 6.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">friction</span></code></p></td>
<td><p>Vector of friction coefficients,
with dimensionality <code class="docutils literal notranslate"><span class="pre">condim-1</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">margin</span></code></p></td>
<td><p>The distance margin used to
determine if the contact should
be included in the global contact
array <code class="docutils literal notranslate"><span class="pre">mjData.contact</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gap</span></code></p></td>
<td><p>For custom computations it is
sometimes convenient to include
contacts in <code class="docutils literal notranslate"><span class="pre">mjData.contact</span></code>
but not generate contact forces.
This is what <code class="docutils literal notranslate"><span class="pre">gap</span></code> does:
contact forces are generated only
when the normal distance is below
margin-gap.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">solref</span></code> and <code class="docutils literal notranslate"><span class="pre">solimp</span></code></p></td>
<td><p><a class="reference internal" href="#solver"><span class="std std-ref">Solver</span></a>
parameters explained later.</p></td>
</tr>
</tbody>
</table>
</div>
<p>The contact friction cone can be either elliptic or pyramidal. This is a global setting determined by the choice of
constraint solver: the elliptic solvers work with elliptic cones, while the pyramidal solvers work with pyramidal cones,
as defined later. The <code class="docutils literal notranslate"><span class="pre">condim</span></code> parameter determines the contact type, and has the following meaning:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">condim</span> <span class="pre">=</span> <span class="pre">1</span></code><span class="classifier">1 for elliptic, 1 for pyramidal</span></dt><dd><p>This corresponds to a frictionless contact and adds only one scalar constraint. Recall that the first axis of the
contact frame is the contact normal. Frictionless contacts can only generate force along the normal. This is very
similar to a joint or tendon limit, but is applied to the distance between two geoms.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condim</span> <span class="pre">=</span> <span class="pre">3</span></code><span class="classifier">3 for elliptic, 4 for pyramidal</span></dt><dd><p>This is a regular frictional contact, which can generate normal force as well as tangential friction force opposing
slip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condim</span> <span class="pre">=</span> <span class="pre">4</span></code><span class="classifier">4 for elliptic, 6 for pyramidal</span></dt><dd><p>In addition to normal and tangential force, this contact can generate torsional friction torque opposing rotation
around the contact normal. This is useful for modeling soft fingers, and can substantially improve the stability of
simulated grasping. Keep in mind that the torsional (as well as rolling) friction coefficients have different units
from the tangential friction coefficients.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condim</span> <span class="pre">=</span> <span class="pre">6</span></code><span class="classifier">6 for elliptic, 10 for pyramidal</span></dt><dd><p>This contact can oppose motion in all relative degrees of freedom between the two geoms. In particular it adds
rolling friction, which can be used for example to stop a ball from rolling indefinitely on a plane. It can also be
used to model rolling friction between tires and a road, and in general to stabilize contacts.</p>
</dd>
</dl>
<p>Note that condim cannot be 2 or 5. This is because the two tangential directions and the two rolling directions are
treated as pairs. The friction coefficients within a pair can be different though, which can be used to model skating
for example.</p>
<p>Now we describe the friction cones and the corresponding Jacobians more formally. In this section only, let <span class="math">\(f\)</span>
denote the vector of constraint forces for a single contact (as opposed to the system-level vector of constraint
forces), <span class="math">\(\mu\)</span> the vector of friction coefficients, and <span class="math">\(n\)</span> the contact dimensionality condim. For
<span class="math">\(n &gt; 1\)</span> the elliptic and pyramidal friction cones are defined as</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
 \text{elliptic cone}: & & \mathcal{K} &=
    \left\{ f \in \mathbb{R}^n : f_1 \geq 0,
            f_1^2 \geq \sum_{i=2}^n {f_i^2 / \mu_{i-1}^2} \right\} \\
 \text{pyramidal cone}: & & \mathcal{K} &=
    \left\{ f \in \mathbb{R}^{2(n-1)} : f \geq 0 \right\} \\
\end{aligned}

\]</div>
</div>
<p>The vector inequality in the pyramidal cone definition is meant element-wise. For <span class="math">\(n=1\)</span> both cones are defined as
the non-negative ray (which is a special case of a cone). Note that the system-level friction cone discussed in the
solver section below will also be denoted <span class="math">\(\mathcal{K}\)</span>. It is the product of the friction cones for the
individual contacts as defined here.</p>
<p>We also need to specify how the constraint force acts on the system. This is done by associating a 6D basis vector with
each component of <span class="math">\(f\)</span>. The basis vectors are spatial vectors: 3D force followed by 3D torque. Arranging the basis
vectors into the columns of a matrix <span class="math">\(E\)</span>, the force/torque generated by the constraint force in the contact frame
is <span class="math">\(E f\)</span>. The matrix of basis vectors is constructed as follows.</p>
<a class="reference internal image-reference" href="_images/contact_frame.svg"><img alt="_images/contact_frame.svg" class="align-center" src="_images/contact_frame.svg" width="700px" /></a>
<p>The figure illustrates the full basis set corresponding to the case <span class="math">\(n = 6\)</span>. Otherwise we use only the first
<span class="math">\(n\)</span> or <span class="math">\(2(n-1)\)</span> columns depending on the cone type. Elliptic cones are easier to understand. Since the
matrix <span class="math">\(E\)</span> is the identity matrix, the first three components of <span class="math">\(f\)</span> are forces acting along the axes of the
contact frame, while the next three components are torques acting around the axes. For pyramidal cones, the basis
vectors correspond to the edges of a pyramid. Each vector combines a normal force component and either a frictional
force or a frictional torque component. The scaling by the friction coefficients ensures that all basis vectors lie
within the elliptic friction cone we are approximating. The same holds for any convex combination of these vectors.</p>
<p>Finally we specify how the contact Jacobian is computed. First we construct the <span class="math">\(6\)</span>-by-<span class="math">\(n_V\)</span> matrix
<span class="math">\(S\)</span> which maps joint velocities <span class="math">\(v\)</span> to spatial velocities <span class="math">\(S v\)</span> expressed in the contact frame. This
is done by considering the contact point as belonging to one or the other geom, computing its spatial Jacobian, and
subtracting these two Jacobians to obtain <span class="math">\(S\)</span>. The convention we use is that the contact force acts from the first
towards the second geom, so the spatial Jacobian for the first geom has negative sign. The contact Jacobian is then
<span class="math">\(E^T S\)</span>. As with all other constraints, this matrix is inserted into the system-level Jacobian <span class="math">\(J\)</span>.</p>
</section>
</section>
<section id="constraint-solver">
<span id="solver"></span><h2>Constraint solver<a class="headerlink" href="#constraint-solver" title="Permalink to this headline">#</a></h2>
<p>This section explains how the constraint forces are computed. This is done in two stages. First, the constraint forces
are defined as the unique global solution to a convex optimization problem. It is a quadratic program for pyramidal
cones and a conic program for elliptic cones. Second, the optimization problem is solved with the algorithms described
below. We also describe the parameters of the constraint model and how they affect the resulting dynamics.</p>
<p>The definition of the optimization problem itself has two steps. We start with a primal problem defined over
accelerations <span class="math">\(\dot{v}\)</span> where the constraint forces are implicit. We then transform the primal problem over
accelerations into its Lagrange dual. The dual is a convex optimization problem over constraint forces, which also play
the role of Lagrange multipliers for the primal problem. In forward dynamics, either the primal or the dual problem has
to be solved numerically. In inverse dynamics, the problem becomes diagonal and can be solved analytically.</p>
<p>The primal formulation is based on a generalization of the Gauss principle of least constraint. In its basic form, the
Gauss principle states that if we have unconstrained dynamics <span class="math">\(M \dot{v} = \tau\)</span> and impose acceleration
constraint <span class="math">\(J \dot{v} = a^*\)</span>, the resulting acceleration will be</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\dot{v} = \arg \min_x \left\| x-M^{-1} \tau \right\|^2_M \\
\textrm{subject to} \; J x = a^*

\]</div>
</div>
<p>where the weighted <span class="math">\(L_2\)</span> norm is the usual <span class="math">\(\|x\|^2_M = x^T M x\)</span>. Thus the constraint causes the smallest
possible deviation from the unconstrained acceleration <span class="math">\(M^{-1}\tau\)</span>, where the metric for measuring deviations in
joint coordinates is given by the inertia matrix. This principle is known to be equivalent to the Lagrange-d’Alembert
principle of constrained motion. Here we will use it to obtain a rich yet principled model of soft constraints. This
will be done by generalizing both the cost function and the constraints in the Gauss principle.</p>
<p>We will use the following notation beyond the notation introduced earlier:</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Symbol</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math">\(z\)</span></p></td>
<td><p><span class="math">\(n_C\)</span></p></td>
<td><p>constraint
deformations</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(\omega\)</span></p></td>
<td><p><span class="math">\(n_C\)</span></p></td>
<td><p>velocity of
constraint
deformations</p></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(d\)</span></p></td>
<td><p><span class="math">\(n_C\)</span></p></td>
<td><p>constraint impedance</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(b\)</span></p></td>
<td><p><span class="math">\(n_C\)</span></p></td>
<td><p>virtual constraint
damping</p></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(k\)</span></p></td>
<td><p><span class="math">\(n_C\)</span></p></td>
<td><p>virtual constraint
stiffness</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(A(q)\)</span></p></td>
<td><p><span class="math">\(n_C \times
n_C\)</span></p></td>
<td><p>inverse inertia in
constraint space</p></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(R(q)\)</span></p></td>
<td><p><span class="math">\(n_C \times
n_C\)</span></p></td>
<td><p>diagonal regularizer
in constraint space</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(a^*(q,v)\)</span></p></td>
<td><p><span class="math">\(n_C\)</span></p></td>
<td><p>reference
acceleration in
constraint space</p></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(a^0(q, v,
\tau)\)</span></p></td>
<td><p><span class="math">\(n_C\)</span></p></td>
<td><p>unconstrained
acceleration in
constraint space</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(a^1(q, v,
\dot{v})\)</span></p></td>
<td><p><span class="math">\(n_C\)</span></p></td>
<td><p>constrained
acceleration in
constraint space</p></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(\mathcal{K}
(q)\)</span></p></td>
<td></td>
<td><p>product of all
contact friction
cones</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(\eta\)</span></p></td>
<td></td>
<td><p>upper bounds on
friction loss forces</p></td>
</tr>
<tr class="row-even"><td><p><span class="math">\(\Omega(q)\)</span></p></td>
<td></td>
<td><p>convex set of
admissible
constraint forces</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math">\(\mathcal{E},
\mathcal{F},
\mathcal{C}\)</span></p></td>
<td></td>
<td><p>index sets for
Equality, Friction
loss, Contact
constraints</p></td>
</tr>
</tbody>
</table>
</div>
<p>The index sets will be used to refer to parts of vectors and matrices. For example, <span class="math">\(J_\mathcal{C}\)</span> is the
sub-matrix of all rows of the Jacobian that correspond to contact constraints.</p>
<section id="primal-problem">
<span id="soprimal"></span><h3>Primal problem<a class="headerlink" href="#primal-problem" title="Permalink to this headline">#</a></h3>
<p>We first formulate the optimization problem whose solution yields the constrained acceleration <span class="math">\(\dot{v}\)</span>, and then
explain what it means and why it makes sense. That problem is</p>
<div class="math-wrapper docutils container" id="equation-eq-primal">
<div class="math" id="equation-eq-primal">
<span class="eqno">(6)<a class="headerlink" href="#equation-eq-primal" title="Permalink to this equation">#</a></span>\[(\dot{v}, \dot{\omega}) = \arg \min_{(x, y)}
                          \left\|x-M^{-1}(\tau-c)\right\|^2_M +
                          \left\|y-a^*\right\|^{\text{Huber}(\eta)}_{R^{-1}} \\
\textrm{subject to} \;
J_\mathcal{E} x_\mathcal{E} - y_\mathcal{E} = 0, \;
J_\mathcal{F} x_\mathcal{F} - y_\mathcal{F} = 0, \;
J_\mathcal{C} x_\mathcal{C} - y_\mathcal{C} \in \mathcal{K}^*

\]</div>
</div>
<p>The new players here are the diagonal regularizer <span class="math">\(R &gt; 0\)</span> which makes the constraints soft, and the reference
acceleration <span class="math">\(a^*\)</span> which stabilizes the constraints. The latter is similar in spirit to Baumgarte stabilization,
but instead of adding a constraint force directly, it modifies the optimization problem whose solution is the constraint
force. Since this problem is itself constrained, the relation between <span class="math">\(a^*\)</span> and <span class="math">\(f\)</span> is generally non-linear.
The quantities <span class="math">\(R\)</span> and <span class="math">\(a^*\)</span> are computed from the solver <a class="reference internal" href="#soparameters"><span class="std std-ref">parameters</span></a> as described
later. For now we assume they are given.</p>
<p>The optimization variable <span class="math">\(x\)</span> stands for acceleration as in the Gauss principle, while <span class="math">\(y\)</span> is a slack
variable in constraint space. It is needed to model soft constraints. If we forced the solution to reach
<span class="math">\(y = a^*\)</span>, which we could do by taking the limit <span class="math">\(R \to 0\)</span>, we would obtain a hard constraint model. This
limit is not allowed in MuJoCo, but nevertheless one can construct models that are phenomenologically hard.</p>
<p>The symbol <span class="math">\(\mathcal{K}^*\)</span> denotes the dual to the friction cone. It is motivated by mathematical reverse
engineering: we want to recover the constraint <span class="math">\(f \in \mathcal{K}\)</span> after taking the dual of our primal problem,
and the dual of the dual of a cone is the cone itself. The pyramidal friction cone defined earlier is actually
self-dual, but the elliptic one is not.</p>
<p>The Huber “norm” is based on the Huber function from robust statistics: it is a quadratic around zero, and transitions
smoothly to a linear function when the absolute value of the argument crosses a threshold - in this case given by the
friction loss parameters. Setting <span class="math">\(\eta = \infty\)</span> recovers the quadratic norm; we use this convention for all
constraint forces that are not due to friction loss. This is another instance of reverse engineering: we want to obtain
interval constraints on the friction loss forces, which is non-trivial because Lagrange duality usually yields
non-negativity constraints. It turns out that the Huber function is precisely what one needs in order to obtain interval
constraints in the dual. In the absence of friction loss constraints both norms become quadratic.</p>
<p>We now relate problem <a class="reference internal" href="#equation-eq-primal">(6)</a> more closely to the Gauss principle, and give physical meaning to the slack
variables. Consider an augmented dynamical system with position <span class="math">\((q, z)\)</span> and velocity <span class="math">\((v, \omega)\)</span>. The new
state variables correspond to deformation dynamics. Similarly to the original system where <span class="math">\(v\)</span> is not the same as
<span class="math">\(\dot{q}\)</span>, here <span class="math">\(\omega\)</span> is not the same as <span class="math">\(\dot{z}\)</span>, although the reason is different. Deformation
is related to non-zero position residual. Recall that we have well-defined position residuals for equality constraints,
limits, all components of pyramidal friction cones, and the normal component of elliptic friction cones. For these
deformation variables we have <span class="math">\(\dot{z} = \omega\)</span>. For friction loss and frictional components of elliptic cones
however, we have <span class="math">\(z = 0\)</span> while <span class="math">\(\omega \neq 0\)</span>. This is because even though there may be motion in the
constraint space (which the constraint force aims to prevent), there is no position error. The augmented dynamics are</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
\tilde{q} &= {q \brack z}, &
\tilde{v} &= {v \brack \omega}, &
\tilde{c} &= {c \brack 0}, \\
\tilde{\tau} &= {\tau \brack {R^{-1} a^*}}, &
\tilde{M} &= \left[\begin{array}{cc}
                   M & 0 \\
                   0 & R^{-1}
                   \end{array} \right], &
\tilde{J} &= \left[ \begin{array}{cc}J & -I \end{array} \right] \\
\end{aligned}

\]</div>
</div>
<p>Applying the Gauss principle to this system yields the primal optimization problem above, except for the Huber norm. The
general equations of motion <a class="reference internal" href="#equation-eq-motion">(1)</a> now become</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\tilde{M} \dot{\tilde{v}} + \tilde{c} = \tilde{\tau} + \tilde{J}^T f

\]</div>
</div>
<p>Unpacking all the tildes yields the explicit form of the original and the deformation dynamics:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
M \dot{v} + c &= \tau +J^T f \\
\dot{\omega} &= a^* - R f \\
\end{aligned}

\]</div>
</div>
<p>Thus <span class="math">\(R\)</span> has the meaning of inverse deformation inertia, while <span class="math">\(a^*\)</span> has the meaning of unforced deformation
acceleration.</p>
<p>Does MuJoCo keep these deformation variables as part of the system state and integrate their dynamics together with the
joint positions and velocities? No, although such an option may be worth providing in the future. Recall that we defined
the functional dependence of the regularizer and the reference acceleration as <span class="math">\(R(q)\)</span> and <span class="math">\(a^*(q, v)\)</span>. This
makes problem <a class="reference internal" href="#equation-eq-primal">(6)</a> dependent only on <span class="math">\((q, v, \tau)\)</span>, and so the original dynamics are not actually
affected by the deformation dynamics. Since the general constraint model we developed up to now makes no assumptions
about how <span class="math">\(R\)</span> and <span class="math">\(a^*\)</span> are computed, our choice is consistent and improves simulator efficiency.
Nevertheless, given that these quantities turned out to be related to the deformation dynamics, it may be more natural
to define them as <span class="math">\(R(z)\)</span> and <span class="math">\(a^* (z, \omega)\)</span> and simulate the entire augmented system. Below we clarify
some of the benefits of such a simulation.</p>
<p>When do the deformation dynamics “track” the original dynamics exactly? One can verify that this happens when the
constraint force <span class="math">\(f\)</span> equals the quantity <span class="math">\(f^+\)</span> defined in the parameter section below. Then the deformation
states become static functions of the joint position and velocity, namely <span class="math">\(z = r(q)\)</span> and <span class="math">\(\omega = J(q) v\)</span>.
But in general this is not the case. Suppose you push your finger into a soft material, pull it back faster than the
material can recover its shape, and push again. The contact force you experience on the second push depends not only on
the rigid-body positions of your finger and the object, but also on the material deformation created during the first
push. Simulating the above augmented dynamics would capture this phenomenon, while the model implemented in MuJoCo
ignores it and instead assumes that all objects recover their shape before the next contact. There is a related
phenomenon associated with slip in friction dimensions which is also ignored.</p>
</section>
<section id="reduced-primal-problem">
<span id="soreduced"></span><h3>Reduced primal problem<a class="headerlink" href="#reduced-primal-problem" title="Permalink to this headline">#</a></h3>
<p>The primal problem defined in <a class="reference internal" href="#equation-eq-primal">(6)</a>, as well as the dual problem we will obtain later, are both constrained
optimization problems. The dual will turn out to have a simpler form, but still, constrained optimization is numerically
less efficient than unconstrained optimization. It turns out that the primal problem can be reduced to unconstrained
optimization over accelerations. If <span class="math">\(x\)</span> in <a class="reference internal" href="#equation-eq-primal">(6)</a> is given, minimizing over <span class="math">\(y\)</span> can be done in
closed form. This also eliminates the constraints, in the sense that the solution for <span class="math">\(y\)</span> automatically satisfies
the constraints. We are then left with an unconstrained optimization problem over <span class="math">\(x\)</span> which can be solved with
more efficient algorithms.</p>
<p>The reduction is based on the fact that minimization over <span class="math">\(y\)</span> in <a class="reference internal" href="#equation-eq-primal">(6)</a> comes down to finding the nearest
point on the constraint set - which is either a plane or a cone, and can be done analytically. Substituting the result,
we obtain the unconstrained problem</p>
<div class="math-wrapper docutils container" id="equation-eq-reduced">
<div class="math" id="equation-eq-reduced">
<span class="eqno">(7)<a class="headerlink" href="#equation-eq-reduced" title="Permalink to this equation">#</a></span>\[\dot{v} = \arg \min_{x} \left\|x-M^{-1}(\tau-c)\right\|^2_M +
          s \left( J x - a^* \right)

\]</div>
</div>
<p>The function <span class="math">\(s(\cdot)\)</span> plays the role of a soft-constraint penalty. It can be shown to be convex and
once-continuously-differentiable. In the case of pyramidal friction cones it is a quadratic spline.</p>
<p>Another appealing feature of the reduced formulation is that the inverse dynamics can be easily computed. Since the
above problem is unconstrained and convex, the unique global minimum makes the gradient vanish. This yields the identity</p>
<div class="math-wrapper docutils container">
<div class="math">
\[M \dot{v} + c = \tau - J^T \nabla s \left( J \dot{v} - a^* \right)

\]</div>
</div>
<p>which is the analytical inverse dynamics in the presence of soft constraints. Comparing to the equations of motion
<a class="reference internal" href="#equation-eq-motion">(1)</a>, we see that the constraint forces <span class="math">\(f\)</span> are given by the negative gradient of the function
<span class="math">\(s(\cdot)\)</span>. Differentiating one more time with respect to <span class="math">\(\dot{v}\)</span> yields</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\frac{\partial \tau}{\partial \dot{v}} = M + J^T H[s] J

\]</div>
</div>
<p>This is the analytical derivative of applied force with respect to acceleration. Thus we see that the function
<span class="math">\(s(\cdot)\)</span> and its derivatives are key to the MuJoCo physics model.</p>
</section>
<section id="dual-problem">
<span id="sodual"></span><h3>Dual problem<a class="headerlink" href="#dual-problem" title="Permalink to this headline">#</a></h3>
<p>The procedure for constructing a Lagrange dual is somewhat tedious but well-established. We skip to the result. The
Lagrange dual to the primal problem defined above is</p>
<div class="math-wrapper docutils container" id="equation-eq-dual">
<div class="math" id="equation-eq-dual">
<span class="eqno">(8)<a class="headerlink" href="#equation-eq-dual" title="Permalink to this equation">#</a></span>\[f = \arg\min_\lambda \frac{1}{2} \lambda^{T} \left( A+R \right) \lambda +
    \lambda^T \left( a^0 - a^* \right) \\
\text{subject to} \; \lambda \in \Omega

\]</div>
</div>
<p>where the inverse inertia in constraint space is</p>
<div class="math-wrapper docutils container">
<div class="math">
\[A = J M^{-1} J^T

\]</div>
</div>
<p>and the unconstrained acceleration in constraint space is</p>
<div class="math-wrapper docutils container">
<div class="math">
\[a^0 = J M^{-1} (\tau-c) + \dot{J} v

\]</div>
</div>
<p>The constraint set <span class="math">\(\Omega\)</span> is as follows. <span class="math">\(\lambda_\mathcal{E}\)</span> is unconstrained, because it is the
Lagrange multiplier for an equality constraint in the primal problem. For friction loss we have the box constraint
<span class="math">\(\left|\lambda_\mathcal{F}\right| \leq \eta\)</span> applied element-wise. For contacts we have
<span class="math">\(\lambda_\mathcal{C} \in \mathcal{K}\)</span>. For pyramidal cones this is simply <span class="math">\(\lambda_\mathcal{C} \geq 0\)</span>,
while for elliptic cones it is a second-order cone constraint. While <span class="math">\(A\)</span> is only symmetric positive semi-definite,
<span class="math">\(R\)</span> is symmetric positive definite by construction, and so the above quadratic cost is strictly convex. Thus for
pyramidal friction cones we have a convex box-constrained quadratic program, and for elliptic friction cones we have a
mixture of box constraints and second-order cone constraints. The <a class="reference internal" href="#soalgorithms"><span class="std std-ref">algorithms</span></a> for solving this
problem are described later.</p>
<p>As mentioned earlier, MuJoCo’s constraint model has uniquely-defined inverse dynamics, and we already saw one way to
derive it in the reduced formulation above. Here we derive it again from the dual formulation. Recall that in inverse
dynamics we have access to <span class="math">\((q, v, \dot{v})\)</span> instead of <span class="math">\((q, v, \tau)\)</span>, so the unconstrained acceleration
<span class="math">\(a^0\)</span> is unknown. However we can compute the constrained acceleration</p>
<div class="math-wrapper docutils container">
<div class="math">
\[a^1 = J \dot{v} + \dot{J} v

\]</div>
</div>
<p>Inverse dynamics can now be computed by solving the optimization problem</p>
<div class="math-wrapper docutils container">
<div class="math">
\[f = \arg \min_\lambda \frac{1}{2} \lambda^{T} R \lambda +
    \lambda^T \left( a^1 - a^* \right) \\
\text{subject to} \; \lambda \in \Omega

\]</div>
</div>
<p>By comparing the KKT conditions for these two convex optimization problems, one can verify that their solutions coincide
when</p>
<div class="math-wrapper docutils container" id="equation-eq-identity">
<div class="math" id="equation-eq-identity">
<span class="eqno">(9)<a class="headerlink" href="#equation-eq-identity" title="Permalink to this equation">#</a></span>\[a^1 = a^0 + Af

\]</div>
</div>
<p>This key identity is essentially Newton’s second law projected in constraint space. It is derived by moving the term
<span class="math">\(c\)</span> in the equations of motion <a class="reference internal" href="#equation-eq-motion">(1)</a> to the right hand side, multiplying by <span class="math">\(J M^{-1}\)</span> from the
left, adding <span class="math">\(\dot{J} v\)</span> to both sides, and substituting the above definitions of <span class="math">\(A, a^0, a^1\)</span>. In terms of
implementation, we do not actually compute the acceleration term <span class="math">\(\dot{J} v\)</span>. This is because our optimization
problems depend on differences of constraint-space accelerations, and so this term would cancel out even if we were to
compute it.</p>
<p>Note that the quadratic term in the inverse problem is weighted by <span class="math">\(R\)</span> instead of <span class="math">\(A+R\)</span>. This tells us two
things. First, in the limit <span class="math">\(R \to 0\)</span> corresponding to hard constraints the inverse is no longer defined, as one
would expect. Second and more useful, the inverse problem is diagonal, i.e., it decouples into independent optimization
problems over the individual constraint forces. The only remaining coupling is due to the constraint set <span class="math">\(\Omega\)</span>,
but that set is also decoupled over the conceptual constraints discussed earlier. It turns out that all these
independent optimization problems can be solved analytically. The only non-trivial case is the elliptic friction cone
model; we have shown how it can be handled in the above-referenced
<a class="reference external" href="https://scholar.google.com/scholar?cluster=9217655838195954277">paper</a>. It requires a certain coupling of the
diagonal values of <span class="math">\(R\)</span>, which is automatically enforced by MuJoCo so as to enable an exact analytical inverse for
every model.</p>
<p>Once the forward dynamics are computed, the inverse dynamics are essentially free in terms of computation. This is
because the forward dynamics need all the quantities that enter into the inverse problem, and so the only extra step is
the analytical formula. This makes it possible to implement an automatic correctness check in MuJoCo. When the flag
<code class="docutils literal notranslate"><span class="pre">fwdinv</span></code> in <code class="docutils literal notranslate"><span class="pre">mjModel.opt.enableflags</span></code> is on, the forward and inverse dynamics are automatically compared at the end
of each time step, and the difference is recorded in <code class="docutils literal notranslate"><span class="pre">mjData.solver_fwdinv</span></code>. Discrepancies indicate that the forward
solver - which is numerical and is usually terminated early - is not converging well. Of course the inverse dynamics are
also useful on their own, without computing the forward dynamics first.</p>
</section>
<section id="algorithms">
<span id="soalgorithms"></span><h3>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">#</a></h3>
<p>Here we describe the numerical algorithms (or “solvers”) for solving the above convex optimization problems. The Newton
and CG solvers work with the reduced primal formulation <a class="reference internal" href="#equation-eq-reduced">(7)</a>, while the PGS solver works with the dual
formulation <a class="reference internal" href="#equation-eq-dual">(8)</a>. Note that numerical solvers are only needed in forward dynamics. Inverse dynamics are handled
analytically.</p>
<p>Each solver algorithm can be used with both pyramidal and elliptic friction cones, and both dense and sparse
representations of the constraint Jacobian and related matrices.</p>
<dl>
<dt><strong>CG</strong><span class="classifier">conjugate gradient method</span></dt><dd><p>This algorithm uses the non-linear conjugate gradient method with the Polak-Ribiere-Plus formula. Line-search is
exact, using Newton’s method in one dimension, with analytical second derivatives.</p>
</dd>
<dt><strong>Newton</strong><span class="classifier">Newton’s method</span></dt><dd><p>This algorithm implements the exact Newton method, with analytical second-order derivatives and Cholesky
factorization of the Hessian. The line-search is the same as in the CG method. It is the default solver.</p>
</dd>
<dt><strong>PGS</strong><span class="classifier">Projected Gauss-Seidel method</span></dt><dd><p>This is the most common algorithm used in physics simulators, and used to be the default in MuJoCo, until we
developed the Newton method which appears to be better in every way. PGS uses the dual formulation. Unlike
gradient-based method which improve the solution along oblique directions, Gauss-Seidel works on one scalar component
at a time, and sets it to its optimal value given the current values of all other components. One sweep of PGS has
the computational complexity of one matrix-vector multiplication (although the constants are larger). It has
first-order convergence but nevertheless makes rapid progress in a few iterations.</p>
<a class="reference internal image-reference" href="_images/gPGS.svg"><img alt="_images/gPGS.svg" class="align-center" src="_images/gPGS.svg" width="500px" /></a>
<p>When using pyramidal friction cones, the problem involves box constraints to which PGS has traditionally been
applied. If we applied PGS directly to the conic constraints resulting from elliptic friction cones, it would get
stuck in a continuum of local minima; see left panel. This is because it can only make progress along the coordinate
axes. The right panel illustrates our solution to this problem. We still update one contact at a time, but within a
contact we update along non-orthogonal axes adapted to the constraint surface, as follows. First, we optimize the
quadratic cost along the ray from the tip of the cone through the current solution. Then we slice the cone with a
hyperplane passing through the current solution and orthogonal to the contact normal. This yields an ellipsoid -which
can be up to 5-dimensional given our contact model. Now we optimize the quadratic cost within this ellipsoid. This is
an instance of quadratically constrained quadratic programming (QCQP). Since there is only one scalar constraint
(however nonlinear it may be), the dual is a scalar optimization problem over the unknown Lagrange multiplier. We
solve this problem with Newton’s method applied until convergence - which in practice takes less than 10 iterations,
and involves small matrices. Overall this algorithm has similar behavior to PGS for pyramidal cones, but it can
handle elliptic cones without approximating them. It does more work per contact, however the contact dimensionality
is smaller, and these two factors roughly balance each other.</p>
</dd>
</dl>
</section>
<section id="parameters">
<span id="soparameters"></span><h3>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">#</a></h3>
<p>Here we explain how the quantities <span class="math">\(R, a^*\)</span> are computed from model parameters. For the chosen parameterization to
make sense, we first need to understand how these quantities affect the dynamics. We focus on the unconstrained
minimizer of <a class="reference internal" href="#equation-eq-dual">(8)</a>, namely</p>
<div class="math-wrapper docutils container">
<div class="math">
\[f^+ = (A+R)^{-1} (a^* - a^0)

\]</div>
</div>
<p>If it happens that <span class="math">\(f^+ \in \Omega\)</span>, then <span class="math">\(f^+ = f\)</span> is the actual constraint force generated by our model.
We focus on this case because it is common, in the sense that the subset of the constraints in <span class="math">\(\Omega\)</span> that are
active at any given time is usually small, and furthermore it is the only case that we can actually analyze.
Substituting <span class="math">\(f^+\)</span> in the constraint dynamics <a class="reference internal" href="#equation-eq-identity">(9)</a> and rearranging terms yields</p>
<div class="math-wrapper docutils container">
<div class="math">
\[a^1 = A(A+R)^{-1} a^* + R (A+R)^{-1} a^0

\]</div>
</div>
<p>Thus the constrained acceleration interpolates between the unconstrained and the reference acceleration. In particular,
in the limit <span class="math">\(R \to 0\)</span> we have a hard constraint and <span class="math">\(a^1 = a^*\)</span>, while in the limit <span class="math">\(R \to \infty\)</span> we
have have an infinitely soft constraint (i.e., no constraint) and <span class="math">\(a^1 = a^0\)</span>. It is then natural to introduce a
model parameter which directly controls the interpolation. We call this parameter <em>impedance</em> and denote it <span class="math">\(d\)</span>.
It is a vector with dimensionality <span class="math">\(n_C\)</span> satisfying <span class="math">\(0&lt;d&lt;1\)</span> element-wise. Once it is specified, we compute
the diagonal elements of the regularizer as</p>
<div class="math-wrapper docutils container">
<div class="math">
\[R_{ii} = \frac{1-d_i}{d_i} \hat{A}_{ii}

\]</div>
</div>
<p>Note that we are not using the diagonal of the actual <span class="math">\(A\)</span> matrix, but an approximation to it. This is because we
do not want to have to compute <span class="math">\(A\)</span> in the sparse solver or in the inverse dynamics. The approximation (which is
limited to the diagonal) is constructed using the “end-effector” inertias of all bodies, joints and tendons when the
model is in the initial configuration <code class="docutils literal notranslate"><span class="pre">mjModel.qpos0</span></code>. These quantities are computed by the compiler. If our
approximation happened to be exact, and <span class="math">\(A\)</span> itself happened to be diagonal, then the acceleration of each scalar
constraint would satisfy</p>
<div class="math-wrapper docutils container">
<div class="math">
\[a^1_i = d_i a^*_i + (1-d_i) a^0_i

\]</div>
</div>
<p>and so we would achieve the desired interpolation effect. This of course does not hold exactly in general, but the goal
here is to construct a sensible and intuitive parameterization of the constraint model and get the scaling right.</p>
<p>Next we explain how the reference acceleration is computed. As already mentioned, we use a spring-damper model
parameterized by <em>damping</em> and <em>stiffness</em> coefficients element-wise:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[a^*_i = -b_i (J v)_i - k_i r_i

\]</div>
</div>
<p>Recall that <span class="math">\(r\)</span> is the position residual (which is zero for friction loss and friction dimensions of elliptic
cones), while <span class="math">\(J v\)</span> is the joint velocity projected in constraint space; the indexing notation refers to one
component of the projected velocity vector.</p>
<p>To summarize, the user specifies the vectors of impedance coefficients <span class="math">\(0&lt;d&lt;1\)</span>, damping coefficients <span class="math">\(b &gt; 0\)</span>
and stiffness coefficients <span class="math">\(k &gt; 0\)</span>. The quantities <span class="math">\(R, a^*\)</span> are then computed by MuJoCo as shown above, and
the selected optimization algorithm is applied to solve problem <a class="reference internal" href="#equation-eq-dual">(8)</a>. As explained in the <a class="reference internal" href="modeling.html#csolver"><span class="std std-ref">solver
parameters</span></a> section of the Modeling chapter, MuJoCo offers additional automation for setting <span class="math">\(d, b, k\)</span>
so as to achieve critical damping, or model a soft contact layer by varying <span class="math">\(d\)</span> with distance.</p>
</section>
<section id="friction-cones">
<span id="socones"></span><h3>Friction cones<a class="headerlink" href="#friction-cones" title="Permalink to this headline">#</a></h3>
<p>As explained above, MuJoCo allows both elliptic friction cones and pyramidal approximations to them; the selected solver
determines which type of friction cone is used. The pyramidal approximation has <span class="math">\(2 (n-1)\)</span> edges where <span class="math">\(n\)</span> is
the dimensionality of the contact space as specified by condim. We could add more edges yielding better approximations
to the underlying elliptic cone, but this is pointless because the resulting solver would become slower than its
elliptic counterpart.</p>
<p>One might have expected that if we were to increase the number of edges in the pyramidal approximation, the solution to
our optimization problem <a class="reference internal" href="#equation-eq-primal">(6)</a> would converge to the solution for the elliptic cone. This is true in the limit
of hard contacts. For soft contacts however, this turns out not be true. This surprising fact is not merely a
mathematical curiosity; it can have visible effects on the dynamics, which in earlier versions of MuJoCo made it
difficult to achieve fine grasping behaviors with the pyramidal approximation. To understand this phenomenon, consider
fixing the acceleration variables <span class="math">\(x\)</span> in problem <a class="reference internal" href="#equation-eq-primal">(6)</a> and optimize away the deformation variables
<span class="math">\(y\)</span>. It can be shown that the resulting optimization problem over <span class="math">\(x\)</span> is equivalent to a penalty method for
constrained optimization, where the penalty is a half-quadratic starting at the constraint boundary. Think of it as a
“shadow” being cast by the boundary. The shape of this shadow is different for elliptic cones and their pyramidal
approximations, no matter how accurate the approximation is. The figure below illustrates this effect for 2D contacts
where the pyramid is not even an approximation, but represents the same constraint set as the elliptic cone. We plot the
contours of the penalty/shadow for the pyramidal (red) and elliptic (dashed blue) cones, for different friction
coefficients varying from left to right. Mathematically, the penalty in the pyramidal case is a quadratic spline, while
the penalty in the elliptic case contains pieces that are quadratics minus square roots of quadratics - allowing
circular contours around the tip of the cone.</p>
<a class="reference internal image-reference" href="_images/softcontact.png"><img alt="_images/softcontact.png" class="align-center" src="_images/softcontact.png" style="width: 600px;" /></a>
<p>In summary, elliptic and pyramidal friction cones define different soft-contact dynamics (although they are usually very
close). The elliptic model is more principled and more consistent with physical intuition, and the corresponding solvers
are quite efficient, but depending on the model may not be as efficient as the pyramidal solvers.</p>
</section>
</section>
<section id="collision-detection">
<span id="collision"></span><h2>Collision detection<a class="headerlink" href="#collision-detection" title="Permalink to this headline">#</a></h2>
<p>Collision detection operates on geoms, which are geometric entities rigidly attached to the underlying bodies. The
output of collision detection is the list of active contacts, defined as having contact distance smaller than their
margin parameter. They are stored in the global array <code class="docutils literal notranslate"><span class="pre">mjData.contact</span></code> which is then used to construct the constraint
Jacobian and compute the constraint force. Below we explain how geom pairs are selected for collision checking, how
collision checking is done, and how the parameters of the resulting contact are determined.</p>
<section id="selection">
<span id="coselection"></span><h3>Selection<a class="headerlink" href="#selection" title="Permalink to this headline">#</a></h3>
<p>If a model has <span class="math">\(n\)</span> geoms, there are <span class="math">\(n (n-1)/2\)</span> geoms pairs that can potentially collide. Checking all these
pairs in detail (also known as near-phase collision detection) is prohibitively expensive for large systems. Fortunately
some of these potential collisions are undesirable and therefore excluded by the user at the modeling stage, while
others can be pruned quickly without a detailed check. MuJoCo has flexible mechanisms for deciding which geom pairs are
checked in detail. The decision process involves two stages: generation and filtering.</p>
<dl>
<dt>Generation</dt><dd><p>First we generate a list of candidate geom pairs in one of two ways: “pair” or “dynamic”. The user can also specify
“all” which merges both sources (and is the default). This is done via the setting <code class="docutils literal notranslate"><span class="pre">mjModel.opt.collision</span></code>. “Pair”
refers to an explicit list of geom pairs defined with the <a class="reference internal" href="XMLreference.html#contact-pair"><span class="std std-ref">pair</span></a> element in MJCF. It gives the
user full control, however it is a static mechanism (independent of the spatial arrangement of the geoms at runtime)
and can be tedious for large models. It is normally used to supplement the output of the “dynamic” mechanism. Dynamic
generation works with bodies rather than geoms; when a body pair is included this means that all geoms attached to
one body can collide with all geoms attached to the other body.</p>
<p>The body pairs are generated via broad-phase collision detection based on a modified sweep-and-prune algorithm. The
modification is that the axis for sorting is chosen as the principal eigenvector of the covariance matrix of all geom
centers - which maximizes the spread. Then, for each body pair, a mid-phase collision detection using a static
bounding volume hierarchy (a BVH binary tree) of axis-aligned bounding boxes (AABB) is performed. Each body is
equipped with an AABB tree of its geoms, aligned with the body inertial or geom frames for all inner or leaf nodes,
respectively.</p>
<p>Finally, the user can explicitly exclude certain body pairs using the <a class="reference internal" href="XMLreference.html#contact-exclude"><span class="std std-ref">exclude</span></a> element
in MJCF. Exclusion is applied when “dynamic” or “all” are selected, but not when “pair” is selected. At the end of
this step we have a list of geoms pairs that is typically much smaller than <span class="math">\(n (n-1)/2\)</span>, but can still be
pruned further before detailed collision checking.</p>
</dd>
<dt>Filtering</dt><dd><p>Next we apply four filters to the list generated in the previous step. Filters 1 and 2 are applied to all geom pairs.
Filters 3 and 4 are applied only to pairs generated by the “dynamic” mechanism, thereby allowing the user to bypass
those filters by specifying geom pairs explicitly.</p>
<ol class="arabic simple">
<li><p>The types of the two geoms must correspond to a collision function that is capable of performing the detailed
check. This is usually the case but there are exceptions (for example plane-plane collisions are not supported),
and furthermore the user may override the default table of collision functions with NULL pointers, effectively
disabling collisions between certain geom types.</p></li>
<li><p>A bounding sphere test is applied, taking into account the contact margin. If one of the geoms in the pair is a
plane, this becomes a plane-sphere test.</p></li>
<li><p>The two geoms cannot belong to the same body. Furthermore, they cannot belong to a parent and a child body, unless
the parent is the world body. The motivation is to avoid permanent contacts within bodies and joints. Note that if
several bodies are welded together in the sense that there are no joints between them, they are treated as a
single body for the purposes of this test. The parent-filter test can be disabled by the user, while the same-body
test cannot be disabled.</p></li>
<li><p>The two geoms must be “compatible” in the following sense. Each geom has integer parameters <code class="docutils literal notranslate"><span class="pre">contype</span></code> and
<code class="docutils literal notranslate"><span class="pre">conaffinity</span></code>. The boolean expression below must be true for the test to pass:
<code class="docutils literal notranslate"><span class="pre">(contype1</span> <span class="pre">&amp;</span> <span class="pre">conaffinity2)</span> <span class="pre">||</span> <span class="pre">(contype2</span> <span class="pre">&amp;</span> <span class="pre">conaffinity1)</span></code> This requires the <code class="docutils literal notranslate"><span class="pre">contype</span></code> of one geom and the
<code class="docutils literal notranslate"><span class="pre">conaffinity</span></code> of the other geom to have a common bit set to 1. This is a powerful mechanism borrowed from the
Open Dynamics Engine. The default setting for all geoms is <code class="docutils literal notranslate"><span class="pre">contype</span> <span class="pre">=</span> <span class="pre">conaffinity</span> <span class="pre">=</span> <span class="pre">1</span></code> which always passes the
test, so the user can ignore this mechanism if it is confusing at first.</p></li>
</ol>
</dd>
</dl>
</section>
<section id="checking">
<span id="cochecking"></span><h3>Checking<a class="headerlink" href="#checking" title="Permalink to this headline">#</a></h3>
<p>Detailed collision checking is performed by functions that depend on the geom types in the pair. MuJoCo supports several
primitive geometric shapes: plane, sphere, capsule, cylinder, ellipsoid, box. It also supports triangulated meshes and
height fields.</p>
<p>We have chosen to limit collision detection to <em>convex</em> geoms. All primitive types are convex. Height fields are not
convex but internally they are treated as unions of triangular prisms (using custom collision pruning beyond the filters
described above). Meshes specified by the user can be non-convex, and are rendered as such. For collision purposes
however they are replaced with their convex hulls. Mesh collisions are based on the Minkowski Portal Refinement (MPR)
algorithm as implemented in <a class="reference external" href="https://github.com/danfis/libccd">libccd</a>. It has tolerance and maximum iteration
parameters exposed as <code class="docutils literal notranslate"><span class="pre">mjModel.opt.mpt_tolerance</span></code> and <code class="docutils literal notranslate"><span class="pre">mjModel.opt.mpr_iterations</span></code> respectively. MPR operates on the
convex hull implicitly, however pre-computing that hull can substantially improve performance for large meshes. The
model compiler does that by default, using the <a class="reference external" href="http://www.qhull.org/">qhull</a> library.</p>
<p>In order to model a non-convex object other than a height field, the user must decompose it into a union of convex geoms
(which can be primitive shapes or meshes) and attach them to the same body. Tools such as the
<a class="reference external" href="https://github.com/kmammou/v-hacd">HACD</a> library can be used outside MuJoCo to automate this process. Finally, all
built-in collision functions can be replaced with custom callbacks. This can be used to incorporate a general-purpose
“triangle soup” collision detector for example. However we do not recommend such an approach. Pre-processing the
geometry and representing it as a union of convex geoms takes some work, but it pays off at runtime and yields both
faster and more stable simulation.</p>
</section>
</section>
<section id="simulation-pipeline">
<span id="pipeline"></span><h2>Simulation pipeline<a class="headerlink" href="#simulation-pipeline" title="Permalink to this headline">#</a></h2>
<p>Here we summarize the sequence of computations involved in forward and inverse dynamics respectively. Most of them were
already described. Keep in mind that the bit flags in <code class="docutils literal notranslate"><span class="pre">mjModel.opt.disableflags</span></code> and <code class="docutils literal notranslate"><span class="pre">mjModel.opt.enableflags</span></code> can
be used to skip default steps and to enable optional steps respectively. Callbacks are not shown here.</p>
<section id="forward-dynamics">
<span id="piforward"></span><h3>Forward dynamics<a class="headerlink" href="#forward-dynamics" title="Permalink to this headline">#</a></h3>
<p>The top-level function <a class="reference internal" href="APIreference/APIfunctions.html#mj-step"><span class="std std-ref">mj_step</span></a> invokes the sequence of computations below. Alternatively one can call
<a class="reference internal" href="APIreference/APIfunctions.html#mj-forward"><span class="std std-ref">mj_forward</span></a> which invokes only steps 2-21.</p>
<ol class="arabic simple">
<li><p>Check the positions and velocities for invalid or unacceptably large real values indicating divergence. If divergence
is detected, the state is automatically reset and the corresponding warning is raised.</p></li>
<li><p>Compute the forward kinematics. This yields the global positions and orientations of all bodies, geoms, sites,
cameras and lights. It also normalizes all quaternions, just in case.</p></li>
<li><p>Compute the body inertias and joint axes, in global frames centered at the centers of mass of the corresponding
kinematic subtrees (to improve floating-point accuracy).</p></li>
<li><p>Compute the actuator lengths and moment arms.</p></li>
<li><p>Compute the composite rigid body inertias and construct the joint-space inertia matrix.</p></li>
<li><p>Compute the sparse factorization of the joint-space inertia matrix.</p></li>
<li><p>Construct the list of active contacts. This includes both broad-phase and near-phase collision detection.</p></li>
<li><p>Construct the constraint Jacobian and compute the constraint residuals.</p></li>
<li><p>Compute the matrices and vectors needed by the constraint solvers.</p></li>
<li><p>Compute the tendon lengths and moment arms. This includes the computation of minimal-length paths for spatial
tendons.</p></li>
<li><p>Compute sensor data that only depends on position, and the potential energy if enabled.</p></li>
<li><p>Compute the tendon and actuator velocities.</p></li>
<li><p>Compute the body velocities and rates of change of the joint axes, again in the global coordinate frames centered at
the subtree centers of mass.</p></li>
<li><p>Compute all passive forces: spring-dampers in joints and tendons, and fluid dynamics forces.</p></li>
<li><p>Compute sensor data that depends on velocity, and the kinetic energy if enabled.</p></li>
<li><p>Compute the reference constraint acceleration.</p></li>
<li><p>Compute the vector of Coriolis, centrifugal and gravitational forces.</p></li>
<li><p>Compute the actuator forces and activation dynamics if defined.</p></li>
<li><p>Compute the joint acceleration resulting from all forces except for the (still unknown) constraint forces.</p></li>
<li><p>Compute the constraint forces with the selected solver, and update the joint acceleration so as to account for the
constraint forces. This yields the vector <code class="docutils literal notranslate"><span class="pre">mjData.qacc</span></code> which is the main output of forward dynamics.</p></li>
<li><p>Compute sensor data that depends on force and acceleration if enabled.</p></li>
<li><p>Check the acceleration for invalid or unacceptably large real values. If divergence is detected, the state is
automatically reset and the corresponding warning is raised.</p></li>
<li><p>Compare the results of forward and inverse dynamics, so as to diagnose poor solver convergence in the forward
dynamics. This is an optional step, and is performed only when enabled.</p></li>
<li><p>Advance the simulation state by one time step, using the selected integrator. Note that the Runge-Kutta integrator
repeats the above sequence three more times, except for the optional computations which are performed only once.</p></li>
</ol>
</section>
<section id="inverse-dynamics">
<span id="piinverse"></span><h3>Inverse dynamics<a class="headerlink" href="#inverse-dynamics" title="Permalink to this headline">#</a></h3>
<p>The top-level function <a class="reference internal" href="APIreference/APIfunctions.html#mj-inverse"><span class="std std-ref">mj_inverse</span></a> invokes the following sequence of computations.</p>
<ol class="arabic simple">
<li><p>Compute the forward kinematics.</p></li>
<li><p>Compute the body inertias and joint axes.</p></li>
<li><p>Compute the tendon lengths and moment arms.</p></li>
<li><p>Compute the actuator lengths and moment arms.</p></li>
<li><p>Compute the composite rigid body inertias and form the joint-space inertia matrix.</p></li>
<li><p>Compute the sparse factorization of the joint-space inertia matrix.</p></li>
<li><p>Construct the list of active contacts.</p></li>
<li><p>Construct the constraint Jacobian and compute the constraint residuals.</p></li>
<li><p>Compute sensor data that only depends on position, and the potential energy if enabled.</p></li>
<li><p>Compute the tendon and actuator velocities.</p></li>
<li><p>Compute the body velocities and joint axes rates of change.</p></li>
<li><p>Compute sensor data that depends on velocity, and the kinetic energy if enabled.</p></li>
<li><p>Compute all passive forces.</p></li>
<li><p>Compute the reference constraint acceleration.</p></li>
<li><p>If the <a class="reference internal" href="XMLreference.html#option-flag-invdiscrete"><span class="std std-ref">invdiscrete</span></a> flag is set and the <a class="reference internal" href="XMLreference.html#option-integrator"><span class="std std-ref">integrator</span></a> is not
<code class="docutils literal notranslate"><span class="pre">RK4</span></code>, convert input accelerations from discrete to continuous time.</p></li>
<li><p>Compute the constraint force. This is done analytically, without using a numerical solver.</p></li>
<li><p>Compute the inverse dynamics for the unconstrained system.</p></li>
<li><p>Compute sensor data that depends on force and acceleration if enabled.</p></li>
<li><p>Compute the vector <code class="docutils literal notranslate"><span class="pre">mjData.qfrc_inverse</span></code> by combining all results. This is the main output of inverse dynamics. It
equals the sum of external and actuation forces.</p></li>
</ol>
</section>
<section id="reproducibility">
<span id="pireproducibility"></span><h3>Reproducibility<a class="headerlink" href="#reproducibility" title="Permalink to this headline">#</a></h3>
<p>MuJoCo’s simulation pipeline is entirely deterministic and reproducible – if a <a class="reference internal" href="#gestate"><span class="std std-ref">state</span></a> in a trajectory is
saved and reloaded and <a class="reference internal" href="APIreference/APIfunctions.html#mj-step"><span class="std std-ref">mj_step</span></a> called again, the resulting next state will be identical. However, there are some
important caveats:</p>
<ul class="simple">
<li><p>Save all the required <a class="reference internal" href="#geintegrationstate"><span class="std std-ref">integration state</span></a> components. In particular <a class="reference internal" href="#gewarmstart"><span class="std std-ref">warmstart
accelerations</span></a> have only a very small effect on the next state, but should be saved if bit-wise equality
is required.</p></li>
<li><p>Any numerical difference between states, no matter how small, will become significant upon integration, especially for
systems with contact. Contact events have high <a class="reference external" href="https://en.wikipedia.org/wiki/Lyapunov_exponent">Lyapunov exponents</a>; this is a property of any rigid-body simulator (and indeed of
<a class="reference external" href="https://en.wikipedia.org/wiki/Roulette">real-world physics</a>) and is not MuJoCo-specific.</p></li>
<li><p>Exact reproducibillity is only guaranteed within a <strong>single version</strong>. Small numerical differences are quite common
between versioned releases, for example due to code optimizations. This means that when saving an initial state and an
open-loop control sequence, the resulting rolled-out trajectory will be identical within the same version but will
likely be different between MuJoCo versions.</p></li>
</ul>
</section>
</section>
<section id="derivatives">
<span id="id1"></span><h2>Derivatives<a class="headerlink" href="#derivatives" title="Permalink to this headline">#</a></h2>
<p>MuJoCo’s entire computational pipline including its constraint solver are analytically differentiable. Writing
efficient implementations of these derivatives is a long term goal of the development team. Analytic derivatives of the
smooth dynamics (excluding constraints) with respect to velocity are already computed and enable the two
<a class="reference internal" href="#geintegration"><span class="std std-ref">implicit integrators</span></a>.</p>
<p>Two functions are currently available which use efficient finite-differencing in order to compute dynamics Jacobians:</p>
<dl class="simple">
<dt><a class="reference internal" href="APIreference/APIfunctions.html#mjd-transitionfd"><span class="std std-ref">mjd_transitionFD</span></a>:</dt><dd><p>Computes state-transition and control-transition Jacobians for the discrete-time forward dynamics (<a class="reference internal" href="APIreference/APIfunctions.html#mj-step"><span class="std std-ref">mj_step</span></a>).
See <a class="reference internal" href="APIreference/APIfunctions.html#mjd-transitionfd"><span class="std std-ref">API documentation</span></a>.</p>
</dd>
<dt><a class="reference internal" href="APIreference/APIfunctions.html#mjd-inversefd"><span class="std std-ref">mjd_inverseFD</span></a>:</dt><dd><p>Computes Jacobians for the continuous-time inverse dynamics (<a class="reference internal" href="APIreference/APIfunctions.html#mj-inverse"><span class="std std-ref">mj_inverse</span></a>).
See <a class="reference internal" href="APIreference/APIfunctions.html#mjd-inversefd"><span class="std std-ref">API documentation</span></a>.</p>
</dd>
</dl>
<p>These derivatives are made efficient by exploiting MuJoCo’s configurable computation pipeline so that quantities are not
recomputed when not required. For example when differencing with respect to controls, quantities which depend only on
position and velocity are not recomputed. Additionally, solver warmstarts, quaternions and control clamping are handled
correctly. Both forward and centered differences are supported.</p>
</section>
<section id="references">
<span id="id2"></span><h2>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h2>
<p>Here we provide a brief annotated list of references and relate them to the main text.</p>
<p>Recursive algorithms for computing robot kinematics and dynamics have a long history. The book by Featherstone is a
standard reference. Our implementation of the RNE and CRB algorithms as well as sparse inertia factorization are based
on it.</p>
<blockquote>
<div><ol class="upperalpha simple" start="18">
<li><p>Featherstone. Rigid Body Dynamics Algorithms. Springer, 2008.</p></li>
</ol>
</div></blockquote>
<p>The MPR algorithm we use for convex mesh collisions was introduced by Snethen.</p>
<blockquote>
<div><ol class="upperalpha simple" start="7">
<li><p>Snethen. Complex collision made simple, Game Programming Gems 7, 165-178, 2008.</p></li>
</ol>
</div></blockquote>
<p>The linear complementarity (LCP) approach to contact modeling, which we discussed but did not actually use here, was
introduced by Stewart and Trinkle. Note that this is a well-developed area with many more recent papers on it.</p>
<blockquote>
<div><p>D. Stewart and J. Trinkle. An implicit time-stepping scheme for rigid-body dynamics with inelastic collisions and
coulomb friction. International Journal Numerical Methods Engineering, 39:2673-2691, 1996.</p>
</div></blockquote>
<p>We now address the prior work related to our constraint model and its roots in the Gauss principle. Udwadia and Kalaba
resurrected interest in the Gauss principle by pointing out the possibility of generalizing it.</p>
<blockquote>
<div><ol class="upperalpha simple" start="6">
<li><p>Udwadia and R. Kalaba. A new perspective on constrained motion. Proceedings of the Royal Society, 1992.</p></li>
</ol>
</div></blockquote>
<p>The first such generalization relevant to contact modeling was done by Redon et al, who extended the Gauss principle to
include inequality constraints on acceleration and used it to model frictionless contacts. This resulted in a convex
quadratic program (QP).</p>
<blockquote>
<div><p>S. Redon, A. Kheddar and S. Coquillart. Gauss’s least constraint principle and rigid body simulations. IEEE
International Conference on Robotics and Automation, 2002.</p>
</div></blockquote>
<p>In an effort to approximate the LCP problem with a more tractable one, Anitescu proposed a QP over accelerations which
is essentially the hard limit of the contact model we developed here. The difference from the earlier model by Redon et
al is that instead of using a single inequality per contact (in the normal direction only), Anitescu used multiple
inequalities forming a pyramid. This is all it takes to transition from frictionless to frictional contacts in convex
complementarity-free models.</p>
<blockquote>
<div><p>M. Anitescu. Optimization-based simulation of nonsmooth rigid multibody dynamics. Math. Program. Ser. A, 105:113-143,
2006.</p>
</div></blockquote>
<p>Drumwright and Shell proposed a QP over contact forces, which is the dual to the QP developed earlier by Anitescu, and
is again restricted to hard contacts.</p>
<blockquote>
<div><p>E. Drumwright and D. Shell, Modeling contact friction and joint friction in dynamic robotic simulation using the
principle of maximum dissipation. International Workshop on the Algorithmic Foundations of Robotics, 2010.</p>
</div></blockquote>
<p>The first version of our present model was developed in the paper below. This was again a convex optimization problem,
but it allowed soft contacts and other constraints and had a uniquely-defined inverse.</p>
<blockquote>
<div><p>E. Todorov. A convex, smooth and invertible contact model for trajectory optimization. IEEE International Conference
on Robotics and Automation, 2011.</p>
</div></blockquote>
<p>None of these convex models of frictional contact were derived from the Gauss principle systematically, as we did in the
present chapter. The augmented dynamics developed here is new. The continuous-time formulation is also new, and is a
departure from modern contact solvers which rely on “velocity-stepping” schemes in discrete time.</p>
<p>The way we obtained a soft constraint model is reminiscent of the constraint force mixing (CFM) parameter in the Open
Dynamics Engine (ODE), even though ODE is based on the LCP formalism and solves a different problem.</p>
<blockquote>
<div><ol class="upperalpha simple" start="18">
<li><p>Smith. Open Dynamics Engine user guide. 2006.</p></li>
</ol>
</div></blockquote>
<p>Lacoursiere introduced “ghost variables” which appear related to our deformation dynamics. However they are somewhat
difficult to interpret (as their name suggests) and the exact relation to our model remains to be clarified.</p>
<blockquote>
<div><p>C. Lacoursiere. Ghosts and machines: Regularized variational methods for interactive simulations of multibodies with
dry frictional contacts. PhD Thesis, Umea University, 2007.</p>
</div></blockquote>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="modeling.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Modeling</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="overview.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Overview</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; DeepMind Technologies Limited
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Computation</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#motivation-for-soft-contact-model">Motivation for soft contact model</a><ul>
<li><a class="reference internal" href="#physical-realism-and-soft-contacts">Physical realism and soft contacts</a></li>
<li><a class="reference internal" href="#computational-efficiency">Computational efficiency</a></li>
<li><a class="reference internal" href="#continuous-time">Continuous time</a></li>
<li><a class="reference internal" href="#inverse-dynamics-and-optimization">Inverse dynamics and optimization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#general-framework">General framework</a><ul>
<li><a class="reference internal" href="#actuation-model">Actuation model</a><ul>
<li><a class="reference internal" href="#transmission">Transmission</a></li>
<li><a class="reference internal" href="#activation-dynamics">Activation dynamics</a></li>
<li><a class="reference internal" href="#force-generation">Force generation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#passive-forces">Passive forces</a></li>
<li><a class="reference internal" href="#numerical-integration">Numerical integration</a></li>
<li><a class="reference internal" href="#the-state">The State</a><ul>
<li><a class="reference internal" href="#physics-state">Physics state</a></li>
<li><a class="reference internal" href="#full-physics-state">Full physics state</a></li>
<li><a class="reference internal" href="#user-inputs">User inputs</a></li>
<li><a class="reference internal" href="#warmstart-acceleration">Warmstart acceleration</a></li>
<li><a class="reference internal" href="#integration-state">Integration state</a></li>
<li><a class="reference internal" href="#simulation-state-mjdata">Simulation state: <code class="docutils literal notranslate"><span class="pre">mjData</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#constraint-model">Constraint model</a><ul>
<li><a class="reference internal" href="#equality">Equality</a></li>
<li><a class="reference internal" href="#friction-loss">Friction loss</a></li>
<li><a class="reference internal" href="#limit">Limit</a></li>
<li><a class="reference internal" href="#contact">Contact</a></li>
</ul>
</li>
<li><a class="reference internal" href="#constraint-solver">Constraint solver</a><ul>
<li><a class="reference internal" href="#primal-problem">Primal problem</a></li>
<li><a class="reference internal" href="#reduced-primal-problem">Reduced primal problem</a></li>
<li><a class="reference internal" href="#dual-problem">Dual problem</a></li>
<li><a class="reference internal" href="#algorithms">Algorithms</a></li>
<li><a class="reference internal" href="#parameters">Parameters</a></li>
<li><a class="reference internal" href="#friction-cones">Friction cones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#collision-detection">Collision detection</a><ul>
<li><a class="reference internal" href="#selection">Selection</a></li>
<li><a class="reference internal" href="#checking">Checking</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simulation-pipeline">Simulation pipeline</a><ul>
<li><a class="reference internal" href="#forward-dynamics">Forward dynamics</a></li>
<li><a class="reference internal" href="#inverse-dynamics">Inverse dynamics</a></li>
<li><a class="reference internal" href="#reproducibility">Reproducibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#derivatives">Derivatives</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/furo.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/katex.min.js"></script>
    <script src="_static/auto-render.min.js"></script>
    <script src="_static/katex_autorenderer.js"></script>
    </body>
</html>