<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
    <link sizes="16x16" href="_static/favicons/favicon-16x16.png" rel="icon" type="image/png">
    <link sizes="32x32" href="_static/favicons/favicon-32x32.png" rel="icon" type="image/png">
    <link rel="apple-touch-icon" sizes="180x180" href="_static/favicons/favicon-180x180.png" type="image/png">
    <link sizes="180x180" href="_static/favicons/favicon-180x180.png" rel="icon" type="image/png">
    <link sizes="192x192" href="_static/favicons/favicon-192x192.png" rel="icon" type="image/png"><link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="XML Reference" href="XMLreference.html" /><link rel="prev" title="Computation" href="computation.html" />

    <meta name="generator" content="sphinx-4.5.0, furo 2022.09.29"/>
        <title>Modeling - MuJoCo Documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="_static/katex-math.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="_static/theme_overrides.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --font-stack--monospace: Inconsolata,Consolas,ui-monospace,monospace;
  --at-color: #bc103e;
  --at-val-color: #bc103e;
  --body-color: #14234b;
  --color-highlight-on-target: #e5e8ed;
  --primary-header-color: #0053d6;
  --row-odd-background-color: #f0f3f7;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #123693;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --at-color: #ff95a6;
  --at-val-color: #ff95a6;
  --body-color: #14234b;
  --color-admonition-background: #1e1e21;
  --color-highlight-on-target: #3d4045;
  --primary-header-color: #a8caff;
  --row-odd-background-color: #222326;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #458dff;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --at-color: #ff95a6;
  --at-val-color: #ff95a6;
  --body-color: #14234b;
  --color-admonition-background: #1e1e21;
  --color-highlight-on-target: #3d4045;
  --primary-header-color: #a8caff;
  --row-odd-background-color: #222326;
  --rst-content-a-color: #2980b9;
  --secondary-header-color: #458dff;
  --wy-menu-vertical-background-color: #0053d6;
  --wy-menu-vertical-color: white;
  --wy-nav-side-background-color: #0053d6;
  --admonition-font-size: 1rem;
  --admonition-title-font-size: 1rem;
  --sidebar-item-font-size: 115%;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">MuJoCo Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="_static/banner.svg" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">MuJoCo Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="computation.html">Computation</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="XMLreference.html">XML Reference</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="programming/index.html">Programming</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="programming/simulation.html">Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming/visualization.html">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming/samples.html">Code samples</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming/extension.html">Extensions</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="APIreference/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="APIreference/APItypes.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="APIreference/APIfunctions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="APIreference/APIglobals.html">Globals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="python.html">Python Bindings</a></li>
<li class="toctree-l1"><a class="reference internal" href="unity.html">Unity Plug-in</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">Model Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="modeling">
<h1>Modeling<a class="headerlink" href="#modeling" title="Permalink to this headline">#</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h2>
<p>MuJoCo can load XML model files in its native <strong>MJCF</strong> format, as well as in the popular but more limited <strong>URDF</strong>
format. This chapter is the MJCF modeling guide. The reference manual is available in the <a class="reference internal" href="XMLreference.html"><span class="doc">XML Reference</span></a>
chapter. The URDF documentation can be found elsewhere; here we only describe
MuJoCo-specific <a class="reference internal" href="#curdf"><span class="std std-ref">URDF extensions</span></a>.</p>
<p>MJCF models can represent complex dynamical systems with a wide range of features and model elements. Accessing all
these features requires a rich modeling format, which can become cumbersome if it is not designed with usability in
mind. Therefore we have made an effort to design MJCF as a scalable format, allowing users to start small and build
more detailed models later. Particularly helpful in this regard is the extensive <a class="reference internal" href="#cdefault"><span class="std std-ref">default setting</span></a>
mechanism inspired by the idea of Cascading Style Sheets (CSS) inlined in HTML. It enables users to rapidly create
new models and experiment with them. Experimentation is further aided by numerous <a class="reference internal" href="XMLreference.html#option"><span class="std std-ref">options</span></a> which
can be used to reconfigure the simulation pipeline, and by quick re-loading that makes model editing an interactive
process.</p>
<p>One can think of MJCF as a hybrid between a modeling format and a programming language. There is a built-in compiler,
which is a concept normally associated with programming languages. While MJCF does not have the power of a
general-purpose programming language, a number of sophisticated compile-time computations are invoked automatically
depending on how the model is designed.</p>
<section id="loading-models">
<span id="load"></span><h3>Loading models<a class="headerlink" href="#loading-models" title="Permalink to this headline">#</a></h3>
<p>As explained in <a class="reference internal" href="overview.html#instance"><span class="std std-ref">Model instances</span></a> in the Overview chapter, MuJoCo models can be loaded from plain-text
XML files in the MJCF or URDF formats, and then compiled into a low-level mjModel. Alternatively a previously saved
mjModel can be loaded directly from a binary MJB file - whose format is not documented but is essentially a copy of the
mjModel memory buffer. MJCF and URDF files are loaded with <a class="reference internal" href="APIreference/APIfunctions.html#mj-loadxml"><span class="std std-ref">mj_loadXML</span></a> while MJB files are loaded with
<a class="reference internal" href="APIreference/APIfunctions.html#mj-loadmodel"><span class="std std-ref">mj_loadModel</span></a>.</p>
<p>When an XML file is loaded, it is first parsed into a document object model (DOM) using the TinyXML parser internally.
This DOM is then processed and converted into a high-level mjCModel object. The conversion depends on the model format
- which is inferred from the top-level element in the XML file, and not from the file extension. Recall that a valid
XML file has a unique top-level element. This element must be <span class="el">mujoco</span> for MJCF, and <span class="el">robot</span> for URDF.</p>
</section>
<section id="compiling-models">
<span id="compile"></span><h3>Compiling models<a class="headerlink" href="#compiling-models" title="Permalink to this headline">#</a></h3>
<p>Once a high-level mjCModel is created - by loading an MJCF file or a URDF file, or programmatically when such
functionality becomes available - it is compiled into mjModel. Even though loading and compilation are presently
combined in one step, compilation is independent of loading, meaning that the compiler works in the same way
regardless of how mjCModel was created. Both the parser and the compiler perform extensive error checking, and abort
when the first error is encountered. The resulting error messages contain the row and column number in the XML file,
and are self-explanatory so we do not document them here. The parser uses a custom schema to make sure that the file
structure, elements and attributes are valid. The compiler then applies many additional semantic checks. Finally, one
simulation step of the compiled model is performed and any runtime errors are intercepted. The latter is done by
(temporarily) setting <a class="reference internal" href="APIreference/APIglobals.html#mju-user-error"><span class="std std-ref">mju_user_error</span></a> to point to a function that throws C++
exceptions; the user can implement similar error-interception functionality at runtime if desired.</p>
<p>The entire process of parsing and compilation is very fast - less than a second if the model does not contain large
meshes or actuator lengthranges that need to be computed via simulation. This makes it possible to design models
interactively, by re-loading often and visualizing the changes. Note that the <a class="reference internal" href="programming/samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a> code
sample has a keyboard shortcut for re-loading the current model (Ctrl+L).</p>
</section>
<section id="saving-models">
<span id="save"></span><h3>Saving models<a class="headerlink" href="#saving-models" title="Permalink to this headline">#</a></h3>
<p>An MJCF model can consist of multiple (included) XML files as well as meshes, height fields and textures referenced
from the XML. After compilation, the contents of all these files are assembled into mjModel, which can be saved into a
binary MJB file with <a class="reference internal" href="APIreference/APIfunctions.html#mj-savemodel"><span class="std std-ref">mj_saveModel</span></a>. The MJB is a stand-alone file and does not
refer to any other files. It also loads faster. So we recommend saving commonly used models as MJB and loading them
when needed for simulation.</p>
<p>It is also possible to save a compiled mjCModel as MJCF with <a class="reference internal" href="APIreference/APIfunctions.html#mj-savelastxml"><span class="std std-ref">mj_saveLastXML</span></a>. If any real-valued fields in the
corresponding mjModel were modified after compilation (which is unusual but can happen in system identification
applications for example), the modifications are automatically copied back into mjCModel before saving. Note that
structural changes cannot be made in the compiled model. The XML writer attempts to generate the smallest MJCF file
which is guaranteed to compile into the same model, modulo negligible numeric differences caused by the plain text
representation of real values. The resulting file may not have the same structure as the original because MJCF has many
user convenience features, allowing the same model to be specified in different ways. The XML writer uses a “canonical”
subset of MJCF where all coordinates are local and all body positions, orientations and inertial properties are
explicitly specified. In the Computation chapter we showed an <a class="reference external" href="_static/example.xml">example</a> MJCF file and the
corresponding <a class="reference external" href="_static/example_saved.xml">saved example</a>.</p>
</section>
</section>
<section id="mjcf-mechanisms">
<span id="mechanisms"></span><h2>MJCF Mechanisms<a class="headerlink" href="#mjcf-mechanisms" title="Permalink to this headline">#</a></h2>
<p>MJCF uses several mechanisms for model creation which span multiple model elements. To avoid repetition we describe them
in detail only once in this section. These mechanisms do not correspond to new simulation concepts beyond those
introduced in the Computation chapter. Their role is to simplify the creation of MJCF models, and to enable the use of
different data formats without need for manual conversion to a canonical format.</p>
<section id="kinematic-tree">
<span id="ctree"></span><h3>Kinematic tree<a class="headerlink" href="#kinematic-tree" title="Permalink to this headline">#</a></h3>
<p>The main part of the MJCF file is an XML tree created by nested <a class="reference internal" href="XMLreference.html#body"><span class="std std-ref">body</span></a> elements. The top-level body is
special and is called <span class="el">worldbody</span>. This tree organization is in contrast with URDF where one creates a collection of
links and then connects them with joints that specify a child and a parent link. In MJCF the child body is literally a
child of the parent body, in the sense of XML.</p>
<p>When a <a class="reference internal" href="XMLreference.html#body-joint"><span class="std std-ref">joint</span></a> is defined inside a body, its function is not to connect the parent and child but
rather to create motion degrees of freedom between them. If no joints are defined within a given body, that body is
welded to its parent. A body in MJCF can contain multiple joints, thus there is no need to introduce dummy bodies for
creating composite joints. Instead simply define all the primitive joints that form the desired composite joint within
the same body. For example, two sliders and one hinge can be used to model a body moving in a plane.</p>
<p>Other MJCF elements can be defined within the tree created by nested body elements, in particular
<a class="reference internal" href="XMLreference.html#body-joint"><span class="std std-ref">joint</span></a>, <a class="reference internal" href="XMLreference.html#body-geom"><span class="std std-ref">geom</span></a>, <a class="reference internal" href="XMLreference.html#body-site"><span class="std std-ref">site</span></a>, <a class="reference internal" href="XMLreference.html#body-camera"><span class="std std-ref">camera</span></a>, <a class="reference internal" href="XMLreference.html#body-light"><span class="std std-ref">light</span></a>. When an element is defined within a body, it is fixed to the local frame of that body and always moves
with it. Elements that refer to multiple bodies, or do not refer to bodies at all, are defined in separate sections
outside the kinematic tree.</p>
</section>
<section id="default-settings">
<span id="cdefault"></span><h3>Default settings<a class="headerlink" href="#default-settings" title="Permalink to this headline">#</a></h3>
<p>MJCF has an elaborate mechanism for setting default attribute values. This allows us to have a large number of elements
and attributes needed to expose the rich functionality of the software, and at the same time write short and readable
model files. This mechanism further enables the user to introduce a change in one place and have it propagate throughout
the model. We start with an example.</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;mujoco&gt;</span>
<span class="w">    </span><span class="nt">&lt;default</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;main&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;1 0 0 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;default</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;sub&quot;</span><span class="nt">&gt;</span>
<span class="w">            </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;0 1 0 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/default&gt;</span>
<span class="w">    </span><span class="nt">&lt;/default&gt;</span>

<span class="w">    </span><span class="nt">&lt;worldbody&gt;</span>
<span class="w">        </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;box&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;body</span><span class="w"> </span><span class="na">childclass=</span><span class="s">&quot;sub&quot;</span><span class="nt">&gt;</span>
<span class="w">            </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;ellipsoid&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;sphere&quot;</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;0 0 1 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;cylinder&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;main&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/body&gt;</span>
<span class="w">    </span><span class="nt">&lt;/worldbody&gt;</span>
<span class="nt">&lt;/mujoco&gt;</span>
</pre></div>
</div>
<p>This example will not actually compile because some required information is missing, but here we are only interested
in the setting of geom rgba values. The four geoms created above will end up with the following rgba values as a
result of the default setting mechanism:</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>geom type</p></th>
<th class="head"><p>geom rgba</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>box</p></td>
<td><p>1 0 0 1</p></td>
</tr>
<tr class="row-odd"><td><p>ellipsoid</p></td>
<td><p>0 1 0 1</p></td>
</tr>
<tr class="row-even"><td><p>sphere</p></td>
<td><p>0 0 1 1</p></td>
</tr>
<tr class="row-odd"><td><p>cylinder</p></td>
<td><p>1 0 0 1</p></td>
</tr>
</tbody>
</table>
</div>
<p>The box uses the top-level defaults class “main” to set the values of its undefined attributes, because no other class
was specified. The body specifies childclass “sub”, causing all children of this body (and all their children etc.) to
use class “sub” unless specified otherwise. So the ellipsoid uses class “sub”. The sphere has explicitly defined rgba
which overrides the default settings. The cylinder specifies defaults class “main”, and so it uses “main” instead of
“sub”, even though the latter was specified in the childclass attribute of the body containing the geom.</p>
<p>Now we describe the general rules. MuJoCo supports unlimited number of defaults classes, created by possibly nested
<a class="reference internal" href="XMLreference.html#default"><span class="std std-ref">default</span></a> elements in the XML. Each class has a unique name - which is a required
attribute except for the top-level class whose name is “main” if left undefined. Each class also has a complete
collection of dummy model elements, with their attributes set as follows. When a defaults class is defined within
another defaults class, the child automatically inherits all attribute values from the parent. It can then override
some or all of them by defining the corresponding attributes. The top-level defaults class does not have a parent, and
so its attributes are initialized to internal defaults which are shown in the <a class="reference internal" href="XMLreference.html"><span class="doc">Reference chapter</span></a>.</p>
<p>The dummy elements contained in the defaults classes are not part of the model; they are only used to initialize the
attribute values of the actual model elements. When an actual element is first created, all its attributes are copied
from the corresponding dummy element in the defaults class that is currently active. There is always an active
defaults class, which can be determined in one of three ways. If no class is specified in the present element or any
of its ancestor bodies, the top-level class is used (regardless of whether it is called “main” or something else). If
no class is specified in the present element but one or more of its ancestor bodies specify a childclass, then the
childclass from the nearest ancestor body is used. If the present element specifies a class, that class is used
regardless of any childclass attributes in its ancestor bodies.</p>
<p>Some attributes, such as body inertia, can be in a special undefined state. This instructs the compiler to infer the
corresponding value from other information, in this case the inertias of the geoms attached to the body. The undefined
state cannot be entered in the XML file. Therefore once an attribute is defined in a given class, it cannot be undefined
in that class or in any of its child classes. So if the goal is to leave a certain attribute undefined in a given model
element, it must be undefined in the active defaults class.</p>
<p>A final twist here is actuators. They are different because some of the actuator-related elements are actually
shortcuts, and shortcuts interact with the defaults setting mechanism in a non-obvious way. This is explained in the
<a class="reference internal" href="#cactuator"><span class="std std-ref">Actuator shortcuts</span></a> section below.</p>
</section>
<section id="coordinate-frames">
<span id="cframe"></span><h3>Coordinate frames<a class="headerlink" href="#coordinate-frames" title="Permalink to this headline">#</a></h3>
<p>The positions and orientations of all elements defined in the kinematic tree are expressed in local coordinates,
relative to the parent body for bodies, and relative to the body that owns the element for geoms, joints, sites, cameras
and lights.</p>
<p>A related attribute is <a class="reference internal" href="XMLreference.html#compiler-angle"><span class="std std-ref">compiler/angle</span></a>. It specifies whether angles in the MJCF file are expressed
in degrees or radians (after compilation, angles are always expressed in radians).</p>
</section>
<section id="frame-orientations">
<span id="corientation"></span><h3>Frame orientations<a class="headerlink" href="#frame-orientations" title="Permalink to this headline">#</a></h3>
<p>Several model elements have right-handed spatial frames associated with them. These are all the elements defined in the
kinematic tree except for joints. A spatial frame is defined by its position and orientation. Specifying 3D positions is
straightforward, but specifying 3D orientations can be challenging. This is why MJCF provides several alternative
mechanisms. No matter which mechanism the user chooses, the frame orientation is always represented as a unit quaternion
after compilation. Recall that a 3D rotation by angle <span class="math">\(a\)</span> around axis given by the unit vector <span class="math">\((x, y, z)\)</span>
corresponds to the quaternion <span class="math">\((\cos(a/2), \: \sin(a/2) \cdot (x, y, z))\)</span>. Also recall that every 3D orientation
can be uniquely specified by a single 3D rotation by some angle around some axis.</p>
<p>All MJCF elements that have spatial frames allow the five attributes listed below. The frame orientation is specified
using at most one of these attributes. The <span class="at">quat</span> attribute has a default value corresponding to the null
rotation, while the others are initialized in the special undefined state. Thus if none of these attributes are
specified by the user, the frame is not rotated.</p>
<dl class="simple">
<dt><span class="at">quat</span>: <span class="at-val">real(4), “1 0 0 0”</span></dt><dd><p>If the quaternion is known, this is the preferred was to specify the frame orientation because it does not involve
conversions. Instead it is normalized to unit length and copied into mjModel during compilation. When a model is
saved as MJCF, all frame orientations are expressed as quaternions using this attribute.</p>
</dd>
<dt><span class="at">axisangle</span>: <span class="at-val">real(4), optional</span></dt><dd><p>These are the quantities <span class="math">\((x, y, z, a)\)</span> mentioned above. The last number is the angle of rotation, in degrees
or radians as specified by the <span class="at">angle</span> attribute of <a class="reference internal" href="XMLreference.html#compiler"><span class="std std-ref">compiler</span></a>. The first three numbers determine
a 3D vector which is the rotation axis. This vector is normalized to unit length during compilation, so the user can
specify a vector of any non-zero length. Keep in mind that the rotation is right-handed; if the direction of the
vector <span class="math">\((x, y, z)\)</span> is reversed this will result in the opposite rotation. Changing the sign of <span class="math">\(a\)</span> can
also be used to specify the opposite rotation.</p>
</dd>
<dt><span class="at">euler</span>: <span class="at-val">real(3), optional</span></dt><dd><p>Rotation angles around three coordinate axes. The sequence of axes around which these rotations are applied is
determined by the <span class="at">eulerseq</span> attribute of <a class="reference internal" href="XMLreference.html#compiler"><span class="std std-ref">compiler</span></a> and is the same for the
entire model.</p>
</dd>
<dt><span class="at">xyaxes</span>: <span class="at-val">real(6), optional</span></dt><dd><p>The first 3 numbers are the X axis of the frame. The next 3 numbers are the Y axis of the frame, which is
automatically made orthogonal to the X axis. The Z axis is then defined as the cross-product of the X and Y axes.</p>
</dd>
<dt><span class="at">zaxis</span>: <span class="at-val">real(3), optional</span></dt><dd><p>The Z axis of the frame. The compiler finds the minimal rotation that maps the vector <span class="math">\((0, 0, 1)\)</span> into the
vector specified here. This determines the X and Y axes of the frame implicitly. This is useful for geoms with
rotational symmetry around the Z axis, as well as lights - which are oriented along the Z axis of their frame.</p>
</dd>
</dl>
</section>
<section id="solver-parameters">
<span id="csolver"></span><h3>Solver parameters<a class="headerlink" href="#solver-parameters" title="Permalink to this headline">#</a></h3>
<p>The solver <a class="reference internal" href="computation.html#soparameters"><span class="std std-ref">Parameters</span></a> section of the Computation chapter explained the mathematical and
algorithmic meaning of the quantities <span class="math">\(d, b, k\)</span> which determine the behavior of the constraints in MuJoCo. Here we
explain how to set them. Setting is done indirectly, through the attributes <span class="at">solref</span> and <span class="at">solimp</span> which are
available in all MJCF elements involving constraints. These parameters can be adjusted per constraint, or per defaults
class, or left undefined – in which case MuJoCo uses the internal defaults shown below. Note also the override mechanism
available in <a class="reference internal" href="XMLreference.html#option"><span class="std std-ref">option</span></a>; it can be used to change all contact-related solver parameters at runtime, so as to
experiment interactively with parameter settings or implement continuation methods for numerical optimization.</p>
<p>Here we focus on a single scalar constraint. Using slightly different notation from the Computation chapter, let
<span class="math">\(a_1\)</span> denote the acceleration, <span class="math">\(v\)</span> the velocity, <span class="math">\(r\)</span> the position or residual (defined as 0 in
friction dimensions), <span class="math">\(k\)</span> and <span class="math">\(b\)</span> the stiffness and damping of the virtual spring used to define the
reference acceleration <span class="math">\(a_{\rm ref} = -b v - k r\)</span>. Let <span class="math">\(d\)</span> be the constraint impedance, and <span class="math">\(a_0\)</span> the
acceleration in the absence of constraint force. Our earlier analysis revealed that the dynamics in constraint space are
approximately</p>
<div class="math-wrapper docutils container">
<div class="math">
\[a_1 + d \cdot (b v + k r) = (1 - d)\cdot a_0

\]</div>
</div>
<p>Again, the parameters that are under the user’s control are <span class="math">\(d, b, k\)</span>. The remaining quantities are functions of
the system state and are computed automatically at each time step.</p>
<section id="impedance">
<span id="csolverimpedance"></span><h4>Impedance<a class="headerlink" href="#impedance" title="Permalink to this headline">#</a></h4>
<p>We begin by explaining the constraint impedance <span class="math">\(d\)</span>.</p>
<div class="admonition-intuitive-description admonition">
<p class="admonition-title">Intuitive description</p>
<p>The <em>impedance</em> <span class="math">\(d \in (0, 1)\)</span> determines a constraint’s <strong>ability to generate force</strong>.
Small values of <span class="math">\(d\)</span> correspond to weak constraints while large values of <span class="math">\(d\)</span>
correspond to strong constraints. Impedance is set using the <span class="at">solimp</span> attribute.</p>
</div>
<p>Recall that <span class="math">\(d\)</span> must lie between 0 and 1; internally MuJoCo clamps it to the range [<a class="reference internal" href="APIreference/APIglobals.html#glnumeric"><span class="std std-ref">mjMINIMP mjMAXIMP</span></a>] which is currently set to [0.0001 0.9999]. It causes the solver to interpolate between the unforced
acceleration <span class="math">\(a_0\)</span> and reference acceleration <span class="math">\(a_{\rm ref}\)</span>. The user can set <span class="math">\(d\)</span> to a constant, or
take advantage of its interpolating property and make it position-dependent, i.e., a function of the constraint
violation <span class="math">\(r\)</span>. Position-dependent impedance can be used to model soft contact layers around objects, or define
equality constraints that become stronger with larger violation (so as to approximate backlash, for example). The shape
of the function <span class="math">\(d(r)\)</span> is determined by the element-specific parameter vector <span class="at">solimp</span>.</p>
<dl>
<dt><strong>solimp :</strong> real(5), “0.9 0.95 0.001 0.5 2”</dt><dd><p>The five numbers (<span class="math">\(d_0\)</span>, <span class="math">\(d_\text{width}\)</span>, <span class="math">\(\text{width}\)</span>, <span class="math">\(\text{midpoint}\)</span>,
<span class="math">\(\text{power}\)</span>) parameterize <span class="math">\(d(r)\)</span> – the impedance <span class="math">\(d\)</span> as a function of the constraint
violation <span class="math">\(r\)</span>.</p>
<p>The first 3 values indicate that the impedance will vary smoothly as <span class="math">\(r\)</span> varies from
<span class="math">\(0\)</span> to <span class="math">\(\text{width}\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[d(0) = d_0, \quad d(\text{width}) = d_\text{width}

\]</div>
</div>
<p>The 4th and 5th values, <span class="math">\(\text{midpoint}\)</span> and <span class="math">\(\text{power}\)</span>, control the shape of the sigmoidal
function that interpolates between <span class="math">\(d_0\)</span> and <span class="math">\(d_\text{width}\)</span>, as shown in the plots below.
The plots show two reflected sigmoids, because the impedance <span class="math">\(d(r)\)</span> depends on the absolute
value of <span class="math">\(r\)</span>. The <span class="math">\(\text{power}\)</span> (of the polynomial spline used to generate the function) must be 1 or
greater. The <span class="math">\(\text{midpoint}\)</span> (specifying the inflection point) must be between 0 and 1, and is expressed in
units of <span class="math">\(\text{width}\)</span>. Note that when <span class="math">\(\text{power}\)</span> is 1, the function is linear regardless of the
<span class="math">\(\text{midpoint}\)</span>.</p>
<p><a class="reference internal" href="_images/impedance.png"><img alt="image0" src="_images/impedance.png" style="width: 600px;" /></a></p>
<p>These plots show the impedance <span class="math">\(d(r)\)</span> on the vertical axis, as a function of the constraint violation <span class="math">\(r\)</span>
on the horizontal axis.</p>
<p>For equality constraints, <span class="math">\(r\)</span> is the constraint violation. For limits, normal directions of elliptic cones and
all directions of pyramidal cones, <span class="math">\(r\)</span> is the (limit or contact) distance minus the margin at which the
constraint becomes active; for contacts this margin is <a class="reference internal" href="XMLreference.html#body-geom-margin"><span class="std std-ref">margin</span></a>-<a class="reference internal" href="XMLreference.html#body-geom-gap"><span class="std std-ref">gap</span></a>.
Limit and contact constraints are active when <span class="math">\(r &lt; 0\)</span> (penetration).</p>
<p>For friction loss or friction dimensions of elliptic cones, the violation <span class="math">\(r\)</span> is identically zero, so
only <span class="math">\(d(0)\)</span> affects these constraints, all other <span class="at">solimp</span> values are ignored.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>For completely smooth dynamics, limits and contacts should have <span class="math">\(d_0=0\)</span>.</p>
</div>
</dd>
</dl>
</section>
<section id="reference">
<span id="csolverreference"></span><h4>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">#</a></h4>
<p>Next we explain the setting of the stiffness <span class="math">\(k\)</span> and damping <span class="math">\(b\)</span> which control the reference acceleration
<span class="math">\(a_{\rm ref}\)</span>.</p>
<div class="admonition-intuitive-description admonition">
<p class="admonition-title">Intuitive description</p>
<p>The <em>reference acceleration</em> <span class="math">\(a_{\rm ref}\)</span> determines <strong>what the constraint is trying to achieve</strong> (as opposed
to how well it can achieve it). This acceleration is defined by two numbers, a stiffness <span class="math">\(k\)</span> and damping
<span class="math">\(b\)</span> which can be set directly or re-parameterized as the time-constant and damping ratio of a
mass-spring-damper system (a <a class="reference external" href="https://en.wikipedia.org/wiki/Harmonic_oscillator">harmonic oscillator</a>).
The reference acceleration is controlled by the <span class="at">solref</span> attribute.</p>
</div>
<p>There are two formats for this attribute, determined by the sign of the numbers. If both numbers are positive the
specification is considered to be in the <span class="math">\((\text{timeconst}, \text{dampratio})\)</span> format. If negative it is in the
“direct” <span class="math">\((-\text{stiffness}, -\text{damping})\)</span> format.</p>
<p>Frictional constraints whose residual is identically 0 have first-order dynamics and the mass-spring-damper analysis
below does not apply. In this case the time constant is the rate of exponential decay of the constraint velocity,
and the damping ratio is ignored. Equivalently, in the direct format, the <span class="math">\(\text{stiffness}\)</span> is ignored.</p>
<dl>
<dt><strong>solref :</strong> real(2), “0.02 1”</dt><dd><p>We first describe the default, positive-value format where the two numbers are
<span class="math">\((\text{timeconst}, \text{dampratio})\)</span>.</p>
<p>The idea here is to re-parameterize the model in terms of the time constant and damping ratio of a mass-spring-damper
system. By “time constant” we mean the inverse of the natural frequency times the damping ratio. In this case we use
a mass-spring-damper model to compute <span class="math">\(k, b\)</span> after suitable scaling. Note that the effective stiffness
<span class="math">\(d(r) \cdot k\)</span> and damping <span class="math">\(d(r) \cdot b\)</span> are scaled by the impedance <span class="math">\(d(r)\)</span> which is a function of
the distance <span class="math">\(r\)</span>. Thus we cannot always achieve the specified mass-spring-damper properties, unless we
completely undo the scaling by <span class="math">\(d\)</span>. But the latter is undesirable because it would ruin the interpolating
property, in particular the limit <span class="math">\(d=0\)</span> would no longer disable the constraint. Instead we scale the stiffness
and damping so that the damping ratio remains constant, while the time constant increases when <span class="math">\(d(r)\)</span> gets
smaller. The scaling formulas are</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
b &= 2 / (d_\text{width}\cdot \text{timeconst}) \\
k &= d(r) / (d_\text{width}^2 \cdot \text{timeconst}^2 \cdot \text{dampratio}^2) \\
\end{aligned}

\]</div>
</div>
<p>The timeconst parameter should be at least two times larger than the simulation time step, otherwise the system can
become too stiff relative to the numerical integrator (especially when Euler integration is used) and the simulation
can go unstable. This is enforced internally, unless the <a class="reference internal" href="XMLreference.html#option-flag-refsafe"><span class="std std-ref">refsafe</span></a> attribute of <a class="reference internal" href="XMLreference.html#option-flag"><span class="std std-ref">flag</span></a> is set to false. The <span class="math">\(\text{dampratio}\)</span> parameter would normally be set to 1, corresponding to
critical damping. Smaller values result in under-damped or bouncy constraints, while larger values result in
over-damped constraints.</p>
<p>Next we describe the direct format where the two numbers are <span class="math">\((-\text{stiffness}, -\text{damping})\)</span>. This
allows direct control over restitution in particular. We still apply some scaling so that the same numbers can be
used with different impedances, but the scaling no longer depends on <span class="math">\(r\)</span> and the two numbers no longer
interact. The scaling formulas are</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
b &= \text{damping} / d_\text{width} \\
k &= \text{stiffness} / d_\text{width}^2 \\
\end{aligned}

\]</div>
</div>
</dd>
</dl>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>In the positive-value default format, the <span class="math">\(\text{timeconst}\)</span> parameter controls constraint <strong>softness</strong>.
It is specified in units of time and means “how quickly is the constraint trying to resolve the violation”. Larger
values correspond to softer constraints.</p>
<p>The negative-value “direct” format is more flexible, for example allowing for perfectly elastic collisions
(<span class="math">\(\text{damping} = 0\)</span>). It is the recommended format for system identification.</p>
</div>
</section>
</section>
<section id="contact-parameters">
<span id="ccontact"></span><h3>Contact parameters<a class="headerlink" href="#contact-parameters" title="Permalink to this headline">#</a></h3>
<p>The parameters of each contact were described in the <a class="reference internal" href="computation.html#cocontact"><span class="std std-ref">Contact</span></a> section of the Computation
chapter. Here we explain how these parameters are set. If the geom pair is explicitly defined with the XML element
<a class="reference internal" href="XMLreference.html#contact-pair"><span class="std std-ref">pair</span></a>, it has attributes specifying all contact parameters directly. In that case the
parameters of the individual geoms are ignored. If on the other hand the contact is generated by the dynamic mechanism,
its parameters need to be inferred from the two geoms in the contact pair. If the two geoms have identical parameters
there is nothing to do, but what if their parameters are different? In that case we use the geom attributes
<span class="at">solmix</span> and <span class="at">priority</span> to decide how to combine them. The combination rules for each contact parameter
are as follows:</p>
<dl class="simple">
<dt>condim</dt><dd><p>If one of the two geoms has higher priority, its condim is used. If both geoms have the same priority, the maximum of
the two condims is used. In this way a frictionless geom and a frictional geom form a frictional contact, unless the
frictionless geom has higher priority. The latter is desirable in particle systems for example, where we may not want
the particles to stick to any objects.</p>
</dd>
<dt>friction</dt><dd><p>Recall that contacts can have up to 5 friction coefficients: two tangential, one torsional, two rolling. Each contact
in mjData.contact actually has all 5 of them, even if condim is less than 6 and not all coefficients are used. In
contrast, geoms have only 3 friction coefficients: tangential (same for both axes), torsional, rolling (same for both
axes). Each of these 3D vectors of friction coefficients is expanded into a 5D vector of friction coefficients by
replicating the tangetial and rolling components. The contact friction coefficients are then computed according to
the following rule: if one of the two geoms has higher priority, its friction coefficients are used. Otherwise the
element-wise maximum of each friction coefficient over the two geoms is used. The rationale is similar to taking the
maximum over condim: we want the more frictional geom to win.
The reason for having 5 coefficients per contact and only 3 per geom is as follows. For a contact pair, we want to
allow the most flexible model our solver can handle. As mentioned earlier, anisotropic friction can be exploited to
model effects such as skating. This however requires knowing how the two axes of the contact tangent plane are
oriented. For a predefined contact pair we know the two geom types in advance, and the corresponding collision
function always generates contact frames oriented in the same way - which we do not describe here but it can be seen
in the visualizer. For individual geoms however, we do not know which other geoms they might collide with and what
their geom types might be, so there is no way to know how the contact tangent plane will be oriented when specifying
an individual geom. This is why MuJoCo does not allow anisotropic friction in the individual geom specifications, but
only in the explicit contact pair specifications.</p>
</dd>
<dt>margin, gap</dt><dd><p>The maximum of the two geom margins (or gaps respectively) is used. The geom priority is ignored here, because the
margin and gap are distance properties and a one-sided specification makes little sense.</p>
</dd>
<dt>solref, solimp</dt><dd><p>If one of the two geoms has higher priority, its solref and solimp parameters are used. If both geoms have the same
priority, the weighted average is used. The weights are proportional to the solmix attributes, i.e., weight1 =
solmix1 / (solmix1 + solmix2) and similarly for weight2. There is one important exception to this weighted averaging
rule. If solref for either geom is non-positive, i.e., it relies on the new direct format introduced in MuJoCo 2.0,
then the element-wise minimum is used regardless of solmix. This is because averaging solref parameters in different
formats would be meaningless.</p>
</dd>
</dl>
</section>
<section id="contact-override">
<span id="coverride"></span><h3>Contact override<a class="headerlink" href="#contact-override" title="Permalink to this headline">#</a></h3>
<p>MuJoCo uses an elaborate as well as novel <a class="reference internal" href="computation.html#constraint"><span class="std std-ref">Constraint model</span></a> described in the
Computation chapter. Gaining an intuition for how this model works requires some experimentation. In order to
facilitate this process, we provide a mechanism to override some of the solver parameters, without making changes to
the actual model. Once the override is disabled, the simulation reverts to the parameters specified in the model. This
mechanism can also be used to implement continuation methods in the context of numerical optimization (such as optimal
control or state estimation). This is done by allowing contacts to act from a distance in the early phases of
optimization - so as to help the optimizer find a gradient and get close to a good solution - and reducing this effect
later to make the final solution physically realistic.</p>
<p>The relevant settings here are the <span class="at">override</span> attribute of <a class="reference internal" href="XMLreference.html#option-flag"><span class="std std-ref">flag</span></a> which
enables and disables this mechanism, and the <span class="at">o_margin</span>, <span class="at">o_solref</span>, <span class="at">o_solimp</span> attributes of
<a class="reference internal" href="XMLreference.html#option"><span class="std std-ref">option</span></a> which specify the new solver parameters. Note that the override applies only to
contacts, and not to other types of constraints. In principle there are many real-valued parameters in a MuJoCo model
that could benefit from a similar override mechanism. However we had to draw a line somewhere, and contacts are the
natural choice because they give rise to the richest yet most difficult-to-tune behavior. Furthermore, contact
dynamics often present a challenge in terms of numerical optimization, and experience has shown that continuation over
contact parameters can help avoid local minima.</p>
</section>
<section id="user-parameters">
<span id="cuser"></span><h3>User parameters<a class="headerlink" href="#user-parameters" title="Permalink to this headline">#</a></h3>
<p>A number of MJCF elements have the optional attribute <span class="at">user</span>, which defines a custom element-specific parameter
array. This interacts with the corresponding “nuser_XXX” attribute of the <a class="reference internal" href="XMLreference.html#size"><span class="std std-ref">size</span></a> element. If for example we
set <span class="at">nuser_geom</span> to 5, then every geom in mjModel will have a custom array of 5 real-valued parameters. These geom-
specific parameters are either defined in the MJCF file via the <span class="at">user</span> attribute of <a class="reference internal" href="XMLreference.html#body-geom"><span class="std std-ref">geom</span></a>, or set
to 0 by the compiler if this attribute is omitted. The default value of all “nuser_XXX” attributes is -1, which
instructs the compiler to automatically set this value to the length of the maximum associated <span class="at">user</span> attribute
defined in the model. MuJoCo does not use these parameters in any internal computations; instead they are available for
custom computations. The parser allows arrays of arbitrary length in the XML, and the compiler later resizes them to
length nuser_XXX.</p>
<p>Some element-specific parameters that are normally used in internal computations can also be used in custom
computations. This is done by installing user callbacks which override parts of the simulation pipeline. For example,
the <a class="reference internal" href="XMLreference.html#actuator-general"><span class="std std-ref">general</span></a> actuator element has attributes <span class="at">dyntype</span> and <span class="at">dynprm</span>. If
<span class="at">dyntype</span> is set to “user”, then MuJoCo will call <a class="reference internal" href="APIreference/APIglobals.html#mjcb-act-dyn"><span class="std std-ref">mjcb_act_dyn</span></a> to compute
the actuator dynamics instead of calling its internal function. The user function pointed to by
<a class="reference internal" href="APIreference/APIglobals.html#mjcb-act-dyn"><span class="std std-ref">mjcb_act_dyn</span></a> can interpret the parameters defined in <span class="at">dynprm</span> however it
wishes. However the length of this parameter array cannot be changed (unlike the custom arrays described earlier whose
length is defined in the MJCF file). The same applies to other callbacks.</p>
<p>In addition to the element-specific user parameters described above, one can include global data in the model via
<a class="reference internal" href="XMLreference.html#custom"><span class="std std-ref">custom</span></a> elements. For data that change in the course of the simulation, there is also
the array mjData.userdata whose size is determined by the <span class="at">nuserdata</span> attribute of the
<a class="reference internal" href="XMLreference.html#size"><span class="std std-ref">size</span></a> element.</p>
</section>
<section id="solver-settings">
<span id="calgorithms"></span><h3>Solver settings<a class="headerlink" href="#solver-settings" title="Permalink to this headline">#</a></h3>
<p>The computation of constraint forces and constrained accelerations involves solving an optimization problem
numerically. MuJoCo has three algorithms for solving this optimization problem: CG, Newton, PGS. Each of them can be
applied to a pyramidal or elliptic model of the friction cones, and with dense or sparse constraint Jacobians. In
addition, the user can specify the maximum number of iterations, and tolerance level which controls early termination.
There is also a second Noslip solver, which is a post-processing step enabled by specifying a positive number of
noslip iterations. All these algorithm settings can be specified in the <a class="reference internal" href="XMLreference.html#option"><span class="std std-ref">option</span></a> element.</p>
<p>The default settings work well for most models, but in some cases it is necessary to tune the algorithm. The best way to
do this is to experiment with the relevant settings and use the visual profiler in <a class="reference internal" href="programming/samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a>,
which shows the timing of different computations as well as solver statistics per iteration. We can offer the following
general guidelines and observations:</p>
<ul class="simple">
<li><p>The constraint Jacobian should be dense for small models and sparse for large models. The default setting is ‘auto’;
it resolves to dense when the number of degrees of freedom is up to 60, and sparse over 60. Note however that the
threshold is better defined in terms of number of active constraints, which is model and behavior dependent.</p></li>
<li><p>The choice between pyramidal and elliptic friction cones is a modeling choice rather than an algorithmic choice,
i.e., it leads to a different optimization problem solved with the same algorithms. Elliptic cones correspond more
closely to physical reality. However pyramidal cones can improve the performance of the algorithms - but not
necessarily. While the default is pyramidal, we recommend trying the elliptic cones. When contact slip is a problem,
the best way to suppress it is to use elliptic cones, large impratio, and the Newton algorithm with very small
tolerance. If that is not sufficient, enable the Noslip solver.</p></li>
<li><p>The Newton algorithm is the best choice for most models. It has quadratic convergence near the global minimum and
gets there in surprisingly few iterations - usually around 5, and rarely more than 20. It should be used with
aggressive tolerance values, say 1e-10, because it is capable of achieving high accuracy without added delay (due to
quadratic convergence at the end). The only situation where we have seen it slow down are large models with elliptic
cones and many slipping contacts. In that regime the Hessian factorization needs a lot of updates. It may also slow
down in some large models with unfortunate ordering of model elements that results in high fill-in (computing the
optimal elimination order is NP-hard, so we are relying on a heuristic). Note that the number of non-zeros in the
factorized Hessian can be monitored in the profiler.</p></li>
<li><p>The CG algorithm works well in the situation described above where Newton slows down. In general CG shows linear
convergence with a good rate, but it cannot compete with Newton in terms of number of iterations, especially when
high accuracy is desired. However its iterations are much faster, and are not affected by fill-in or increased
complexity due to elliptic cones. If Newton proves to be too slow, try CG next.</p></li>
<li><p>The PGS solver is best when the number of degrees of freedom is larger than the number of constraints. PGS solves a
constrained optimization problem and has sub-linear convergence in our experience, however it usually makes rapid
progress on the first few iterations. So it is a good choice when inaccurate solutions can be tolerated. For systems
with large mass ratios or other model properties causing poor conditioning, PGS convergence tends to be rather slow.
Keep in mind that PGS performs sequential updates, and therefore breaks symmetry in systems where the physics should
be symmetric. In contrast, CG and Newton perform parallel updates and preserve symmetry.</p></li>
<li><p>The Noslip solver is a modified PGS solver. It is executed as a post-processing step after the main solver (which can
be Newton, CG or PGS). The main solver updates all unknowns. In contrast, the Noslip solver updates only the
constraint forces in friction dimensions, and ignores constraint regularization. This has the effect of suppressing
the drift or slip caused by the soft-constraint model. However, this cascade of optimization steps is no longer
solving a well-defined optimization problem (or any other problem); instead it is just an adhoc mechanism. While it
usually does its job, we have seen some instabilities in models with more complex interactions among multiple
contacts.</p></li>
<li><p>PGS has a setup cost (in terms of CPU time) for computing the inverse inertia in constraint space. Similarly, Newton
has a setup cost for the initial factorization of the Hessian, and incurs additional factorization costs depending on
how many factorization updates are needed later. CG does not have any setup cost. Since the Noslip solver is also a
PGS solver, the PGS setup cost will be paid whenever Noslip is enabled, even if the main solver is CG or Newton. The
setup operation for the main PGS and Noslip PGS is the same, thus the setup cost is paid only once when both are
enabled.</p></li>
</ul>
</section>
<section id="actuator-shortcuts">
<span id="cactuator"></span><h3>Actuator shortcuts<a class="headerlink" href="#actuator-shortcuts" title="Permalink to this headline">#</a></h3>
<p>As explained in the <a class="reference internal" href="computation.html#geactuation"><span class="std std-ref">Actuation model</span></a> section of the Computation chapter, MuJoCo offers a flexible
actuator model with transmission, activation dynamics and force generation components that can be specified
independently. The full functionality can be accessed via the XML element <a class="reference internal" href="XMLreference.html#actuator-general"><span class="std std-ref">general</span></a> which allows
the user to create a variety of custom actuators. In addition, MJCF provides shortcuts for configuring common actuators.
This is done via the XML elements <a class="reference internal" href="XMLreference.html#actuator-motor"><span class="std std-ref">motor</span></a>, <a class="reference internal" href="XMLreference.html#actuator-position"><span class="std std-ref">position</span></a>, <a class="reference internal" href="XMLreference.html#actuator-velocity"><span class="std std-ref">velocity</span></a>, <a class="reference internal" href="XMLreference.html#actuator-intvelocity"><span class="std std-ref">intvelocity</span></a>, <a class="reference internal" href="XMLreference.html#actuator-damper"><span class="std std-ref">damper</span></a>,
<a class="reference internal" href="XMLreference.html#actuator-cylinder"><span class="std std-ref">cylinder</span></a>, <a class="reference internal" href="XMLreference.html#actuator-muscle"><span class="std std-ref">muscle</span></a>, and <a class="reference internal" href="XMLreference.html#actuator-adhesion"><span class="std std-ref">adhesion</span></a>. These are
<em>not</em> separate model elements. Internally MuJoCo supports only one actuator type -which is why when an MJCF model is
saved all actuators are written as <span class="el">general</span>. Shortcuts create general actuators implicitly, set their attributes to
suitable values, and expose a subset of attributes with possibly different names. For example, <span class="el">position</span> creates a
position servo with attribute <span class="at">kp</span> which is the servo gain. However <span class="el">general</span> does not have an attribute
<span class="at">kp</span>. Instead the parser adjusts the gain and bias parameters of the general actuator in a coordinated way so as to
mimic a position servo. The same effect could have been achieved by using <span class="el">general</span> directly, and setting its
attributes to certain values as described below.</p>
<p>Actuator shortcuts also interact with defaults. Recall that the <a class="reference internal" href="#cdefault"><span class="std std-ref">default setting</span></a> mechanism involves
classes, each of which has a complete collection of dummy elements (one of each element type) used to initialize the
attributes of the actual model elements. In particular, each defaults class has only one general actuator element.
What happens if we specify <span class="el">position</span> and later <span class="el">velocity</span> in the same defaults class? The XML elements are
processed in order, and the attributes of the single general actuator are set every time an actuator-related element
is encountered. Thus <span class="el">velocity</span> has precedence. If however we specify <span class="el">general</span> in the defaults class, it will
only set the attributes that are given explicitly, and leave the rest unchanged. A similar complication arises when
creating actual model elements. Suppose the active defaults class specified <span class="el">position</span>, and now we create an
actuator using <span class="el">general</span> and omit some of its attributes. The missing attributes will be set to whatever values
are used to model a position servo, even though this actuator may not be intended as a position servo.</p>
<p>In light of these potential complications, we recommend a simple approach: use the same actuator shortcut in both the
defaults class and in the creation of actual model elements. If a given model requires different actuators, either
create multiple defaults classes, or avoid using defaults for actuators and instead specify all their attributes
explicitly.</p>
</section>
<section id="actuator-force-clamping">
<span id="cforcerange"></span><h3>Actuator force clamping<a class="headerlink" href="#actuator-force-clamping" title="Permalink to this headline">#</a></h3>
<p>Actuator forces are usually limited between lower and upper bounds. These limits can be enforced in three ways:</p>
<dl>
<dt>Control clamping with <a class="reference internal" href="XMLreference.html#actuator-general-ctrlrange"><span class="std std-ref">ctrlrange</span></a>:</dt><dd><p>If this actuator attribute is set, the input control value will be clamped. For simple <a class="reference internal" href="XMLreference.html#actuator-motor"><span class="std std-ref">motors</span></a>,
clamping the control input is equivalent to clamping the force output.</p>
</dd>
<dt>Force clamping at actuator output with <a class="reference internal" href="XMLreference.html#actuator-general-forcerange"><span class="std std-ref">forcerange</span></a>:</dt><dd><p>If this actuator attribute is set, the actuator’s output force will be clamped. This attribute is useful for e.g.
<a class="reference internal" href="XMLreference.html#actuator-position"><span class="std std-ref">position actuators</span></a>, to keep the forces within bounds. Note that position actuators
usually also require control range clamping to avoid hitting joint limits.</p>
</dd>
<dt>Force clamping at joint input with <a class="reference internal" href="XMLreference.html#body-joint-actuatorfrcrange"><span class="std std-ref">joint/actuatorfrcrange</span></a>:</dt><dd><p>This joint attribute clamps input forces from all actuators acting on the joint, after passing through the
<a class="reference internal" href="computation.html#getransmission"><span class="std std-ref">transmission</span></a>. Clamping actuator forces at the joint is equivalent to clamping them at the
actuator if the transmission is trivial (there is a one-to-one relationship between the actuator and the joint).
However, in situations where multiple actuators act on one joint or one actuator acts on multiple joints—yet the
actual torque is applied by a single physical actuator at the joint—it is desirable to clamp the forces at the joint
itself. Below are three examples where it is desirable to clamp actuator forces at the joint, rather than the
actuator:</p>
<ul class="simple">
<li><p>In <a class="reference external" href="https://github.com/deepmind/mujoco/blob/main/test/engine/testdata/actuation/joint_force_clamp.xml">this example model</a> ,
two actuators, a <a class="reference internal" href="XMLreference.html#actuator-motor"><span class="std std-ref">motor</span></a> and a <a class="reference internal" href="XMLreference.html#actuator-damper"><span class="std std-ref">damper</span></a>, act on a single joint.</p></li>
<li><p>In <a class="reference external" href="https://github.com/deepmind/mujoco/blob/main/model/car/car.xml">this example model</a> (similar to a “Dubin’s
Car”), two actuators act on two wheels via a <a class="reference internal" href="XMLreference.html#tendon-fixed"><span class="std std-ref">fixed tendon</span></a> transmission in order to apply
symmetric (roll forward/back) and antisymmetric (turn right/left) torques.</p></li>
<li><p>In <a class="reference external" href="https://github.com/deepmind/mujoco/tree/main/test/engine/testdata/actuation/refsite.xml">this example model</a>,
a <a class="reference internal" href="XMLreference.html#actuator-general-refsite"><span class="std std-ref">site transmission</span></a> implements a Cartesian controller of an arm end-effector.
In order for the computed torques to be realisable by individual, torque-limited joint motors, they need to be
clamped at the joints.</p></li>
</ul>
<p>Note that in this case, where forces/torques are combined by the transmission, one should use the
<a class="reference internal" href="XMLreference.html#sensor-jointactuatorfrc"><span class="std std-ref">jointactuatorfrc</span></a> sensor to report the total actuator force acting on a joint.
The standard <a class="reference internal" href="XMLreference.html#sensor-actuatorfrc"><span class="std std-ref">actuatorfrc</span></a> sensor will continue to report the pre-clamped actuator force.</p>
</dd>
</dl>
<p>The three clamping options above are non-exclusive and can be combined as required.</p>
</section>
<section id="activation-clamping">
<span id="cactrange"></span><h3>Activation clamping<a class="headerlink" href="#activation-clamping" title="Permalink to this headline">#</a></h3>
<p>As described in the <a class="reference internal" href="computation.html#geactuation"><span class="std std-ref">Actuation model</span></a> section of the Computation chapter, MuJoCo supports actuators
with internal dynamics whose states are called “activations”. One useful application of these stateful actuators is the
“integrated-velocity” actuator, implemented by the <a class="reference internal" href="XMLreference.html#actuator-intvelocity"><span class="std std-ref">intvelocity</span></a> shortcut. Different from the
<a class="reference internal" href="XMLreference.html#actuator-velocity"><span class="std std-ref">pure velocity</span></a> actuators, which implement direct feedback on transmission target’s velocity,
<em>integrated-velocity</em> actuators couple an <em>integrator</em> with a <em>position-feedback</em> actuator. In this case the semantics
of the activation state are “the setpoint of the position actuator”, and the semantics of the control signal are “the
velocity of the setpoint of the position actuator”. Note that in real robotic systems this integrated-velocity actuator
is the most common implementation of actuators with velocity semantics, rather than pure feedback on velocity which is
often quite unstable (both in real life and in simulation).</p>
<p>In the case of integrated-velocity actuators, it is often desirable to <em>clamp</em> the activation state, since otherwise the
position target would keep integrating beyond the joint limits, leading to loss of controllabillity. To see the effect
of activation clamping, load the example model below:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;mujoco&gt;</span>
<span class="w">  </span><span class="nt">&lt;default&gt;</span>
<span class="w">    </span><span class="nt">&lt;joint</span><span class="w"> </span><span class="na">axis=</span><span class="s">&quot;0 0 1&quot;</span><span class="w"> </span><span class="na">limited=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">range=</span><span class="s">&quot;-90 90&quot;</span><span class="w"> </span><span class="na">damping=</span><span class="s">&quot;0.3&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">size=</span><span class="s">&quot;.1 .1 .1&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;box&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;/default&gt;</span>

<span class="w">  </span><span class="nt">&lt;worldbody&gt;</span>
<span class="w">    </span><span class="nt">&lt;body&gt;</span>
<span class="w">      </span><span class="nt">&lt;joint</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;joint1&quot;</span><span class="nt">/&gt;</span>
<span class="w">      </span><span class="nt">&lt;geom/&gt;</span>
<span class="w">    </span><span class="nt">&lt;/body&gt;</span>
<span class="w">    </span><span class="nt">&lt;body</span><span class="w"> </span><span class="na">pos=</span><span class="s">&quot;.3 0 0&quot;</span><span class="nt">&gt;</span>
<span class="w">      </span><span class="nt">&lt;joint</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;joint2&quot;</span><span class="nt">/&gt;</span>
<span class="w">      </span><span class="nt">&lt;geom/&gt;</span>
<span class="w">    </span><span class="nt">&lt;/body&gt;</span>
<span class="w">  </span><span class="nt">&lt;/worldbody&gt;</span>

<span class="w">  </span><span class="nt">&lt;actuator&gt;</span>
<span class="w">    </span><span class="nt">&lt;general</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;unclamped&quot;</span><span class="w"> </span><span class="na">joint=</span><span class="s">&quot;joint1&quot;</span><span class="w"> </span><span class="na">gainprm=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="na">biastype=</span><span class="s">&quot;affine&quot;</span>
<span class="w">      </span><span class="na">biasprm=</span><span class="s">&quot;0 -1&quot;</span><span class="w"> </span><span class="na">dyntype=</span><span class="s">&quot;integrator&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;intvelocity</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;clamped&quot;</span><span class="w"> </span><span class="na">joint=</span><span class="s">&quot;joint2&quot;</span><span class="w"> </span><span class="na">actrange=</span><span class="s">&quot;-1.57 1.57&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;/actuator&gt;</span>
<span class="nt">&lt;/mujoco&gt;</span>
</pre></div>
</div>
<p>Note that the <span class="at">actrange</span> attribute is always specified in native units (radians), even though the joint range
can be either in degrees (the default) or radians, depending on the <a class="reference internal" href="XMLreference.html#compiler"><span class="std std-ref">compiler/angle</span></a> attribute.</p>
</section>
<section id="actuator-length-range">
<span id="clengthrange"></span><h3>Actuator length range<a class="headerlink" href="#actuator-length-range" title="Permalink to this headline">#</a></h3>
<p>As of MuJoCo 2.0, the field mjModel.actuator_lengthrange contains the range of feasible actuator lengths (or more
precisely, lengths of the actuator’s transmission). This is needed to simulate <a class="reference internal" href="#cmuscle"><span class="std std-ref">muscle actuators</span></a> as
explained below. Here we focus on what actuator_lengthrange means and how to set it.</p>
<p>Unlike all other fields of mjModel which are exact physical or geometric quantities, actuator_lengthrange is an
approximation. Intuitively it corresponds to the minimum and maximum length that the actuator’s transmission can reach
over all “feasible” configurations of the model. However MuJoCo constraints are soft, so in principle any
configuration is feasible. Yet we need a well-defined range for muscle modeling. There are three ways to set this
range: (1) provide it explicitly using the new attribute lengthrange available in all actuators; (2) copy it from the
limits of the joint or tendon to which the actuator is attached; (3) compute it automatically, as explained in the
rest of this section. There are many options here, controlled with the new XML element
<a class="reference internal" href="XMLreference.html#compiler-lengthrange"><span class="std std-ref">lengthrange</span></a>.</p>
<p>Automatic computation of actuator length ranges is done at compile time, and the results are stored in
mjModel.actuator_lengthrange of the compiled model. If the model is then saved (either as XML or MJB), the computation
does not need to be repeated at the next load. This is important because the computation can slow down the model
compiler with large musculo-skeletal models. Indeed we have made the compiler multi-threaded just to speed up this
operation (different actuators are processed in parallel in different threads). Incidentally, this is why the flag
‘-pthread’ is now needed when linking user code against the MuJoCo library on Linux and macOS.</p>
<p>Automatic computation relies on modified physics simulation. For each actuator we apply force (negative when computing
the minimum, positive when computing the maximum) through the actuator’s transmission, advance the simulation in a
damped regime avoiding instabilities, give it enough time to settle and record the result. This is related to gradient
descent with momentum, and indeed we have experimented with explicit gradient-based optimization, but the problem is
that it is not clear what objective we should be optimizing (given the mix of soft constraints). By using simulation,
we are essentially letting the physics tell us what to optimize. Keep in mind though that this is still an
optimization process, and as such it has parameters that may need to be adjusted. We provide conservative defaults
which should work with most models, but if they don’t, use the attributes of
<a class="reference internal" href="XMLreference.html#compiler-lengthrange"><span class="std std-ref">lengthrange</span></a> for fine-tuning.</p>
<p>It is important to keep in mind the geometry of the model when using this feature. The implicit assumption here is
that feasible actuator lengths are indeed limited. Furthermore we do not consider contacts as limiting factors (in
fact we disable contacts internally in this simulation, together with passive forces, gravity, friction loss and
actuator forces). This is because models with contacts can tangle up and produce many local minima. So the actuator
should be limited either because of joint or tendon limits defined in the model (which are enabled during this
simulation) or due to geometry. To illustrate the latter, consider a tendon with one end attached to the world and the
other end attached to an object spinning around a hinge joint attached to the world. In this case the minimum and
maximum length of the tendon are well-defined and depend on the size of the circle that the attachment point traces in
space, even though neither the joint nor the tendon have limits defined by the user. But if the actuator is attached
to the joint, or to a fixed tendon equal to the joint, then it is unlimited. The compiler will return an error in this
case, but it cannot tell if the error is due to lack of convergence or because the actuator length is unlimited. All
of this sounds overly complicated, and it is in the sense that we are considering all possible corner cases here. In
practice length ranges will almost always be used with muscle actuators attached to spatial tendons, and there will be
joint limits defined in the model, effectively limiting the lengths of the muscle actuators. If you get a convergence
error in such a model, the most likely explanation is that you forgot to include joint limits.</p>
</section>
<section id="muscle-actuators">
<span id="cmuscle"></span><h3>Muscle actuators<a class="headerlink" href="#muscle-actuators" title="Permalink to this headline">#</a></h3>
<p>As of MuJoCo 2.0, we provide a set of tools for modeling biological muscles. Users who want to add muscles with minimum
effort can do so with a single line of XML in the actuator section:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;actuator&gt;</span>
<span class="w">    </span><span class="nt">&lt;muscle</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;mymuscle&quot;</span><span class="w"> </span><span class="na">tendon=</span><span class="s">&quot;mytendon&quot;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/actuator&gt;</span>
</pre></div>
</div>
<p>Biological muscles look very different from each other, yet behave in remarkably similar ways once certain scaling is
applied. Our default settings apply such scaling, which is why one can obtain a reasonable muscle model without
adjusting any parameters. Constructing a more detailed model will of course require parameter adjustment, as explained
in this section.</p>
<p>Keep in mind that even though the muscle model is quite elaborate, it is still a type of MuJoCo actuator and obeys the
same conventions as all other actuators. A muscle can be defined using <a class="reference internal" href="XMLreference.html#actuator-general"><span class="std std-ref">general</span></a>, but
the shortcut <a class="reference internal" href="XMLreference.html#actuator-muscle"><span class="std std-ref">muscle</span></a> is more convenient. As with all other actuators, the force
production mechanism and the transmission are defined independently. Nevertheless, muscles only make (bio)physical
sense when attached to tendon or joint transmissions. For concreteness we will assume a tendon transmission here.</p>
<p>First we discuss length and length scaling. The range of feasible lengths of the transmission (i.e., MuJoCo tendon) will
play an important role; see <a class="reference internal" href="#clengthrange"><span class="std std-ref">Length range</span></a> section above. In biomechanics, a muscle and a tendon are
attached in series and form a muscle-tendon actuator. Our convention is somewhat different: in MuJoCo the entity that
has spatial properties (in particular length and velocity) is the tendon, while the muscle is an abstract force-
generating mechanism that pulls on the tendon. Thus the tendon length in MuJoCo corresponds to the muscle+tendon length
in biomechanics. We assume that the biological tendon is inelastic, with constant length <span class="math">\(L_T\)</span>, while the
biological muscle length <span class="math">\(L_M\)</span> varies over time. The MuJoCo tendon length is the sum of the biological muscle and
tendon lengths:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\texttt{actuator\_length} = L_T + L_M

\]</div>
</div>
<p>Another important constant is the optimal resting length of the muscle, denoted <span class="math">\(L_0\)</span>. It equals the length
<span class="math">\(L_M\)</span> at which the muscle generates maximum active force at zero velocity. We do not ask the user to specify
<span class="math">\(L_0\)</span> and <span class="math">\(L_T\)</span> directly, because it is difficult to know their numeric values given the spatial complexity
of the tendon routing and wrapping. Instead we compute <span class="math">\(L_0\)</span> and <span class="math">\(L_T\)</span> automatically as follows. The length
range computation described above already provided the operating range for <span class="math">\(L_T+L_M\)</span>. In addition, we ask the user
to specify the operating range for the muscle length <span class="math">\(L_M\)</span> scaled by the (still unknown) constant <span class="math">\(L_0\)</span>.
This is done with the attribute range; the default scaled range is <span class="math">\((0.75, 1.05)\)</span>. Now we can compute the two
constants, using the fact that the actual and scaled ranges have to map to each other:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
(\texttt{actuator\_lengthrange[0]} - L_T) / L_0 &= \texttt{range[0]} \\
(\texttt{actuator\_lengthrange[1]} - L_T) / L_0 &= \texttt{range[1]} \\
\end{aligned}

\]</div>
</div>
<p>At runtime, we compute the scaled muscle length and velocity as:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\begin{aligned}
L &= (\texttt{actuator\_length} - L_T) / L_0 \\
V &= \texttt{actuator\_velocity} / L_0 \\
\end{aligned}

\]</div>
</div>
<p>The advantage of the scaled quantities is that all muscles behave similarly in that representation. The behavior is
captured by the Force-Length-Velocity (<span class="math">\(\text{\small FLV}\)</span>) function measured in many experimental papers. We
approximate this function as follows:</p>
<p><a class="reference internal" href="_images/musclemodel.png"><img alt="image1" src="_images/musclemodel.png" style="width: 650px;" /></a></p>
<p>The function is in the form:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\text{\small FLV}(L, V, \texttt{act}) = F_L(L)\cdot F_V(V)\cdot \texttt{act} + F_P(L)

\]</div>
</div>
<p>Comparing to the general form of a MuJoCo actuator, we see that <span class="math">\(F_L\cdot F_V\)</span> is the actuator gain and
<span class="math">\(F_P\)</span> is the actuator bias. <span class="math">\(F_L\)</span> is the active force as a function of length, while <span class="math">\(F_V\)</span> is the
active force as a function of velocity. They are multiplied to obtain the overall active force (note the scaling by act
which is the actuator activation). <span class="math">\(F_P\)</span> is the passive force which is always present regardless of activation.
The output of the <span class="math">\(\text{\small FLV}\)</span> function is the scaled muscle force. We multiply the scaled force by a
muscle-specific constant <span class="math">\(F_0\)</span> to obtain the actual force:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\texttt{actuator\_force} = -\text{\small FLV}(L, V, \texttt{act}) \cdot F_0

\]</div>
</div>
<p>The negative sign is because positive muscle activation generates pulling force. The constant <span class="math">\(F_0\)</span> is the peak
active force at zero velocity. It is related to the muscle thickness (i.e., physiological cross-sectional area or PCSA).
If known, it can be set with the attribute force of element <a class="reference internal" href="XMLreference.html#actuator-muscle"><span class="std std-ref">muscle</span></a>. If it is not known, we set
it to <span class="math">\(-1\)</span> which is the default. In that case we rely on the fact that larger muscles tend to act on joints that
move more weight. The attribute scale defines this relationship as:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[F_0 = \text{scale} / \texttt{actuator\_acc0}

\]</div>
</div>
<p>The quantity <span class="math">\(\texttt{actuator\_acc0}\)</span> is precomputed by the model compiler. It is the norm of the joint
acceleration caused by unit force acting on the actuator transmission. Intuitively, <span class="math">\(\text{scale}\)</span> determines how
strong the muscle is “on average” while its actual strength depends on the geometric and inertial properties of the
entire model.</p>
<p>Thus far we encountered three constants that define the properties of an individual muscle: <span class="math">\(L_T, L_0, F_0\)</span>. In
addition, the function <span class="math">\(\text{\small FLV}\)</span> itself has several parameters illustrated in the above figure:
<span class="math">\(l_\text{min}, l_\text{max}, v_\text{max}, f_\text{pmax}, f_\text{vmax}\)</span>. These are supposed to be the same for
all muscles, however different experimental papers suggest different shapes of the FLV function, thus users familiar
with that literature may want to adjust them. We provide the MATLAB function <a class="reference external" href="_static/FLV.m">FLV.m</a> which was used to
generate the above figure and shows how we compute the <span class="math">\(\text{\small FLV}\)</span> function.</p>
<p>Before embarking on a mission to design more accurate <span class="math">\(\text{\small FLV}\)</span> functions, consider the fact that the
operating range of the muscle has a bigger effect than the shape of the <span class="math">\(\text{\small FLV}\)</span> function, and in many
cases this parameter is unknown. Below is a graphical illustration:</p>
<p><a class="reference internal" href="_images/musclerange.png"><img alt="image2" src="_images/musclerange.png" style="width: 400px;" /></a></p>
<p>This figure format is common in the biomechanics literature, showing the operating range of each muscle superimposed on
the normalized <span class="math">\(\text{FL}\)</span> curve (ignore the vertical displacement). Our default range is shown in black. The blue
curves are experimental data for two arm muscles. One can find muscles with small range, large range, range spanning the
ascending portion of the <span class="math">\(\text{FL}\)</span> curve, or the descending portion, or some of both. Now suppose you have a
model with 50 muscles. Do you believe that someone did careful experiments and measured the operating range for every
muscle in your model, taking into account all the joints that the muscle spans? If not, then it is better to think of
musculo-skeletal models as having the same general behavior as the biological system, while being different in various
details – including details that are of great interest to some research community. For most muscle properties which
modelers consider constant and known, there is an experimental paper showing that they vary under some conditions. This
is not to discourage people from building accurate models, but rather to discourage people from believing too strongly
in their models.</p>
<p>Coming back to our muscle model, there is the muscle activation <code class="docutils literal notranslate"><span class="pre">act</span></code>. This is the state of a first-order nonlinear
filter whose input is the control signal. The filter dynamics are:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\frac{\partial}{\partial t}\texttt{act} = \frac{\texttt{ctrl} - \texttt{act}}{\tau(\texttt{ctrl}, \texttt{act})}

\]</div>
</div>
<p>Internally the control signal is clamped to [0, 1] even if the actuator does not have a control range specified. There
are two time constants specified with the attribute timeconst, namely <span class="math">\(\text{timeconst} = (\tau_\text{act},
\tau_\text{deact})\)</span> with defaults <span class="math">\((0.01, 0.04)\)</span>. Following <a class="reference external" href="https://doi.org/10.1115/1.4023390">Millard et al. (2013)</a>, the effective time constant <span class="math">\(\tau\)</span> is then computed at runtime as:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[\tau(\texttt{ctrl}, \texttt{act}) =
\begin{cases}
   \tau_\text{act} \cdot (0.5 + 1.5\cdot\texttt{act}) & \texttt{ctrl}-\texttt{act} \gt 0 \\
   \tau_\text{deact} / (0.5 + 1.5\cdot\texttt{act}) & \texttt{ctrl} - \texttt{act} \leq 0
\end{cases}

\]</div>
</div>
<p>Since the above equation describes discontinuous switching, which can be undesirable when using derivative-based
optimization, we introduce the optional smoothing parameter <a class="reference internal" href="XMLreference.html#actuator-muscle-tausmooth"><span class="std std-ref">tausmooth</span></a>. When greater
than 0, the switching is replaced by <a class="reference internal" href="APIreference/APIfunctions.html#mju-sigmoid"><span class="std std-ref">mju_sigmoid</span></a>, which will smoothly interpolate between the two values within
the range <span class="math">\((\texttt{ctrl}-\texttt{act}) \pm \text{tausmooth}/2\)</span>.</p>
<p>Now we summarize the attributes of element <a class="reference internal" href="XMLreference.html#actuator-muscle"><span class="std std-ref">muscle</span></a> which users may want to adjust,
depending on their familiarity with the biomechanics literature and availability of detailed measurements with regard
to a particular model:</p>
<dl class="simple">
<dt>Defaults</dt><dd><p>Use the built-in defaults everywhere. All you have to do is attach a muscle to a tendon, as shown at the beginning of
this section. This yields a generic yet reasonable model.</p>
</dd>
<dt>scale</dt><dd><p>If you do not know the strength of individual muscles but want to make all muscles stronger or weaker, adjust scale.
This can be adjusted separately for each muscle, but it makes more sense to set it once in the
<a class="reference internal" href="XMLreference.html#default"><span class="std std-ref">default</span></a> element.</p>
</dd>
<dt>force</dt><dd><p>If you know the peak active force <span class="math">\(F_0\)</span> of the individual muscles, enter it here. Many experimental papers
contain this data.</p>
</dd>
<dt>range</dt><dd><p>The operating range of the muscle in scaled lengths is also available in some papers. It is not clear how reliable
such measurements are (given that muscles act on many joints) but they do exist. Note that the range differs
substantially between muscles.</p>
</dd>
<dt>timeconst</dt><dd><p>Muscles are composed of slow-twitch and fast-twitch fibers. The typical muscle is mixed, but some muscles have a
higher proportion of one or the other fiber type, making them faster or slower. This can be modeled by adjusting the
time constants. The vmax parameter of the <span class="math">\(\text{\small FLV}\)</span> function should also be adjusted accordingly.</p>
</dd>
<dt>tausmooth</dt><dd><p>When positive, smooths the transition between activation and de-activation time-constants. While a single
<a class="reference external" href="https://en.wikipedia.org/wiki/Motor_unit">motor unit</a> is either activating or de-activating, an entire muscle
will have a mixture of many units, leading to a corresponding mixture of timescales.</p>
</dd>
<dt>lmin, lmax, vmax, fpmax, fvmax</dt><dd><p>These are the parameters controlling the shape of the <span class="math">\(\text{\small FLV}\)</span> function. Advanced users can
experiment with them; see MATLAB function <a class="reference external" href="_static/FLV.m">FLV.m</a>. Similar to the scale setting, if you want to
change the <span class="math">\(\text{\small FLV}\)</span> parameters for all muscles, do so in the <a class="reference internal" href="XMLreference.html#default"><span class="std std-ref">default</span></a> element.</p>
</dd>
<dt>Custom model</dt><dd><p>Instead of adjusting the parameters of our muscle model, users can implement a different model, by setting gaintype,
biastype and dyntype of a <a class="reference internal" href="XMLreference.html#actuator-general"><span class="std std-ref">general</span></a> actuator to “user” and providing callbacks at
runtime. Or, leave some of these types set to “muscle” and use our model, while replacing the other components. Note
that tendon geometry computations are still handled by the standard MuJoCo pipeline providing actuator_length,
actuator_velocity and actuator_lengthrange as inputs to the user’s muscle model. Custom callbacks could then simulate
elastic tendons or any other detail we have chosen to omit.</p>
</dd>
</dl>
<p><strong>Relation to OpenSim</strong></p>
<p>The standard software used by researchers in biomechanics is OpenSim. We have designed our muscle model to be similar
to the OpenSim model where possible, while making simplifications which result in significantly faster and more stable
simulations. To help MuJoCo users convert OpenSim models, here we summarize the similarities and differences.</p>
<p>The activation dynamics model is identical to OpenSim, including the default time constants.</p>
<p>The <span class="math">\(\text{\small FLV}\)</span> function is not exactly the same, but both MuJoCo and OpenSim approximate the same
experimental data, so they are very close. For a description of the OpenSim model and summary of relevant experimental
data, see <a class="reference external" href="https://doi.org/10.1115/1.4023390">Millard et al. (2013)</a>.</p>
<p>We assume inelastic tendons while OpenSim can model tendon elasticity. We decided not to do that here, because tendon
elasticity requires fast-equilibrium assumptions which in turn require various tweaks and are prone to simulation
instability. In practice tendons are quite stiff, and their effect can be captured approximately by stretching the
<span class="math">\(\text{FL}\)</span> curve corresponding to the inelastic case (<a class="reference external" href="https://pubmed.ncbi.nlm.nih.gov/2676342/">Zajac (1989)</a>). This can be done in MuJoCo by shortening the muscle operating range.</p>
<p>Pennation angle (i.e., the angle between the muscle and the line of force) is not modeled in MuJoCo and is assumed to
be 0. This effect can be approximated by scaling down the muscle force and also adjusting the operating range.</p>
<p>Tendon wrapping is also more limited in MuJoCo. We allow spheres and infinite cylinders as wrapping objects, and require
two wrapping objects to be separated by a fixed site in the tendon path. This is to avoid the need for iterative
computations of tendon paths. As of MuJoCo 2.0 we also allow “side sites” to be placed inside the sphere or cylinder,
which causes an inverse wrap: the tendon path is constrained to pass through the object instead of going around it. This
can replace torus wrapping objects used in OpenSim to keep the tendon path within a given area. Overall, tendon wrapping
is the most challenging part of converting an OpenSim model to a MuJoCo model, and requires some manual work. On the
bright side, there is a small number of high-quality OpenSim models in use, so once they are converted we are done.</p>
<p>Below we illustrate the four types of tendon wrapping available in MuJoCo 2.0. Note that the curved sections of the
wrapping tendons are rendered as straight, but the geometry pipeline works with the actual curves and computes their
lengths and moments analytically:</p>
<p><a class="reference internal" href="_images/tendonwraps.png"><img alt="image3" src="_images/tendonwraps.png" style="width: 500px;" /></a></p>
</section>
<section id="sensors">
<span id="csensor"></span><h3>Sensors<a class="headerlink" href="#sensors" title="Permalink to this headline">#</a></h3>
<p>MuJoCo can simulate a wide variety of sensors as described in the <a class="reference internal" href="XMLreference.html#sensor"><span class="std std-ref">sensor</span></a> element below.
User sensor types can also be defined, and are evaluated by the callback
<a class="reference internal" href="APIreference/APIglobals.html#mjcb-sensor"><span class="std std-ref">mjcb_sensor</span></a>. Sensors do not affect the simulation. Instead their outputs are
copied in the array mjData.sensordata and are available for user processing.</p>
<p>Here we describe the XML attributes common to all sensor types, so as to avoid repetition later.</p>
<dl class="simple">
<dt><span class="at">name</span>: <span class="at-val">string, optional</span></dt><dd><p>Name of the sensor.</p>
</dd>
<dt><span class="at">noise</span>: <span class="at-val">real, “0”</span></dt><dd><p>The standard deviation of zero-mean Gaussian noise added to the sensor output, when the <span class="at">sensornoise</span>
attribute of <a class="reference internal" href="XMLreference.html#option-flag"><span class="std std-ref">flag</span></a> is enabled. Sensor noise respects the sensor data type:
quaternions and unit vectors remain normalized, non-negative quantities remain non-negative.</p>
</dd>
<dt><span class="at">cutoff</span>: <span class="at-val">real, “0”</span></dt><dd><p>When this value is positive, it limits the absolute value of the sensor output. It is also used to normalize the
sensor output in the sensor data plots in <a class="reference internal" href="programming/samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a>.</p>
</dd>
<dt><span class="at">user</span>: <span class="at-val">real(nuser_sensor), “0 0 …”</span></dt><dd><p>See <a class="reference internal" href="#cuser"><span class="std std-ref">User parameters</span></a>.</p>
</dd>
</dl>
</section>
<section id="composite-objects">
<span id="ccomposite"></span><h3>Composite objects<a class="headerlink" href="#composite-objects" title="Permalink to this headline">#</a></h3>
<p>Composite objects were introduced in MuJoCo 2.0, along with solver optimizations to speed up the simulation of such
objects. They are not new model elements. Instead, they are (large) collections of existing elements designed to
simulate particle systems, ropes, cloth, and soft bodies. These collections are generated by the model compiler
automatically. The user configures the automatic generator on a high level, using the new XML element
<a class="reference internal" href="XMLreference.html#body-composite"><span class="std std-ref">composite</span></a> and its attributes and sub-elements, as described in the XML reference
chapter. If the compiled model is then saved, <span class="el">composite</span> is no longer present and is replaced with the collection
of regular model elements that were automatically generated. So think of it as a macro that gets expanded by the model
compiler.</p>
<p>Composite objects are made up of regular MuJoCo bodies, which we call “element bodies” in this context. The element
bodies are created as children of the body within which <span class="el">composite</span> appears; thus a composite object appears in the
same place in the XML where a regular child body may have been defined. Each automatically-generated element body has a
single geom attached to it, usually a sphere but could also be a capsule or an ellipsoid. Thus the composite object is
essentially a particle system, however the particles can be constrained to move together in ways that simulate various
flexible objects. The initial positions of the element bodies form a regular grid in 1D, 2D or 3D. They could all be
children of the parent body (which can be the world or another regular body; composite objects cannot be nested) and
have joints allowing motion relative to the parent, or they could form a kinematic tree with joints between the element
bodies. They can also be connected with tendons with soft equality constraints on the tendon length, creating the
necessary coupling. Joint equality constraints are also used in some cases. The <span class="at">solref</span> and <span class="at">solimp</span> attributes
of these equality constraints can be adjusted by the user, thereby adjusting the softness and flexibility of the
composite objects.</p>
<p>In addition to setting up the physics, the composite object generator creates suitable rendering. 2D and 3D objects
can be rendered as <a class="reference internal" href="XMLreference.html#asset-skin"><span class="std std-ref">skins</span></a> which are also new in MuJoCo 2.0. The skin is generated
automatically, and can be textured as well as subdivided using bi-cubic interpolation. The actual physics and in
particular the collision detection are based on the element bodies and their geoms, while the skin is purely a
visualization object. Yet in most situations we prefer to look at the skin representation. To facilitate this, the
generator places all geoms, sites and tendons in group 3 whose visualization is disabled by default. So when you load
a 2D grid for example, you will see a continuous flexible surface and not a collection of spheres connected with
tendons. However when fine-tuning the model and trying to understand the physics behind it, it is useful to be able to
render the spheres and tendons. To switch the rendering style, disable the rendering of skins and enable group 3 for
geoms and tendons (note that starting with MuJoCo 2.0 we have added a group property to sites, tendons and joints in
addition to geoms).</p>
<p>We have designed the composite object generator to have intuitive high-level controls as much as possible, but at the
same time it exposes a large number of options that interact with each other and can profoundly affect the resulting
physics. So at some point users should read the <a class="reference internal" href="XMLreference.html#body-composite"><span class="std std-ref">reference documentation</span></a> carefully.
As a quick start though, MuJoCo 2.0 comes with an example of each composite object type. Below we go over these
examples and explain the less obvious aspects. In all examples we have a static scene which is included in the model,
followed by a single composite object. The static scene has a mocap body (large capsule) that can be moved around with
the mouse to probe the behavior of the system. The XML snippets below are just the definition of the composite object;
see the XML model files in the distribution for the complete examples.</p>
<p><strong>Particle</strong>.</p>
<p><a class="reference internal" href="_images/particle.png"><img alt="image4" src="_images/particle.png" style="height: 300px;" /></a> <a class="reference internal" href="_images/particle2.png"><img alt="image5" src="_images/particle2.png" style="height: 300px;" /></a></p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;worldbody&gt;</span>
<span class="w">  </span><span class="nt">&lt;composite</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;particle&quot;</span><span class="w"> </span><span class="na">count=</span><span class="s">&quot;10 10 10&quot;</span><span class="w"> </span><span class="na">spacing=</span><span class="s">&quot;0.07&quot;</span><span class="w"> </span><span class="na">offset=</span><span class="s">&quot;0 0 1&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">size=</span><span class="s">&quot;.02&quot;</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;.8 .2 .1 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;/composite&gt;</span>
<span class="nt">&lt;/worldbody&gt;</span>
</pre></div>
</div>
<p>The above XML is all it takes to create a system with 1000 particles with initial positions on a 10-10-10 grid, and
set the size, color, spacing and offset of the particles. The resulting element bodies become children of the world
body. One could adjust many other properties including the softness of the contacts and the joint attributes. The plot
on the right shows the joints. Each element body has 3 orthogonal slider joints, allowing it to translate but not
rotate. The idea is that particles should have position but no orientation. MuJoCo bodies always have orientation,
however by using only slider joints we do not allow the orientation to change. The geom defaults are adjusted
automatically so that they make frictionless contacts with each other and with the rest of the model. So this system
has 1000 bodies (each with a geom), 3000 degrees of freedom and around 1000 active contacts. Evaluating the dynamics
takes around 1 ms on a single core of a modern processor. As with most other MuJoCo models, the soft constraints allow
simulation at much larger timesteps (this model is stable at 30 ms timestep and even higher).</p>
<p><strong>1D grid</strong>.</p>
<p><a class="reference internal" href="_images/grid1.png"><img alt="image6" src="_images/grid1.png" style="height: 200px;" /></a> <a class="reference internal" href="_images/grid1pin.png"><img alt="image7" src="_images/grid1pin.png" style="height: 200px;" /></a></p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;composite</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;grid&quot;</span><span class="w"> </span><span class="na">count=</span><span class="s">&quot;20 1 1&quot;</span><span class="w"> </span><span class="na">spacing=</span><span class="s">&quot;0.045&quot;</span><span class="w"> </span><span class="na">offset=</span><span class="s">&quot;0 0 1&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;joint</span><span class="w"> </span><span class="na">kind=</span><span class="s">&quot;main&quot;</span><span class="w"> </span><span class="na">damping=</span><span class="s">&quot;0.001&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;tendon</span><span class="w"> </span><span class="na">kind=</span><span class="s">&quot;main&quot;</span><span class="w"> </span><span class="na">width=</span><span class="s">&quot;0.01&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">size=</span><span class="s">&quot;.02&quot;</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;.8 .2 .1 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;pin</span><span class="w"> </span><span class="na">coord=</span><span class="s">&quot;1&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;pin</span><span class="w"> </span><span class="na">coord=</span><span class="s">&quot;13&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/composite&gt;</span>
</pre></div>
</div>
<p>The grid type can create 1D or 2D grids, depending on the <span class="at">count</span> attribute. Here we illustrate 1D grids. These
are strings of spheres connected with tendons whose length is soft-equality-constrained. The softness can be adjusted.
Similar to particles, the element bodies here have slider joints but no rotational joints. The plot on the right
illustrates pinning. The <span class="el">pin</span> sub-element is used to specify the grid coordinates of the pinned bodies, and the
model compiler does not generate joints for these bodies, thereby fixing them rigidly to the parent body (in this case
the world). This makes the string in the right plot hang in space. The same mechanism can be used to model a whip for
example; in that case the parent body would be moving, and the first element body would be pinned to the parent.</p>
<p><strong>2D grid</strong>.</p>
<p><a class="reference internal" href="_images/grid2.png"><img alt="image8" src="_images/grid2.png" style="height: 300px;" /></a> <a class="reference internal" href="_images/grid2pin.png"><img alt="image9" src="_images/grid2pin.png" style="height: 300px;" /></a></p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;composite</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;grid&quot;</span><span class="w"> </span><span class="na">count=</span><span class="s">&quot;9 9 1&quot;</span><span class="w"> </span><span class="na">spacing=</span><span class="s">&quot;0.05&quot;</span><span class="w"> </span><span class="na">offset=</span><span class="s">&quot;0 0 1&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;skin</span><span class="w"> </span><span class="na">material=</span><span class="s">&quot;matcarpet&quot;</span><span class="w"> </span><span class="na">inflate=</span><span class="s">&quot;0.001&quot;</span><span class="w"> </span><span class="na">subgrid=</span><span class="s">&quot;3&quot;</span><span class="w"> </span><span class="na">texcoord=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">size=</span><span class="s">&quot;.02&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;pin</span><span class="w"> </span><span class="na">coord=</span><span class="s">&quot;0 0&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;pin</span><span class="w"> </span><span class="na">coord=</span><span class="s">&quot;8 0&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/composite&gt;</span>
</pre></div>
</div>
<p>A 2D grid can be used to simulate cloth. What it really simulates is a 2D grid of spheres connected with
equality-constrained tendons (not shown). The model compiler can also generate skin, enabled with the <span class="el">skin</span>
sub-element in the above XML. Some of the element bodies can also be pinned, similar to 1D grids but using two grid
coordinates. The plot on the right shows a cloth pinned to the world body at the two corners, and draping over our
capsule probe. The skin on the right is subdivided using bi-cubic interpolation, which increases visual quality in the
absence of textures. When textures are present (left) the benefits of subdivision are less visible.</p>
<p><strong>Rope and loop</strong>.</p>
<p><a class="reference internal" href="_images/rope.png"><img alt="image10" src="_images/rope.png" style="height: 200px;" /></a> <a class="reference internal" href="_images/loop.png"><img alt="image11" src="_images/loop.png" style="height: 200px;" /></a></p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;body</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;B10&quot;</span><span class="w"> </span><span class="na">pos=</span><span class="s">&quot;0 0 1&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;freejoint/&gt;</span>
<span class="w">  </span><span class="nt">&lt;composite</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;rope&quot;</span><span class="w"> </span><span class="na">count=</span><span class="s">&quot;21 1 1&quot;</span><span class="w"> </span><span class="na">spacing=</span><span class="s">&quot;0.04&quot;</span><span class="w"> </span><span class="na">offset=</span><span class="s">&quot;0 0 2&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;joint</span><span class="w"> </span><span class="na">kind=</span><span class="s">&quot;main&quot;</span><span class="w"> </span><span class="na">damping=</span><span class="s">&quot;0.005&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;capsule&quot;</span><span class="w"> </span><span class="na">size=</span><span class="s">&quot;.01 .015&quot;</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;.8 .2 .1 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;/composite&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></div>
</div>
<p>The remaining composite object types create kinematic trees of element bodies, and the parent body becomes the root of
the tree. This is why <span class="el">composite</span> appears inside a moving body, and not inside the world body as in particle and
grid objects. If it appeared inside the world body, the root of the composite object would not move. Unlike grids and
particles, the orientation of the element bodies here can change. The kinematic tree is constructed using (mostly)
hinge joints. In the case of rope and loop objects illustrated here, the tree is a chain. Note the naming of the
parent body. This name must correspond to one of the automatically-generated names of the element bodies. This
mechanism is used to specify where the composite object should attach to the parent. Compared to 1D grids, the rope
and loop are less jittery and can use capsule and ellipsoid geoms in addition to spheres (thus filling the gaps for
collision detection). However this comes at a price. Because we have long kinematic chains, the resulting differential
equations become stiff and can no longer be integrated at large timesteps. The examples we provide illustrate
comfortable timesteps where the models are stable. The rope can be easily tied into a knot using mouse perturbations,
as shown in the left plot. Using a larger number of smaller elements makes knots and other manipulations even easier.
The loop is similar to a rope but the first and last element bodies are connected with an equality constraint.</p>
<p><strong>Cloth</strong>.</p>
<p><a class="reference internal" href="_images/cloth.png"><img alt="image12" src="_images/cloth.png" style="height: 300px;" /></a> <a class="reference internal" href="_images/cloth2.png"><img alt="image13" src="_images/cloth2.png" style="height: 300px;" /></a></p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;body</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;B3_5&quot;</span><span class="w"> </span><span class="na">pos=</span><span class="s">&quot;0 0 1&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;freejoint/&gt;</span>
<span class="w">  </span><span class="nt">&lt;composite</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;cloth&quot;</span><span class="w"> </span><span class="na">count=</span><span class="s">&quot;9 9 1&quot;</span><span class="w"> </span><span class="na">spacing=</span><span class="s">&quot;0.05&quot;</span><span class="w"> </span><span class="na">flatinertia=</span><span class="s">&quot;0.01&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;joint</span><span class="w"> </span><span class="na">kind=</span><span class="s">&quot;main&quot;</span><span class="w"> </span><span class="na">damping=</span><span class="s">&quot;0.001&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;skin</span><span class="w"> </span><span class="na">material=</span><span class="s">&quot;matcarpet&quot;</span><span class="w"> </span><span class="na">texcoord=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">inflate=</span><span class="s">&quot;0.005&quot;</span><span class="w"> </span><span class="na">subgrid=</span><span class="s">&quot;2&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;capsule&quot;</span><span class="w"> </span><span class="na">size=</span><span class="s">&quot;0.015 0.01&quot;</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;.8 .2 .1 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;/composite&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></div>
</div>
<p>The cloth type is an alternative to a 2D grid, and has somewhat different properties. Similar to rope vs. 1D grid, the
cloth is less jittery than a 2D grid and can also fill collision holes better. This is done by using capsules or
ellipsoids, and arranging them in the pattern shown on the right. The geom capsules are shown in red, the kinematic
tree in thick blue, the equality-constrained tendons holding the cloth together in thin gray, and the joints in cyan.
The element body corresponding to the parent body has a floating joint rendered as a cube, while the rest of the tree
is constructed using pairs of hinge joints that form universal joints. Note the naming of the parent body: similar to
rope, it must coincide with one of the automatically-generated element body names in the composite object. Explicit
pinning is not possible. However if the parent is a static body, the cloth is essentially pinned but only at one
point. Similar to rope, the cloth object involves long kinematic chains that require relatively small timesteps and
some damping for stable integration. The parameters can be found in the XML model files in the software distribution.</p>
<p><strong>Box</strong>.</p>
<p><a class="reference internal" href="_images/box.png"><img alt="image14" src="_images/box.png" style="height: 300px;" /></a> <a class="reference internal" href="_images/box2.png"><img alt="image15" src="_images/box2.png" style="height: 300px;" /></a></p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;body</span><span class="w"> </span><span class="na">pos=</span><span class="s">&quot;0 0 1&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;freejoint/&gt;</span>
<span class="w">  </span><span class="nt">&lt;composite</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;box&quot;</span><span class="w"> </span><span class="na">count=</span><span class="s">&quot;7 7 7&quot;</span><span class="w"> </span><span class="na">spacing=</span><span class="s">&quot;0.04&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;skin</span><span class="w"> </span><span class="na">texcoord=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">material=</span><span class="s">&quot;matsponge&quot;</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;.7 .7 .7 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;capsule&quot;</span><span class="w"> </span><span class="na">size=</span><span class="s">&quot;.015 0.05&quot;</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;.8 .2 .1 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;/composite&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></div>
</div>
<p>The box type, as well as the cylinder and ellipsoid types below, are used to model soft 3D objects. The element bodies
form a grid along the outer shell, thus the number of element bodies scales with the square of the linear dimension.
This is much more efficient than simulating a 3D grid. The parent body within which <span class="el">composite</span> appears is at the
center of the soft object. All element bodies are children of the parent. Each element body has a single sliding joint
pointing away from the parent. These joints allow the surface of the soft object to compress and expand at any point.
The joints are equality-constrained to their initial position, so as to maintain the shape. In addition each joint is
equality-constrained to its neighbor joints, so that when the soft objects deforms, the deformation is smooth.
Finally, there is a tendon equality constraint specifying that the sum of all joints should remain constant. This
attempts to preserve the volume of the soft object approximately. If the object is squeezed from all sides it will
compress and the volume will decrease, but otherwise some element bodies will stick out to compensate for squeezing
elsewhere. The plot on the left shows this effect; we are using the capsule probe to compress one corner, and the
opposite sides of the cube expand a bit, while the deformations remain smooth. The <span class="at">count</span> attribute determines
the number of element bodies in each dimension, so if the counts are different the resulting object will be a
rectangular box and not a cube. The geoms attached to the element bodies can be spheres, capsules or ellipsoids.
Spheres are faster for collision detection, but they result in a thin shell, allowing other bodies to “get under the
skin” of the soft object. When capsules or ellipsoids are used, they are automatically oriented so that the long axis
points to the outside, thus creating a thicker shell which is harder to penetrate.</p>
<p><strong>Cylinder and ellipsoid</strong>.</p>
<p><a class="reference internal" href="_images/cylinder.png"><img alt="image16" src="_images/cylinder.png" style="height: 300px;" /></a> <a class="reference internal" href="_images/ellipsoid.png"><img alt="image17" src="_images/ellipsoid.png" style="height: 300px;" /></a></p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;body</span><span class="w"> </span><span class="na">pos=</span><span class="s">&quot;0 0 1&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;freejoint/&gt;</span>
<span class="w">  </span><span class="nt">&lt;composite</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;ellipsoid&quot;</span><span class="w"> </span><span class="na">count=</span><span class="s">&quot;5 7 9&quot;</span><span class="w"> </span><span class="na">spacing=</span><span class="s">&quot;0.05&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;skin</span><span class="w"> </span><span class="na">texcoord=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">material=</span><span class="s">&quot;matsponge&quot;</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;.7 .7 .7 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;capsule&quot;</span><span class="w"> </span><span class="na">size=</span><span class="s">&quot;.015 0.05&quot;</span><span class="w"> </span><span class="na">rgba=</span><span class="s">&quot;.8 .2 .1 1&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;/composite&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></div>
</div>
<p>Cylinders and ellipsoids are created in the same way as boxes. The only difference is that the reference positions of
the element bodies (relative to the parent) are projected on a cylinder or ellipsoid, with size implied by the
<span class="at">count</span> attribute. The automatic skin generator is aware of the smooth surfaces, and adjusts the skin normals
accordingly. In the plots we have used the capsule probe to press on each body, then paused the simulation and moved the
probe away (which is possible because the probe is a mocap body which can move independent of the physics). In this way
we can see the indentation made by the probe, and the resulting deformation in the rest of the body. By changing the
solref and solimp attributes of the equality constraints that hold the soft object together, one can adjust the behavior
of the system making it softer or harder, damped or springy, etc. Note that box, cylinder and ellipsoid objects do not
involve long kinematic chains, and can be simulated at large timesteps - similar to particle and grid, and unlike rope
and cloth.</p>
</section>
<section id="including-files">
<span id="cinclude"></span><h3>Including files<a class="headerlink" href="#including-files" title="Permalink to this headline">#</a></h3>
<p>MJCF files can include other XML files using the <a class="reference internal" href="XMLreference.html#include"><span class="std std-ref">include</span></a> element. Mechanistically, the
parser replaces the DOM node corresponding to the include element in the master file with the list of XML elements
that are children of the top-level element in the included file. The top-level element itself is discarded, because it
is a grouping element for XML purposes and would violate the MJCF format if included.</p>
<p>This functionality enables modular MJCF models; see the MPL family of models in the model library. One example of
modularity is constructing a model of a robot (which tends to be elaborate) and then including it in multiple
“scenes”, i.e., MJCF models defining the objects in the robot’s environment. Another example is creating a file with
commonly used assets (say materials with carefully adjusted rgba values) and including it in multiple models which
reference those assets.</p>
<p>The included files are not required to be valid MJCF files on their own, but they usually are. Indeed we have designed
this mechanism to allow MJCF models to be included in other MJCF models. To make this possible, repeated MJCF sections
are allowed even when that does not make sense semantically in the context of a single model. For example, we allow
the kinematic tree to have multiple roots (i.e., multiple <span class="el">worldbody</span> elements) which are merged automatically by
the parser. Otherwise including robots into scenes would be impossible.</p>
<p>The flexibility of repeated MCJF sections comes at a price: global settings that apply to the entire model, such as
the <span class="at">angle</span> attribute of <a class="reference internal" href="XMLreference.html#compiler"><span class="std std-ref">compiler</span></a> for example, can be defined multiple times.
MuJoCo allows this, and uses the last definition encountered in the composite model, after all include elements have
been processed. So if model A is defined in degrees and model B is defined in radians, and A is included in B after
the <span class="el">compiler</span> element in B, the entire composite model will be treated as if it was defined in degrees - leading
to undesirable consequences in this case. The user has to make sure that models included in each other are compatible
in this sense; local vs. global coordinates is another compatibility requirement.</p>
<p>Finally, as explained next, element names must be unique among all elements of the same type. So for example if the
same geom name is used in two models, and one model is included in the other, this will result in compile error.
Including the same XML file more than once is a parsing error. The reason for this restriction is that we want to
avoid repeated element names as well as infinite recursion caused by inclusion.</p>
</section>
<section id="naming-elements">
<span id="cname"></span><h3>Naming elements<a class="headerlink" href="#naming-elements" title="Permalink to this headline">#</a></h3>
<p>Most model elements in MJCF can have names. They are defined with the attribute <span class="at">name</span> of the corresponding XML
element. When a given model element is named, its name must be unique among all elements of the same type. Names are
case-sensitive. They are used at compile time to reference the corresponding element, and are also saved in mjModel
for user convenience at runtime.</p>
<p>The name is usually an optional attribute. We recommend leaving it undefined (so as to keep the model file shorter)
unless there is a specific reason to define it. There can be several such reasons:</p>
<ul class="simple">
<li><p>Some model elements need to reference other elements as part of their creation. For example, a spatial tendon needs
to reference sites in order to specify the via points it passes through. Referencing can only be done by name. Note
that assets exist for the sole purpose of being referenced, so they must have a name, however it can be omitted and
set implicitly from the corresponding file name.</p></li>
<li><p>The visualizer offers the option to label all model elements of a given type. When a name is available, it is printed
next to the object in the 3D view; otherwise a generic label in the format “body 7” is printed.</p></li>
<li><p>The function <a class="reference internal" href="APIreference/APIfunctions.html#mj-name2id"><span class="std std-ref">mj_name2id</span></a> returns the index of the model element with given type and
name. Conversely, the function <a class="reference internal" href="APIreference/APIfunctions.html#mj-id2name"><span class="std std-ref">mj_id2name</span></a> returns the name given the index. This
is useful for custom computations involving a model element that is identified by its name in the XML (as opposed to
relying on a fixed index which can change when the model is edited).</p></li>
<li><p>The model file could in principle become more readable by naming certain elements. Keep in mind however that XML
itself has a commenting mechanism, and that mechanism is more suitable for achieving readability - especially since
most text editors provide syntax highlighting which detects XML comments.</p></li>
</ul>
</section>
<section id="urdf-extensions">
<span id="curdf"></span><h3>URDF extensions<a class="headerlink" href="#urdf-extensions" title="Permalink to this headline">#</a></h3>
<p>The Unified Robot Description Format (URDF) is a popular XML file format in which many existing robots have been
modeled. This is why we have implemented support for URDF even though it can only represent a subset of the model
elements available in MuJoCo. In addition to standard URDF files, MuJoCo can load files that have a custom (from the
viewpoint of URDF) <span class="el">mujoco</span> element as a child of the top-level element <span class="el">robot</span>. This custom element can have
sub-elements <a class="reference internal" href="XMLreference.html#compiler"><span class="std std-ref">compiler</span></a>, <a class="reference internal" href="XMLreference.html#option"><span class="std std-ref">option</span></a>,
<a class="reference internal" href="XMLreference.html#size"><span class="std std-ref">size</span></a> with the same functionality as in MJCF, except that the default compiler settings
are modified so as to accomodate the URDF modeling convention. The <a class="reference internal" href="XMLreference.html#compiler"><span class="std std-ref">compiler</span></a> extension
in particular has proven very useful, and indeed several of its attributes were introduced because a number of
existing URDF models have non-physical dynamics parameters which MuJoCo’s built-in compiler will reject if left
unmodified. This extension is also needed to specify mesh directories.</p>
<p>Note that the while MJCF models are checked against a custom XML schema by the parser, URDF models are not. Even the
MuJoCo-specific elements embedded in the URDF file are not checked. As a result, mis-typed attribute names are
silently ignored, which can result in major confusion if the typo remains unnoticed.</p>
<p>Here is an example extension section of a URDF model:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;robot</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;darwin&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;mujoco&gt;</span>
<span class="w">    </span><span class="nt">&lt;compiler</span><span class="w"> </span><span class="na">meshdir=</span><span class="s">&quot;../mesh/darwin/&quot;</span><span class="w"> </span><span class="na">balanceinertia=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">discardvisual=</span><span class="s">&quot;false&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;/mujoco&gt;</span>
<span class="w">  </span><span class="nt">&lt;link</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MP_BODY&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span>...
<span class="nt">&lt;/robot&gt;</span>
</pre></div>
</div>
<p>The above extensions make URDF more usable but still limited. If the user wants to build models taking full advantage of
MuJoCo and at the same time maintain URDF compatibility, we recommend the following procedure. Introduce extensions in
the URDF as needed, load it and save it as MJCF. Then add information to the MJCF using
<a class="reference internal" href="XMLreference.html#include"><span class="std std-ref">include</span></a> elements whenever possible. In this way, if the URDF is modified, the
corresponding MJCF can be easily re-created. In our experience though, URDF files tend to be static while MJCF files are
often edited. Thus in practice it is usually sufficient to convert the URDF to MJCF once and after that only work with
the MJCF.</p>
</section>
<section id="mocap-bodies">
<span id="cmocap"></span><h3>MoCap bodies<a class="headerlink" href="#mocap-bodies" title="Permalink to this headline">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">mocap</span></code> bodies are static children of the world (i.e., have no joints) and their <span class="at">mocap</span> attribute is set to
“true”. They can be used to input a data stream from a motion capture device into a MuJoCo simulation. Suppose you are
holding a VR controller, or an object instrumented with motion capture markers (e.g. Vicon), and want to have a
simulated object moving in the same way but also interacting with other simulated objects. There is a dilemma here:
virtual objects cannot push on your physical hand, so your hand (and thereby the object you are controlling) can
violate the simulated physics. But at the same time we want the resulting simulation to be reasonable. How do we do
this?</p>
<p>The first step is to define a mocap body in the MJCF model, and implement code that reads the data stream at runtime and
sets mjModel.mocap_pos and mjModel.mocap_quat to the position and orientation received from the motion capture system.
The <a class="reference internal" href="programming/samples.html#sasimulate"><span class="std std-ref">simulate.cc</span></a> code sample uses the mouse as a motion capture device, allowing the user to move
mocap bodies around:</p>
<p><a class="reference internal" href="_images/particle.gif"><img alt="particle" src="_images/particle.gif" style="width: 270px;" /></a></p>
<p>The key thing to understand about mocap bodies is that the simulator treats them as being fixed. We are causing them
to move from one simulation time step to the next by updating their position and orientation directly, but as far as
the physics model is concerned their position and orientation are constant. So what happens if we make contact with a
regular dynamic body, as in the composite object examples provided with the MuJoCo 2.0 distribution (recall that in
those example we have a capsule probe which is a mocap body that we move with the mouse). A contact between two
regular bodies will experience penetration as well as relative velocity, while contact with a mocap body is missing
the relative velocity component because the simulator does not know that the mocap body itself is moving. So the
resulting contact force is smaller and it takes longer for the contact to push the dynamic object away. Also, in more
complex simulations the fact that we are doing something inconsistent with the physics can cause instabilities.</p>
<p>There is however a better-behaved alternative. In addition to the mocap body, we include a second regular body and
connect it to the mocap body with a weld equality constraint. In the plots below, the pink box is the mocap body and
it is connected to the base of the hand. In the absence of other constraints, the hand tracks the mocap body almost
perfectly (and much better than a spring-damper would) because the constraints are handled implicitly and can produce
large forces without destabilizing the simulation. But if the hand is forced to make contact with the table for example
(right plot) it cannot simultaneously respect the contact constraint and track the mocap body. This is because the
mocap body is free to go through the table. So which constraint wins? That depends on the softness of the weld
constraint realtive to the contact constraint. The corresponding <span class="at">solref</span> and <span class="at">solimp</span> parameters need to be
adjusted so as to achieve the desired trade-off. See the Modular Prosthetic Limb (MPL) hand model available on the
MuJoCo Forum for an example; the plots below are generated with that model.</p>
<p><a class="reference internal" href="_images/mocap1.png"><img alt="image18" src="_images/mocap1.png" style="height: 250px;" /></a> <a class="reference internal" href="_images/mocap2.png"><img alt="image19" src="_images/mocap2.png" style="height: 250px;" /></a></p>
</section>
<section id="memory-allocation">
<span id="csize"></span><h3>Memory allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this headline">#</a></h3>
<p>MuJoCo preallocates all the memory needed at runtime in <a class="reference internal" href="APIreference/APItypes.html#mjdata"><span class="std std-ref">mjData</span></a>, and does not access the heap allocator after
model creation. Memory in <a class="reference internal" href="APIreference/APItypes.html#mjdata"><span class="std std-ref">mjData</span></a> is allocated by <a class="reference internal" href="APIreference/APIfunctions.html#mj-makedata"><span class="std std-ref">mj_makeData</span></a> in two contiguous blocks:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mjData.buffer</span></code> contains fixed-size arrays.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mjData.arena</span></code> contains dynamically-sized arrays.</p></li>
</ul>
<p>There are two types of dynamic arrays allocated in the <code class="docutils literal notranslate"><span class="pre">arena</span></code> memory space.</p>
<ul class="simple">
<li><p>contacts and constraint-related arrays are laid out from the beginning of the <code class="docutils literal notranslate"><span class="pre">arena</span></code>.</p></li>
<li><p><a class="reference internal" href="programming/simulation.html#sistack"><span class="std std-ref">stack</span></a> arrays are laid out from the end of the <code class="docutils literal notranslate"><span class="pre">arena</span></code>.</p></li>
</ul>
<p>By allocating dynamic quantities from both sides of the <code class="docutils literal notranslate"><span class="pre">arena</span></code> space, variable-sized memory allocation is controlled
by a single number: the <span class="at">memory</span> attribute of the <a class="reference internal" href="XMLreference.html#size"><span class="std std-ref">size</span></a> MJCF element. Unlike the fixed-size arrays in
the <code class="docutils literal notranslate"><span class="pre">buffer</span></code>, variable-sized arrays in the arena can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, for example after a call to <a class="reference internal" href="APIreference/APIfunctions.html#mj-resetdata"><span class="std std-ref">mj_resetData</span></a>.
When <code class="docutils literal notranslate"><span class="pre">arena</span></code> memory runs out, one of three things will happen, depending on the type of memory requested:</p>
<ul class="simple">
<li><p>If memory runs out during contact allocation, a warning will be raised and subsequent contacts will not be added in
this step, but simulation continues as usual.</p></li>
<li><p>If memory runs out during constraint-related allocation, a warning will be raised and the constraint solver will be
disabled in this step, but simulation continues as usual. Note that physics without the constraint solver will
generally be very different, but allowing the simulation to continue can still be useful, e.g. during
scene initialization when many bodies are temporarily overlapping.</p></li>
<li><p>If memory runs out during stack array allocation, a hard error will occur.</p></li>
</ul>
<p>Unlike the size of the <code class="docutils literal notranslate"><span class="pre">buffer</span></code>, the size of the <code class="docutils literal notranslate"><span class="pre">arena</span></code> cannot be pre-computed, since the number of contacts and
stack usage is not known in advance. So how should one choose it? The following simple heuristic is currently used,
though it may be improved in the future: enough memory is allocated for 100 contacts and 500 scalar constraints, under
worst-case conditions. If this heuristic is insufficient, we recommend the following procedure. Increase the <code class="docutils literal notranslate"><span class="pre">arena</span></code>
memory significantly using the <span class="at">memory</span> attribute, and inspect the actual memory used at runtime.
<code class="docutils literal notranslate"><span class="pre">mjData.maxuse_arena</span></code> keeps track of the maximum <code class="docutils literal notranslate"><span class="pre">arena</span></code> memory utilization since the last reset. The <a class="reference internal" href="programming/samples.html#sasimulate"><span class="std std-ref">simulate</span></a> viewer shows this number as a fraction of the total arena space (in the info window in the lower-left
corner). So one can start with a large number, simulate for a while, and if the fractions are small go back to the XML
and reduce the allocation size. Keep in mind though that memory utilization can change dramatically in the course of the
simulation, depending on how many constraints are active and which constraint solver is used. The CG solver is the most
memory efficient, followed by the Newton solver, while the PGS solver is the most memory intensive. When we design
models, we usually aim for 50% utilization in the worst-case scenario encountered while exploring the model. If you only
intend to use the CG solver, you can get away with significantly smaller arena allocation.</p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>Memory allocation behaviour changed in MuJoCo 2.3.0. Before this version, the <span class="at">njmax</span>, <span class="at">nconmax</span> and
<span class="at">nstack</span> attributes of the <a class="reference internal" href="XMLreference.html#size"><span class="std std-ref">size</span></a> MJCF element had the semantics of maximum memory allocated for
contacts, constraints and stack, respectively. If you are using an earlier version of MuJoCo, please switch to an
<a class="reference external" href="https://mujoco.readthedocs.io/en/2.2.2/modeling.html#model-sizes">earlier</a> documentation version to read about the
previous behaviour.</p>
</div>
</section>
</section>
<section id="tips-and-tricks">
<span id="tips"></span><h2>Tips and tricks<a class="headerlink" href="#tips-and-tricks" title="Permalink to this headline">#</a></h2>
<p>Here we provide guidance on how to accomplish some common modeling tasks. There is no new material here, in the sense
that everything in this section can be inferred from the rest of the documentation. Nevertheless the inference process
is not always obvious, so it may be useful to have it spelled out.</p>
<section id="backlash">
<span id="cbacklash"></span><h3>Backlash<a class="headerlink" href="#backlash" title="Permalink to this headline">#</a></h3>
<p>Backlash is present in many robotic joints. It is usually caused by small gaps between gears in the gearbox, but could
also be caused by some sloppiness in the joint mechanism. The effect is that the motor can turn for a small angle before
the joint turns, or vice versa (when external force is applied on the joint). Backlash can be modeled in MuJoCo as
follows. Instead of having a single hinge joint within the body, define two hinge joints with identical position and
orientation:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;body&gt;</span>
<span class="w">  </span><span class="nt">&lt;joint</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;J1&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;hinge&quot;</span><span class="w"> </span><span class="na">pos=</span><span class="s">&quot;0 0 0&quot;</span><span class="w"> </span><span class="na">axis=</span><span class="s">&quot;0 0 1&quot;</span><span class="w"> </span><span class="na">armature=</span><span class="s">&quot;0.01&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;joint</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;J2&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;hinge&quot;</span><span class="w"> </span><span class="na">pos=</span><span class="s">&quot;0 0 0&quot;</span><span class="w"> </span><span class="na">axis=</span><span class="s">&quot;0 0 1&quot;</span><span class="w"> </span><span class="na">limited=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">range=</span><span class="s">&quot;-1 1&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></div>
</div>
<p>Thus the overall rotation of the body relative to its parent is J1+J2. Now define an actuator acting only on J1. The
small joint range on J2 keeps it near 0, yet allows it to move a bit in the direction of the force acting on it,
producing a backlash effect. Note the <span class="at">armature</span> attribute in J1. Without it the joint-space inertia matrix
will be singular, because the two joints could accelerate in opposite directions without encountering any inertia. The
physical gears responsible for the backlash actually have rotational inertia (which we call armature) so this is a
realistic modeling approach. The numbers in this example should be adjusted to obtain the desired behavior. The
<span class="at">solref</span> and <span class="at">solimp</span> parameters of the joint limit constraint could also be adjusted, to make the
backlash rotation end at a softer or a harder limit.</p>
<p>Instead of specifying joint limits in J2, one can specify a soft equality constraint keeping J2=0. The constraint
impedance function should then be adjusted so the constraint is weak near J2=0 and gets stronger away from 0. The new
parameterization of impedance functions shown in <a class="reference internal" href="#csolver"><span class="std std-ref">Solver parameters</span></a> enables this. Compared to joint
limits, the equality constraint approach will generate a softer transition between the backlash regime and the limit
regime. It will also be active all the time, which is convenient in user code that needs the constraint violation or
constraint force as input.</p>
</section>
<section id="damping">
<span id="cdamping"></span><h3>Damping<a class="headerlink" href="#damping" title="Permalink to this headline">#</a></h3>
<p>Damping generates a force proportional to velocity and opposite to it. In a physical system damping always increases
stability. But this is only because the Universe is equipped with an ideal continuous-time integrator which does not
accumulate errors due to time discretization. In a computer simulation where time is discretized, large damping can
destabilize the system because of integration errors. This was already discussed in the
<a class="reference internal" href="computation.html#gepassive"><span class="std std-ref">Computation</span></a> chapter.</p>
<p>The standard approach to reducing integration errors is to reduce the timestep or use the Runge-Kutta integrator, both
of which are effective but slow down the simulation. An alternative approach is to put all damping in the joints and
use the Euler integrator. In that case damping forces are integrated implicitly - meaning that the inertia matrix is
adjusted and re-factorized internally as part of the velocity update, in a way transparent to the user. Implicit
integration is much more stable than explicit integration, allowing substantially larger time steps. Note that the
Runge-Kutta integrator is explicit, and so is Euler except for the way it treats damping forces. Ideally we would have
a fully implicit integrator, but there is no publicly available physics engine that currently has such an integrator.
It is on our todo list for a future MuJoCo release.</p>
<p>Given this state of affairs, joint damping is better behaved than damping in tendons or actuators, because the latter
are not integrated implicitly. Now consider a velocity servo producing force:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">force</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="p">(</span><span class="n">desired_velocity</span> <span class="o">-</span> <span class="n">current_velocity</span><span class="p">)</span>
</pre></div>
</div>
<p>This can be modeled as a velocity actuator, however such an actuator adds damping to the system and could cause
instability when the gain is high. Instead we could split the above force in two terms. For the first term, define a
motor which generates force = gain * desired_velocity, by treating desired_velocity as the control signal. For the
second term, add damping in the joint, with damping coefficient equal to the above servo gain. Now the overall force is
the same yet the damping component of the force is integrated implicitly.</p>
</section>
<section id="restitution">
<span id="crestitution"></span><h3>Restitution<a class="headerlink" href="#restitution" title="Permalink to this headline">#</a></h3>
<p>MuJoCo 2.0 introduced a new mechanism for specifying <span class="at">solref</span> as explained in <a class="reference internal" href="#csolver"><span class="std std-ref">Solver parameters</span></a>.
When both numbers are non-positive, they are interpreted as (-stiffness, -damping) and scaled by the constraint
impedance. To achieve perfect restitution for contacts and other constraints, set stiffness to some reasonably large
value and damping to zero. Below is an example of a sphere bouncing on a plane with restitution coefficient of 1, so
that the energy before and after contact is approximately preserved. It is not exactly preserved because the contact
itself is soft and takes several time steps, and the (implicit) deformations during those time steps are not exactly
energy-preserving. But the overall effect is that the ball bounces for a very long time without changing its peak height
in a visible way, and the energy fluctuates around the initial value instead of drifting.</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;worldbody&gt;</span>
<span class="w">  </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;plane&quot;</span><span class="w"> </span><span class="na">size=</span><span class="s">&quot;1 1 .1&quot;</span><span class="nt">/&gt;</span>

<span class="w">  </span><span class="nt">&lt;body</span><span class="w"> </span><span class="na">pos=</span><span class="s">&quot;0 0 1&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;freejoint/&gt;</span>
<span class="w">    </span><span class="nt">&lt;geom</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;sphere&quot;</span><span class="w"> </span><span class="na">size=</span><span class="s">&quot;0.1&quot;</span><span class="w"> </span><span class="na">solref=</span><span class="s">&quot;-1000 0&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/worldbody&gt;</span>
</pre></div>
</div>
</section>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="XMLreference.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">XML Reference</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="computation.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Computation</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; DeepMind Technologies Limited
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Modeling</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#loading-models">Loading models</a></li>
<li><a class="reference internal" href="#compiling-models">Compiling models</a></li>
<li><a class="reference internal" href="#saving-models">Saving models</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mjcf-mechanisms">MJCF Mechanisms</a><ul>
<li><a class="reference internal" href="#kinematic-tree">Kinematic tree</a></li>
<li><a class="reference internal" href="#default-settings">Default settings</a></li>
<li><a class="reference internal" href="#coordinate-frames">Coordinate frames</a></li>
<li><a class="reference internal" href="#frame-orientations">Frame orientations</a></li>
<li><a class="reference internal" href="#solver-parameters">Solver parameters</a><ul>
<li><a class="reference internal" href="#impedance">Impedance</a></li>
<li><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
<li><a class="reference internal" href="#contact-parameters">Contact parameters</a></li>
<li><a class="reference internal" href="#contact-override">Contact override</a></li>
<li><a class="reference internal" href="#user-parameters">User parameters</a></li>
<li><a class="reference internal" href="#solver-settings">Solver settings</a></li>
<li><a class="reference internal" href="#actuator-shortcuts">Actuator shortcuts</a></li>
<li><a class="reference internal" href="#actuator-force-clamping">Actuator force clamping</a></li>
<li><a class="reference internal" href="#activation-clamping">Activation clamping</a></li>
<li><a class="reference internal" href="#actuator-length-range">Actuator length range</a></li>
<li><a class="reference internal" href="#muscle-actuators">Muscle actuators</a></li>
<li><a class="reference internal" href="#sensors">Sensors</a></li>
<li><a class="reference internal" href="#composite-objects">Composite objects</a></li>
<li><a class="reference internal" href="#including-files">Including files</a></li>
<li><a class="reference internal" href="#naming-elements">Naming elements</a></li>
<li><a class="reference internal" href="#urdf-extensions">URDF extensions</a></li>
<li><a class="reference internal" href="#mocap-bodies">MoCap bodies</a></li>
<li><a class="reference internal" href="#memory-allocation">Memory allocation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tips-and-tricks">Tips and tricks</a><ul>
<li><a class="reference internal" href="#backlash">Backlash</a></li>
<li><a class="reference internal" href="#damping">Damping</a></li>
<li><a class="reference internal" href="#restitution">Restitution</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/scripts/furo.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/katex.min.js"></script>
    <script src="_static/auto-render.min.js"></script>
    <script src="_static/katex_autorenderer.js"></script>
    </body>
</html>